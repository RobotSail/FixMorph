# -*- coding: utf-8 -*-

''' Main vector generation functions '''

import os
from Utils import err_exit, exec_com, remove_Hexa
import ASTVector
import ASTparser
import Print

def gen_AST(file, src_dir):
    
    # Check that we have an appropriate file
    if not os.path.isfile(file):
        err_exit("This is not a file: \n" + file)
    
    # Uses clang -ast-dump to generate an AST for file an saves it in "AST"
    c = "clang -Xclang -ast-dump -fsyntax-only -fno-diagnostics-color " + \
        "-ferror-limit=0 -w -I /usr/include/ -I /usr/local/include/ -I " + \
        src_dir + " "
    
    # We try to include any .h file stated in the .c file
    d = "cat " + file + " | grep -P '#include (\"|<)' | grep '\.h' > output/hs"
    exec_com(d, False)
    includes = set()
    with open('output/hs', 'r', errors='replace') as h_files:
        line = h_files.readline().strip()
        while line:
            if line[:9] == "#include ":
                # For cases of the form '#include "****.h"'
                if '"' in line:
                    line = line.split('"')[1]
                # For cases of the form '#include <****.h>'
                else:
                    line = line.split('<')[1].split('>')[0]
                # We only keep the file name or find doesn't work
                line = line.split("/")[-1]
                c1 = "find " + src_dir + " -name '" + line + "'"
                l = exec_com(c1, False)[0].split("\n")
                for i in l:
                    i = i.split("/")
                    if len(i) > 2:
                        # Here we get the directory and the parent directory
                        includes.add("/".join(i[:-1]))
                        includes.add("/".join(i[:-2]))
            line = h_files.readline().strip()
    for include in includes:
        c += "-I " + include + " "
    c += file + " > " + file + ".AST 2>> output/errors"
    try:
        exec_com(c, False)
    except Exception as e:
        err_exit(e, "Error with clang AST dump on file:", file,
                 "Reproduce with command:", c.replace("2>> errors", ""),
                 "or look at file 'errors'.")


def gen_vec(proj, proj_attribute, file, f_or_struct, start, end, Deckard=True):
    v = ASTVector.ASTVector(proj, file, f_or_struct, start, end, Deckard)
    if not v.vector:
        return None
    if file in proj_attribute.keys():
        proj_attribute[file][f_or_struct] = v
    else:
        proj_attribute[file] = dict()
        proj_attribute[file][f_or_struct] = v
    return v

def ASTdump(file, output):
    c = "crochet-diff -s 2147483647 -ast-dump-json " + file + \
        " 2>> output/errors_AST_dump > " + output
    exec_com(c, False)

def gen_json(filepath):
    json_file = filepath + ".ASTalt"
    ASTdump(filepath, json_file)
    return ASTparser.AST_from_file(json_file)

def parseAST(filepath, proj, Deckard=True):
    try:
        
        # OLD CODE #        
        
        gen_AST(filepath, proj.path)
        # Path to the AST file generated by gen_AST
        AST = filepath + ".AST"
        
        # NEW CODE #
        try:
            ast = gen_json(filepath)
        except:
            Print.yellow("Skipping... Failed for file:\n\t" + filepath)
            return ""
        
    except Exception as e:
        err_exit(e, "Unexpected error in gen_AST with file:", filepath)
        
    # Save functions here
    function_lines = []
    # Save variables for each function d[function] = "typevar namevar; ...;"
    dict_file = dict()
    # If we're inside the tree parsing a function
    in_function = False
    # If we're inside the tree parsing a struct
    #in_struct = False
    # Start and ending line of the function/struct
    start = 0
    end = 0
    
    file = filepath.split("/")[-1]
    
    if Deckard:
        Print.grey("Generating vectors for " + filepath.split("/")[-1])
        
    
    # NEW CODE #
    
    for node in ast:
        if "FunctionDecl" in node.type:
            #Print.yellow(node.value)
            for child_node in node.children:
                #Print.yellow(child_node.type)
                pass
                
    
    
    # CURRENT CODE #
    with open(AST, 'r', errors='replace') as ast:
        # A line is a node of the AST
        line = ast.readline().strip()
        # Skip irrelevant things from other files
        while line:
            if filepath in line and ".c" not in line.replace(file, ""):
                break
            line = ast.readline().strip()
        # We find Function declarations and retrieve parameters and variables
        while line:
            if len(line) > 2:
                if line[2].isalpha():
                    in_function = False
            # Skip irrelevant things from other files
            if ".h" in line or ".c" in line.replace(file, ""):
                while line:
                    if filepath in line and ".c" not in line.replace(file, ""):
                        break
                    line = ast.readline().strip()
            # Function declaration: Capture start, end and use Deckard on it
            elif "-FunctionDecl " in line:
                line = line.split(" ")
                if line[-1] != "extern":
                    line = remove_Hexa(line)
                    lines = line.split("> ")
                    if (len(lines) != 2) or (filepath in lines[1]) \
                       or ("col:" in lines[1]):
                        in_function = False
                    else:
                        lines = lines[0].split(" <")[-1].split(",")
                        if len(lines) == 2:
                            if ((lines[0].count("line") == 1 or
                                 lines[0].count(filepath) == 1) and \
                                (lines[1].count("line") == 1)):
                                try:
                                    start = lines[0].split(":")[1]
                                    end = lines[1].split(":")[1]
                                    f = line.split(" '")[-2].split(" ")[-1]
                                except Exception as e:
                                    err_exit(e, "Fail parsing FunctionDecl.")
                                in_function = True
                                try:
                                    start = int(start)
                                    end = int(end)
                                except Exception as e:
                                    err_exit("Parsing error, not ints.", start,
                                             end, line, lines, e)
                                function_lines.append((f, start, end))
                                gen_vec(proj, proj.funcs, filepath, f, start,
                                        end, Deckard)
                else:
                    in_function = False
            # Capture variable in function
            elif in_function and ("VarDecl " in line) and \
                 ("invalid sloc" not in line):
                line = "-".join(line.split("-")[1:]).split(" ")
                line = remove_Hexa(line).split(" '")
                var_type = " '".join(line[1:]).split("'")[0]
                line = line[0].split(" ")
                line = line[0].replace("Decl", "") + " " + line[-1]
                line = line.replace("  ", "").split(" ")
                line = line[0] + " " + var_type + " " + line[1] + ";"
                if f not in dict_file.keys():
                    dict_file[f] = ""
                dict_file[f] = dict_file[f] + line
                
            line = ast.readline().strip()
    
    with open('output/function-lines', 'w') as func_l:
        for l in function_lines:
            func_l.write(l[0] + " " + str(l[1]) + "-" + str(l[2]) + "\n")
    with open('output/function-vars', 'w') as func_l:
        for func in dict_file.keys():
            func_l.write(func + "\n")
            for line in dict_file[func].split(";"):
                func_l.write("\t" + line.replace("  ", "") + "\n")
    if Deckard:
        get_vars(proj, filepath, dict_file)
    return function_lines, dict_file


def get_vars(proj, file, dict_file):
    for func in dict_file.keys():
        for line in dict_file[func].split(";"):
            if file in proj.funcs.keys():
                if func in proj.funcs[file].keys():
                    if "ParmVar" in line:
                        line = line.replace("  ", "").replace("ParmVar ", "")
                        proj.funcs[file][func].params.append(line)
                    else:
                        line = line.replace("  ", "").replace("Var ", "")
                        proj.funcs[file][func].variables.append(line)
                        

def intersect(start, end, start2, end2):
    return not (end2 < start or start2 > end)
    
                        
def find_affected_funcs(proj, file, pertinent_lines):
    try:
        function_lines, dict_file = parseAST(file, proj, False)
    except Exception as e:
        err_exit(e, "Error in parseAST.")
    for start2, end2 in pertinent_lines:
        for f, start, end in function_lines:
            if intersect(start, end, start2, end2):
                if file not in proj.funcs.keys():
                    proj.funcs[file] = dict()
                if f not in proj.funcs[file]:
                    proj.funcs[file][f] = ASTVector.ASTVector(proj, file, f,
                                                              start, end, True)
                    Print.rose("\t\tFunction successfully found: " + f + \
                               " in " + file.replace(proj.path, 
                                                     proj.name + "/"))
                    Print.grey("\t\t\t" + f + " " + str(start) + "-" + \
                               str(end), False)
                break
    get_vars(proj, file, dict_file)
    return function_lines, dict_file