# -*- coding: utf-8 -*-
"""
Created on Mon Jul  2 17:09:28 2018

@author: pedrobw
"""

''' Main vector generation functions '''

import os
from Utils import err_exit, exec_com, remove_Hexa
import ASTVector
import Print

def gen_AST(file, src_dir):
    
    # Check that we have an appropriate file
    if not os.path.isfile(file):
        err_exit("This is not a file: \n" + file)
        
    # Uses clang -ast-dump to generate an AST for file an saves it in "AST"
    c = "clang -Xclang -ast-dump -fsyntax-only -fno-diagnostics-color " + \
        "-ferror-limit=0 -w -I /usr/include/ -I /usr/local/include/ "
    
    # We try to include any .h file stated in the .c file
    d = "cat " + file + " | grep '#include ' | grep '\.h' > output/hs"
    exec_com(d, False)
    includes = set()
    with open('output/hs', 'r', errors='replace') as h_files:
        line = h_files.readline().strip()
        while line:
            # For cases of the form '#include "****.h"'
            if '"' in line:
                line = line.split('"')[1]
            # For cases of the form '#include <****.h>'
            else:
                line = line.split('<')[1].split('>')[0]
            # We only keep the file name or find doesn't work
            line = line.split("/")[-1]
            c1 = "find " + src_dir + " -name '" + line + "'"
            l = exec_com(c1, False)[0].split("\n")
            for i in l:
                i = i.split("/")
                if len(i) > 2:
                    # Here we get the directory and the parent directory
                    includes.add("/".join(i[:-1]))
                    includes.add("/".join(i[:-2]))
            line = h_files.readline().strip()
    for include in includes:
        c += "-I " + include + " "
    c += file + " > " + file + ".AST 2>> output/errors"
    try:
        exec_com(c, False)
    except Exception as e:
        err_exit(e, "Error with clang AST dump on file:", file,
                 "Reproduce with command:", c.replace("2>> errors", ""),
                 "or look at file 'errors'.")


def gen_vec(proj, project_attribute, file, func_or_struct, start, end, Deckard=True):
    v = ASTVector.ASTVector(proj, file, func_or_struct, start, end, Deckard)
    if not v.vector:
        return None
    if file in project_attribute.keys():
        project_attribute[file][func_or_struct] = v
    else:
        project_attribute[file] = dict()
        project_attribute[file][func_or_struct] = v
    return v


def parseAST(filepath, proj, Deckard=True):
    try:
        gen_AST(filepath, proj.path)
        # Path to the AST file generated by gen_AST
        AST = filepath + ".AST"
    except Exception as e:
        err_exit(e, "Unexpected error in gen_AST with file:", filepath)
    # Keep functions here
    function_lines = []
    # Keep structures here
    #structure_lines = []
    # Keep variables for each function d[function] = "typevar namevar; ...;"
    dict_file = dict()
    # If we're inside the tree parsing a function
    in_function = False
    # If we're inside the tree parsing a struct
    #in_struct = False
    # Start and ending line of the function/struct
    start = 0
    end = 0
    
    file = filepath.split("/")[-1]
    
    if Deckard:
        Print.grey("Generating vectors for " + filepath.split("/")[-1])
    
    
    with open(AST, 'r', errors='replace') as ast:
        # A line is a node of the AST
        line = ast.readline().strip()
        # Skip irrelevant things from other files
        while line:
            if filepath in line and ".c" not in line.replace(file, ""):
                break
            line = ast.readline().strip()
        # We find Function declarations and retrieve parameters and variables
        while line:
            # Skip irrelevant things from other files
            if ".h" in line or ".c" in line.replace(file, ""):
                in_function = False
                #in_struct = False
                while line:
                    if filepath in line and ".c" not in line.replace(file, ""):
                        break
                    line = ast.readline().strip()
            # Function declaration: Capture start, end and use Deckard on it
            elif (("-FunctionDecl " in line) and ("col:" not in line) and 
                "invalid sloc" not in line):
                #in_struct = False
                line = line.split(" ")
                if line[-1] != "extern":
                    line = remove_Hexa(line)
                    # col: appears for .h files and other references
                    lines_aux = line.split("> ")
                    lines = lines_aux[0].split(" <")[1]
                    if "invalid" not in lines:
                        try:
                            start = lines_aux[1].split(":")[1]
                            end = lines.split(", ")[1]
                            end = end.split(":")[1]
                            f = line.split(" '")[-2].split(" ")[-1]
                        except Exception as e:
                            err_exit(e, ":(")
                        in_function = True
                        try:
                            start = int(start)
                            end = int(end)
                        except Exception as e:
                            err_exit("Parsing error, not ints.", start, end, 
                                     line, lines_aux, lines, e)
                        function_lines.append((f, start, end))
                        gen_vec(proj, proj.funcs, filepath, f, start, end,
                                Deckard)
                    else:
                        in_function = False
                else:
                    in_function = False
            # Capture variable in function
            elif in_function and ("VarDecl " in line) and \
                 ("invalid sloc" not in line):
                #in_struct = False
                line = "-".join(line.split("-")[1:]).split(" ")
                line = remove_Hexa(line).split(" '")
                # TODO: Get variable types
                var_type = " '".join(line[1:]).split("'")[0]
                line = line[0].split(" ")
                line = line[0].replace("Decl", "") + " " + line[-1]
                line = line.replace("  ", "").split(" ")
                line = line[0] + " " + var_type + " " + line[1] + ";"
                if f not in dict_file.keys():
                    dict_file[f] = ""
                dict_file[f] = dict_file[f] + line
                
            # FIXME: This also accounts for struct declarations inside function
            '''
            elif ("-RecordDecl " in line) and ("struct" in line):
                in_function = False
                line = line.split(" ")
                line = remove_Hexa(line)
                if "invalid sloc" not in line and "scratch space" not in line:
                    in_struct = True
                    try:
                        lines = line.split("> ")[0].split(" <")[1].split(",")
                        start = lines[0].split(":")[1]
                        end = lines[1].split(":")[1]
                    except:
                        err_exit(line, lines, "RecordDecl error")
            elif in_struct and ("-FieldDecl" in line):
                if False:
                    Print.green("\t" + line)
            elif in_struct and ("-TypedefDecl" in line):
                try:
                    if len(line) > 2 and start and end:
                        struct = line.split(" '")[-2].split(" ")[-1]
                        structure_lines.append((struct, int(start), int(end)))
                        gen_vec(proj, proj.structs, filepath, struct, start,
                                end, False)
                except Exception as e:
                    err_exit(e)
                in_struct = False
            '''
            line = ast.readline().strip()
    
    with open('output/function-lines', 'w') as func_l:
        for l in function_lines:
            func_l.write(l[0] + " " + str(l[1]) + "-" + str(l[2]) + "\n")
    with open('output/function-vars', 'w') as func_l:
        for func in dict_file.keys():
            func_l.write(func + "\n")
            for line in dict_file[func].split(";"):
                func_l.write("\t" + line.replace("  ", "") + "\n")
    if Deckard:
        get_vars(proj, filepath, dict_file)
    return function_lines, dict_file


def get_vars(proj, file, dict_file):
    for func in dict_file.keys():
        for line in dict_file[func].split(";"):
            if file in proj.funcs.keys():
                if func in proj.funcs[file].keys():
                    if "ParmVar" in line:
                        line = line.replace("  ", "").replace("ParmVar ", "")
                        proj.funcs[file][func].params.append(line)
                    else:
                        line = line.replace("  ", "").replace("Var ", "")
                        proj.funcs[file][func].variables.append(line)
                        

def intersect(start, end, start2, end2):
    return not (end2 < start or start2 > end)
    
                        
def find_affected_funcs(proj, file, pertinent_lines):
    try:
        function_lines, dict_file = parseAST(file, proj, False)
    except Exception as e:
        err_exit(e, "Error in parseAST.")
    for start2, end2 in pertinent_lines:
        for f, start, end in function_lines:
            if intersect(start, end, start2, end2):
                if file not in proj.funcs.keys():
                    proj.funcs[file] = dict()
                if f not in proj.funcs[file]:
                    proj.funcs[file][f] = ASTVector.ASTVector(proj, file, f,
                                                              start, end, True)
                    Print.rose("\t\tFunction successfully found in " + \
                               file.split("/")[-1])
                    Print.grey("\t\t\t" + f + " " + str(start) + "-" + \
                               str(end), False)
                break
    get_vars(proj, file, dict_file)
    return function_lines, dict_file