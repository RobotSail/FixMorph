[K	

####################################################################################################

	Crochet - Horizontal Code Edit Transfer
	Test conducted on: 30-Jan-2020 (23:02:28.268389)

####################################################################################################
[K
====================================================================================================

	Initializing project for Transfer
====================================================================================================

[K
	loading configuration
	__________________________________________________________________________________________

[K		reading configuration values
[K
	set environment
	__________________________________________________________________________________________

[K		setting environment values
[K
====================================================================================================

	Building Projects
====================================================================================================

[K
	building binaries
	__________________________________________________________________________________________

[K
		restoring projects
		------------------------------------------------------------------------------------------

[K		/hostap/CVE-2017-13077_Android/hostap-2016/src/
[K		/hostap/CVE-2017-13077_Android/hostap-2017/src/
[K		/hostap/CVE-2017-13077_Android/Android/src/
[K		/hostap/CVE-2017-13077_Android/Android/src-patch/
[K
		cleaning projects
		------------------------------------------------------------------------------------------

[K		/hostap/CVE-2017-13077_Android/hostap-2016/src/
[K		/hostap/CVE-2017-13077_Android/hostap-2017/src/
[K		/hostap/CVE-2017-13077_Android/Android/src/
[K		/hostap/CVE-2017-13077_Android/Android/src-patch/
[K
		configuring projects
		------------------------------------------------------------------------------------------

[K		/hostap/CVE-2017-13077_Android/hostap-2016/src/
[K		/hostap/CVE-2017-13077_Android/hostap-2017/src/
[K		/hostap/CVE-2017-13077_Android/Android/src/
[K		/hostap/CVE-2017-13077_Android/Android/src-patch/
[K
		building projects
		------------------------------------------------------------------------------------------

[K		/hostap/CVE-2017-13077_Android/hostap-2016/src/
[K		/hostap/CVE-2017-13077_Android/hostap-2017/src/
[K		/hostap/CVE-2017-13077_Android/Android/src/
[K		/hostap/CVE-2017-13077_Android/Android/src-patch/
[K
	Successful building binaries, after 47.09286069869995 seconds.
[K
====================================================================================================

	Analysing Changes
====================================================================================================

[K
	analysing source diff
	__________________________________________________________________________________________

[K		finding changed files...
[K
		analysing header files
		------------------------------------------------------------------------------------------

[K			extracting changed header files...
[K			header files:
[K				/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth.h
[K				/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth_i.h
[K
		analysing C/CPP source files
		------------------------------------------------------------------------------------------

[K			extracting changed c/cpp files...
[K			source files:
[K				/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/ieee802_11.c
[K				/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth.c
[K				/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth_ft.c
[K
		analysing changed code segments
		------------------------------------------------------------------------------------------

[K			collecting diff info...
[K			/hostap/CVE-2017-13077_Android/hostap-2016/src/:
[K				add_associated_sta in Pa/ap/ieee802_11.c
[K				add_associated_sta 2628-2682[K[K			/hostap/CVE-2017-13077_Android/hostap-2017/src/:
[K				add_associated_sta in Pb/ap/ieee802_11.c
[K				add_associated_sta 2628-2692[K[K			/hostap/CVE-2017-13077_Android/hostap-2016/src/:
[K				wpa_auth_sm_event in Pa/ap/wpa_auth.c
[K				wpa_auth_sm_event 1708-1820[K[K				wpa_auth_sta_wpa_version in Pa/ap/wpa_auth.c
[K				wpa_auth_sta_wpa_version 3936-3941[K[K			/hostap/CVE-2017-13077_Android/hostap-2017/src/:
[K				wpa_auth_sm_event in Pb/ap/wpa_auth.c
[K				wpa_auth_sm_event 1708-1823[K[K				wpa_auth_sta_wpa_version in Pb/ap/wpa_auth.c
[K				wpa_auth_sta_wpa_version 3939-3944[K[K			/hostap/CVE-2017-13077_Android/hostap-2016/src/:
[K				wpa_ft_install_ptk in Pa/ap/wpa_auth_ft.c
[K				wpa_ft_install_ptk 1926-1952[K[K				wpa_ft_process_auth_req in Pa/ap/wpa_auth_ft.c
[K				wpa_ft_process_auth_req 2044-2189[K[K			/hostap/CVE-2017-13077_Android/hostap-2017/src/:
[K				wpa_ft_install_ptk in Pb/ap/wpa_auth_ft.c
[K				wpa_ft_install_ptk 1926-1961[K[K				wpa_ft_process_auth_req in Pb/ap/wpa_auth_ft.c
[K				wpa_ft_process_auth_req 2053-2199[K[K
	Successful analysing source diff, after 7.328349590301514 seconds.
[K
	analysing ast diff
	__________________________________________________________________________________________

[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth_ft.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:1939
[K			filtering AST script by merging and grouping
[K			merging AST script
[K		line number:2154
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/ieee802_11.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:2641
[K			filtering AST script by merging and grouping
[K			merging AST script
[K		line number:2642
[K			filtering AST script by merging and grouping
[K			merging AST script
[K		line number:2669
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:1786
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/ieee802_11.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:2665
[K			filtering AST script by merging and grouping
[K			merging AST script
[K		line number:2639
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:3940
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/ieee802_11.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:2632
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth_ft.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:1951
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
	Successful analysing ast diff, after 50.810117959976196 seconds.
[K
====================================================================================================

	Clone Detection
====================================================================================================

[K
	generating vectors for target
	__________________________________________________________________________________________

[K
		Generating vector files for all functions in Target
		------------------------------------------------------------------------------------------

[K			generating vectors for *\.c files in Pc...
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/common/ctrl_iface_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/common/wpa_helpers.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/common/cli.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/common/wpa_ctrl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/wps/wps_registrar.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/wps/wps_validate.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/fst/fst.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/fst/fst_ctrl_aux.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/fst/fst_session.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/fst/fst_ctrl_iface.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/fst/fst_group.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/fst/fst_iface.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/vlan_ioctl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/taxonomy.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/acs.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/mbo_ap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/vlan_util.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/vlan_full.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/fils_hlp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/ieee802_11_he.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/l2_packet/l2_packet_freebsd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/l2_packet/l2_packet_pcap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/l2_packet/l2_packet_privsep.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/l2_packet/l2_packet_winpcap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/l2_packet/l2_packet_ndis.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/l2_packet/l2_packet_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_otp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_sim.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_md5.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_pax.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_ikev2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_tnc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_gpsk.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_aka.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_fast_pac.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_pwd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_mschapv2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_psk.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_tls_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_fast.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_proxy_dummy.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/tncc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/ikev2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_ttls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_leap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_sake.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_gtc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_peap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_eke.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_wsc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_tls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/mschapv2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/crypto/sha384.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/crypto/tls_openssl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_-2017-13088_11_1/FreeBSD-11.1/src/crypto/sha384-internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/crypto/tls_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/crypto/crypto_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/crypto/fips_prf_openssl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/crypto/crypto_gnutls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/crypto/tls_gnutls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/crypto/tls_openssl_ocsp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/crypto/crypto_openssl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/crypto/crypto_libtomcrypt.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/crypto/sha256-kdf.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/crypto/sha1-internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/crypto/sha384-prf.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/tls/libtommath.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/os_win32.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/ext_password.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/browser-system.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/os_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/browser-android.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/eloop_win.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/xml-utils.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/edit_simple.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/browser-wpadebug.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/http_curl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/browser.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/pcsc_funcs.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/os_internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/xml_libxml2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/utils/edit_readline.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/radius/radius.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13088_11_1/FreeBSD-11.1/src/drivers/driver_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_monitor.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_android.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_event.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_hostap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_privsep.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/linux_ioctl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_wext.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_ndis.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_bsd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/drivers.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_wired.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_atheros.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/ndis_events.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/netlink.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_nl80211.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_openbsd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_roboswitch.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_macsec_qca.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_capa.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/rfkill.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_scan.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_ndis_.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_wsc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_gpsk.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_gtc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_eke.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_mschapv2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_tls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_pax.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_tls_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_md5.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_ikev2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_fast.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_peap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_sake.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_ttls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_sim.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_tnc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_aka.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_psk.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/tncs.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/ikev2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_sim_db.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_pwd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/pae/ieee802_1x_cp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/pae/ieee802_1x_kay.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/pae/ieee802_1x_key.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/pae/ieee802_1x_secy_ops.c
[K
	Successful generating vectors for target, after 463.5907483100891 seconds.
[K
	finding clones in target
	__________________________________________________________________________________________

[K
		Finding clone functions in Target
		------------------------------------------------------------------------------------------

[K		checking vectors for C files in Pa...
[K		checking vectors for C files in Pc...
[K		finding clones for edited functions:

[K			Finding match for wpa_auth_sm_event in $Pa/ap/wpa_auth.c:
[K			Function: wpa_auth_sm_event in $Pc/ap/wpa_auth.c
[K			Distance: 0.0002533212110277353

[K			Finding match for add_associated_sta in $Pa/ap/ieee802_11.c:
[K			Function: add_associated_sta in $Pc/ap/ieee802_11.c
[K			Distance: 0.0

[K			Finding match for wpa_auth_sta_wpa_version in $Pa/ap/wpa_auth.c:
[K			Function: wpa_sm_has_ptk in $Pc/rsn_supp/wpa.c
[K			Distance: 0.0

[K			Finding match for wpa_ft_install_ptk in $Pa/ap/wpa_auth_ft.c:
[K			Function: wpa_ft_install_ptk in $Pc/ap/wpa_auth_ft.c
[K			Distance: 0.0

[K			Finding match for wpa_ft_process_auth_req in $Pa/ap/wpa_auth_ft.c:
[K			Function: wpa_ft_process_auth_req in $Pc/ap/wpa_auth_ft.c
[K			Distance: 2.545294166451336e-06

[K
	Successful finding clones in target, after 120.65929532051086 seconds.
[K
====================================================================================================

	Generating GumTree script for patch
====================================================================================================

[K
	Starting generating script for C files...
	__________________________________________________________________________________________

[K	Generating edit script: wpa_auth.c to wpa_auth.c...
[K	Generating edit script: ieee802_11.c to ieee802_11.c...
[K	Generating edit script: wpa_auth.c to wpa_auth.c...
[K	Generating edit script: wpa_auth_ft.c to wpa_auth_ft.c...
[K	Generating edit script: wpa_auth_ft.c to wpa_auth_ft.c...
[K
	Successful generating script for C files, after 11.693644046783447 seconds.
[K
====================================================================================================

	Variable Mapping
====================================================================================================

[K
	Variable mapping for C files
	__________________________________________________________________________________________

[K	Generating mapping: wpa_auth_ft.c to wpa_auth_ft.c...
[K	Generating mapping: wpa_auth.c to wpa_auth.c...
[K	Generating mapping: wpa_auth.c to wpa.c...
[K	Generating mapping: ieee802_11.c to ieee802_11.c...
[K
====================================================================================================

	Translate GumTree Script
====================================================================================================

[K
	Translating scripts for C files
	__________________________________________________________________________________________

[K	Generating JSON temp files for each pertinent file...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth_ft.c in Pa...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2017/src/ap/wpa_auth_ft.c in Pb...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/Android/src/ap/wpa_auth_ft.c in Pc...
[K	Failed at locating match for EnumConstantDecl(11448)
[K	Trying to get pos anyway.
[K	Generating JSON temp files for each pertinent file...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth.c in Pa...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2017/src/ap/wpa_auth.c in Pb...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/Android/src/ap/wpa_auth.c in Pc...
[K	Failed at locating match for EnumConstantDecl(12975)
[K	Trying to get pos anyway.
[K	Failed at locating match for CaseStmt(20068)
[K	Trying to get pos anyway.
[K	Failed at match for child.
[K	Generating JSON temp files for each pertinent file...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth.c in Pa...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2017/src/ap/wpa_auth.c in Pb...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/Android/src/rsn_supp/wpa.c in Pc...
[K	Failed at locating match for EnumConstantDecl(12975)
[K	Trying to get pos anyway.
[K	Failed at locating match for FunctionDecl(13059)
[K	Trying to get pos anyway.
[K	Failed at locating match for FieldDecl(14884)
[K	Trying to get pos anyway.
[K	Failed at locating match for CaseStmt(20068)
[K	Trying to get pos anyway.
[K	Failed at match for child.
[K	Failed at locating match for FunctionDecl(24012)
[K	Trying to get pos anyway.
[K	Generating JSON temp files for each pertinent file...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2016/src/ap/ieee802_11.c in Pa...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2017/src/ap/ieee802_11.c in Pb...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/Android/src/ap/ieee802_11.c in Pc...
[K	Failed at locating match for EnumConstantDecl(21537)
[K	Trying to get pos anyway.
[K	Failed at match for child.
[K
====================================================================================================

	Applying transformation
====================================================================================================

[K
	Starting transplanting code...
	__________________________________________________________________________________________

[K
		/hostap/CVE-2017-13077_Android/Android/src/ap/wpa_auth_ft.c
		------------------------------------------------------------------------------------------

[K	Original AST script
[K			AST Script:
[K				 Insert EnumConstantDecl(11449) EnumDecl(11439) 9
[K				 Insert FunctionDecl(11540) TranslationUnitDecl(0) 696
[K				 Insert TypeLoc(11541) FunctionDecl(11540) 0
[K				 Insert TypeLoc(11542) TypeLoc(11541) 0
[K				 Insert ParmVarDecl(11543) TypeLoc(11541) 1
[K				 Insert TypeLoc(11544) ParmVarDecl(11543) 0
[K				 Insert TypeLoc(11545) TypeLoc(11544) 0
[K				 Insert TypeLoc(11546) TypeLoc(11545) 0
[K				 Insert FieldDecl(12326) RecordDecl(12225) 31
[K				 Insert TypeLoc(12327) FieldDecl(12326) 0
[K				 Insert IfStmt(18913) CompoundStmt(18879) 5
[K				 Insert MemberExpr(18914) IfStmt(18913) 0
[K				 Insert DeclRefExpr(18915) MemberExpr(18914) 0
[K				 Insert CompoundStmt(18916) IfStmt(18913) 1
[K				 Insert CallExpr(18917) CompoundStmt(18916) 0
[K				 Insert DeclRefExpr(18918) CallExpr(18917) 0
[K				 Insert DeclRefExpr(18919) CallExpr(18917) 1
[K				 Insert StringLiteral(18920) CallExpr(18917) 2
[K				 Insert ReturnStmt(18921) CompoundStmt(18916) 1
[K				 Insert BinaryOperator(18941) CompoundStmt(18879) 8
[K				 Insert MemberExpr(18942) BinaryOperator(18941) 0
[K				 Insert DeclRefExpr(18943) MemberExpr(18942) 0
[K				 Insert DeclRefExpr(18944) BinaryOperator(18941) 1
[K				 Insert BinaryOperator(19582) CompoundStmt(19226) 40
[K				 Insert MemberExpr(19583) BinaryOperator(19582) 0
[K				 Insert DeclRefExpr(19584) MemberExpr(19583) 0
[K				 Insert DeclRefExpr(19585) BinaryOperator(19582) 1
[K	Generated AST script
[K			AST Script:
[K				 Insert EnumConstantDecl(11449) into EnumDecl(11250) at 9
[K				 Insert FunctionDecl(11540) into TranslationUnitDecl(0) at 683
[K				 Insert FieldDecl(12326) into RecordDecl(11848) at 30
[K				 Insert IfStmt(18913) into CompoundStmt(14944) at 5
[K				 Insert BinaryOperator(18941) into CompoundStmt(14944) at 7
[K				 Insert BinaryOperator(19582) into CompoundStmt(15278) at 40
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth_ft.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth_ft.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth_ft.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth_ft.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth_ft.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth_ft.c
[K	Original Patch
[K		1939a1940,1947
[K		> 	if (sm->tk_already_set) {
[K		> 		/* Must avoid TK reconfiguration to prevent clearing of TX/RX
[K		> 		 * PN in the driver */
[K		> 		wpa_printf(MSG_DEBUG,
[K		> 			   "FT: Do not re-install same PTK to the driver");
[K		> 		return;
[K		> 	}
[K		>
[K		1951a1960
[K		> 	sm->tk_already_set = TRUE;
[K		2154a2164
[K		> 	sm->tk_already_set = FALSE;
[K	Generated Patch
[K		798a799,806
[K		>  if (sm->keycount) {
[K		> 		/* Must avoid TK reconfiguration to prevent clearing of TX/RX
[K		> 		 * PN in the driver */
[K		> 		wpa_printf(MSG_DEBUG,
[K		> 			   "FT: Do not re-install same PTK to the driver");
[K		> 		return;
[K		> 	}
[K		>
[K		811a820,821
[K		>  sm->keycount = TRUE;
[K		>
[K		1008a1019,1020
[K		>  sm->keycount = FALSE;
[K		>
[K
	Successful transformation
[K
		/hostap/CVE-2017-13077_Android/Android/src/ap/wpa_auth.c
		------------------------------------------------------------------------------------------

[K	Original AST script
[K			AST Script:
[K				 Insert EnumConstantDecl(12976) EnumDecl(12966) 9
[K				 Insert FunctionDecl(13067) TranslationUnitDecl(0) 811
[K				 Insert TypeLoc(13068) FunctionDecl(13067) 0
[K				 Insert TypeLoc(13069) TypeLoc(13068) 0
[K				 Insert ParmVarDecl(13070) TypeLoc(13068) 1
[K				 Insert TypeLoc(13071) ParmVarDecl(13070) 0
[K				 Insert TypeLoc(13072) TypeLoc(13071) 0
[K				 Insert TypeLoc(13073) TypeLoc(13072) 0
[K				 Insert FieldDecl(14894) RecordDecl(14793) 31
[K				 Insert TypeLoc(14895) FieldDecl(14894) 0
[K				 Insert CaseStmt(20081) CompoundStmt(19989) 12
[K				 Insert DeclRefExpr(20082) CaseStmt(20081) 0
[K				 Insert BinaryOperator(20083) CaseStmt(20081) 1
[K				 Insert MemberExpr(20084) BinaryOperator(20083) 0
[K				 Insert DeclRefExpr(20085) MemberExpr(20084) 0
[K				 Insert DeclRefExpr(20086) BinaryOperator(20083) 1
[K				 Insert ReturnStmt(20087) CompoundStmt(19989) 13
[K				 Insert IntegerLiteral(20088) ReturnStmt(20087) 0
[K				 Insert FunctionDecl(24047) TranslationUnitDecl(0) 1059
[K				 Insert TypeLoc(24048) FunctionDecl(24047) 0
[K				 Insert TypeLoc(24049) TypeLoc(24048) 0
[K				 Insert ParmVarDecl(24050) TypeLoc(24048) 1
[K				 Insert TypeLoc(24051) ParmVarDecl(24050) 0
[K				 Insert TypeLoc(24052) TypeLoc(24051) 0
[K				 Insert TypeLoc(24053) TypeLoc(24052) 0
[K				 Insert CompoundStmt(24054) FunctionDecl(24047) 1
[K				 Insert IfStmt(24055) CompoundStmt(24054) 0
[K				 Insert BinaryOperator(24056) IfStmt(24055) 0
[K				 Insert UnaryOperator(24057) BinaryOperator(24056) 0
[K				 Insert DeclRefExpr(24058) UnaryOperator(24057) 0
[K				 Insert UnaryOperator(24059) BinaryOperator(24056) 1
[K				 Insert CallExpr(24060) UnaryOperator(24059) 0
[K				 Insert DeclRefExpr(24061) CallExpr(24060) 0
[K				 Insert MemberExpr(24062) CallExpr(24060) 1
[K				 Insert DeclRefExpr(24063) MemberExpr(24062) 0
[K				 Insert ReturnStmt(24064) IfStmt(24055) 1
[K				 Insert IntegerLiteral(24065) ReturnStmt(24064) 0
[K				 Insert ReturnStmt(24066) CompoundStmt(24054) 1
[K				 Insert MemberExpr(24067) ReturnStmt(24066) 0
[K				 Insert DeclRefExpr(24068) MemberExpr(24067) 0
[K	Generated AST script
[K			AST Script:
[K				 Insert EnumConstantDecl(12976) into EnumDecl(12837) at 9
[K				 Insert FunctionDecl(13067) into TranslationUnitDecl(0) at 801
[K				 Insert FieldDecl(14894) into RecordDecl(14475) at 30
[K				 Insert CaseStmt(20081) into CompoundStmt(19518) at 12
[K				 Insert ReturnStmt(20087) into CompoundStmt(19518) at 13
[K				 Insert FunctionDecl(24047) into TranslationUnitDecl(0) at 1032
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth.c
[K	Original Patch
[K		1786a1787,1789
[K		> 	case WPA_DRV_STA_REMOVED:
[K		> 		sm->tk_already_set = FALSE;
[K		> 		return 0;
[K		3940a3944,3951
[K		> }
[K		>
[K		>
[K		> int wpa_auth_sta_ft_tk_already_set(struct wpa_state_machine *sm)
[K		> {
[K		> 	if (!sm || !wpa_key_mgmt_ft(sm->wpa_key_mgmt))
[K		> 		return 0;
[K		> 	return sm->tk_already_set;
[K	Generated Patch
[K		1,4218d0
[K		< /*
[K		<  * IEEE 802.11 RSN / WPA Authenticator
[K		<  * Copyright (c) 2004-2015, Jouni Malinen <j@w1.fi>
[K		<  *
[K		<  * This software may be distributed under the terms of the BSD license.
[K		<  * See README for more details.
[K		<  */
[K		<
[K		< #include "utils/includes.h"
[K		<
[K		< #include "utils/common.h"
[K		< #include "utils/eloop.h"
[K		< #include "utils/state_machine.h"
[K		< #include "utils/bitfield.h"
[K		< #include "common/ieee802_11_defs.h"
[K		< #include "crypto/aes.h"
[K		< #include "crypto/aes_wrap.h"
[K		< #include "crypto/aes_siv.h"
[K		< #include "crypto/crypto.h"
[K		< #include "crypto/sha1.h"
[K		< #include "crypto/sha256.h"
[K		< #include "crypto/random.h"
[K		< #include "eapol_auth/eapol_auth_sm.h"
[K		< #include "ap_config.h"
[K		< #include "ieee802_11.h"
[K		< #include "wpa_auth.h"
[K		< #include "pmksa_cache_auth.h"
[K		< #include "wpa_auth_i.h"
[K		< #include "wpa_auth_ie.h"
[K		<
[K		< #define STATE_MACHINE_DATA struct wpa_state_machine
[K		< #define STATE_MACHINE_DEBUG_PREFIX "WPA"
[K		< #define STATE_MACHINE_ADDR sm->addr
[K		<
[K		<
[K		< static void wpa_send_eapol_timeout(void *eloop_ctx, void *timeout_ctx);
[K		< static int wpa_sm_step(struct wpa_state_machine *sm);
[K		< static int wpa_verify_key_mic(int akmp, struct wpa_ptk *PTK, u8 *data,
[K		< 			      size_t data_len);
[K		< #ifdef CONFIG_FILS
[K		< static int wpa_aead_decrypt(struct wpa_state_machine *sm, struct wpa_ptk *ptk,
[K		< 			    u8 *buf, size_t buf_len, u16 *_key_data_len);
[K		< #endif /* CONFIG_FILS */
[K		< static void wpa_sm_call_step(void *eloop_ctx, void *timeout_ctx);
[K		< static void wpa_group_sm_step(struct wpa_authenticator *wpa_auth,
[K		< 			      struct wpa_group *group);
[K		< static void wpa_request_new_ptk(struct wpa_state_machine *sm);
[K		< static int wpa_gtk_update(struct wpa_authenticator *wpa_auth,
[K		< 			  struct wpa_group *group);
[K		< static int wpa_group_config_group_keys(struct wpa_authenticator *wpa_auth,
[K		< 				       struct wpa_group *group);
[K		< static int wpa_derive_ptk(struct wpa_state_machine *sm, const u8 *snonce,
[K		< 			  const u8 *pmk, unsigned int pmk_len,
[K		< 			  struct wpa_ptk *ptk);
[K		< static void wpa_group_free(struct wpa_authenticator *wpa_auth,
[K		< 			   struct wpa_group *group);
[K		< static void wpa_group_get(struct wpa_authenticator *wpa_auth,
[K		< 			  struct wpa_group *group);
[K		< static void wpa_group_put(struct wpa_authenticator *wpa_auth,
[K		< 			  struct wpa_group *group);
[K		< static u8 * ieee80211w_kde_add(struct wpa_state_machine *sm, u8 *pos);
[K		<
[K		< static const u32 eapol_key_timeout_first = 100; /* ms */
[K		< static const u32 eapol_key_timeout_subseq = 1000; /* ms */
[K		< static const u32 eapol_key_timeout_first_group = 500; /* ms */
[K		<
[K		< /* TODO: make these configurable */
[K		< static const int dot11RSNAConfigPMKLifetime = 43200;
[K		< static const int dot11RSNAConfigPMKReauthThreshold = 70;
[K		< static const int dot11RSNAConfigSATimeout = 60;
[K		<
[K		<
[K		< static inline int wpa_auth_mic_failure_report(
[K		< 	struct wpa_authenticator *wpa_auth, const u8 *addr)
[K		< {
[K		< 	if (wpa_auth->cb->mic_failure_report)
[K		< 		return wpa_auth->cb->mic_failure_report(wpa_auth->cb_ctx, addr);
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static inline void wpa_auth_psk_failure_report(
[K		< 	struct wpa_authenticator *wpa_auth, const u8 *addr)
[K		< {
[K		< 	if (wpa_auth->cb->psk_failure_report)
[K		< 		wpa_auth->cb->psk_failure_report(wpa_auth->cb_ctx, addr);
[K		< }
[K		<
[K		<
[K		< static inline void wpa_auth_set_eapol(struct wpa_authenticator *wpa_auth,
[K		< 				      const u8 *addr, wpa_eapol_variable var,
[K		< 				      int value)
[K		< {
[K		< 	if (wpa_auth->cb->set_eapol)
[K		< 		wpa_auth->cb->set_eapol(wpa_auth->cb_ctx, addr, var, value);
[K		< }
[K		<
[K		<
[K		< static inline int wpa_auth_get_eapol(struct wpa_authenticator *wpa_auth,
[K		< 				     const u8 *addr, wpa_eapol_variable var)
[K		< {
[K		< 	if (wpa_auth->cb->get_eapol == NULL)
[K		< 		return -1;
[K		< 	return wpa_auth->cb->get_eapol(wpa_auth->cb_ctx, addr, var);
[K		< }
[K		<
[K		<
[K		< static inline const u8 * wpa_auth_get_psk(struct wpa_authenticator *wpa_auth,
[K		< 					  const u8 *addr,
[K		< 					  const u8 *p2p_dev_addr,
[K		< 					  const u8 *prev_psk)
[K		< {
[K		< 	if (wpa_auth->cb->get_psk == NULL)
[K		< 		return NULL;
[K		< 	return wpa_auth->cb->get_psk(wpa_auth->cb_ctx, addr, p2p_dev_addr,
[K		< 				     prev_psk);
[K		< }
[K		<
[K		<
[K		< static inline int wpa_auth_get_msk(struct wpa_authenticator *wpa_auth,
[K		< 				   const u8 *addr, u8 *msk, size_t *len)
[K		< {
[K		< 	if (wpa_auth->cb->get_msk == NULL)
[K		< 		return -1;
[K		< 	return wpa_auth->cb->get_msk(wpa_auth->cb_ctx, addr, msk, len);
[K		< }
[K		<
[K		<
[K		< static inline int wpa_auth_set_key(struct wpa_authenticator *wpa_auth,
[K		< 				   int vlan_id,
[K		< 				   enum wpa_alg alg, const u8 *addr, int idx,
[K		< 				   u8 *key, size_t key_len)
[K		< {
[K		< 	if (wpa_auth->cb->set_key == NULL)
[K		< 		return -1;
[K		< 	return wpa_auth->cb->set_key(wpa_auth->cb_ctx, vlan_id, alg, addr, idx,
[K		< 				     key, key_len);
[K		< }
[K		<
[K		<
[K		< static inline int wpa_auth_get_seqnum(struct wpa_authenticator *wpa_auth,
[K		< 				      const u8 *addr, int idx, u8 *seq)
[K		< {
[K		< 	if (wpa_auth->cb->get_seqnum == NULL)
[K		< 		return -1;
[K		< 	return wpa_auth->cb->get_seqnum(wpa_auth->cb_ctx, addr, idx, seq);
[K		< }
[K		<
[K		<
[K		< static inline int
[K		< wpa_auth_send_eapol(struct wpa_authenticator *wpa_auth, const u8 *addr,
[K		< 		    const u8 *data, size_t data_len, int encrypt)
[K		< {
[K		< 	if (wpa_auth->cb->send_eapol == NULL)
[K		< 		return -1;
[K		< 	return wpa_auth->cb->send_eapol(wpa_auth->cb_ctx, addr, data, data_len,
[K		< 					encrypt);
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_MESH
[K		< static inline int wpa_auth_start_ampe(struct wpa_authenticator *wpa_auth,
[K		< 				      const u8 *addr)
[K		< {
[K		< 	if (wpa_auth->cb->start_ampe == NULL)
[K		< 		return -1;
[K		< 	return wpa_auth->cb->start_ampe(wpa_auth->cb_ctx, addr);
[K		< }
[K		< #endif /* CONFIG_MESH */
[K		<
[K		<
[K		< int wpa_auth_for_each_sta(struct wpa_authenticator *wpa_auth,
[K		< 			  int (*cb)(struct wpa_state_machine *sm, void *ctx),
[K		< 			  void *cb_ctx)
[K		< {
[K		< 	if (wpa_auth->cb->for_each_sta == NULL)
[K		< 		return 0;
[K		< 	return wpa_auth->cb->for_each_sta(wpa_auth->cb_ctx, cb, cb_ctx);
[K		< }
[K		<
[K		<
[K		< int wpa_auth_for_each_auth(struct wpa_authenticator *wpa_auth,
[K		< 			   int (*cb)(struct wpa_authenticator *a, void *ctx),
[K		< 			   void *cb_ctx)
[K		< {
[K		< 	if (wpa_auth->cb->for_each_auth == NULL)
[K		< 		return 0;
[K		< 	return wpa_auth->cb->for_each_auth(wpa_auth->cb_ctx, cb, cb_ctx);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_logger(struct wpa_authenticator *wpa_auth, const u8 *addr,
[K		< 		     logger_level level, const char *txt)
[K		< {
[K		< 	if (wpa_auth->cb->logger == NULL)
[K		< 		return;
[K		< 	wpa_auth->cb->logger(wpa_auth->cb_ctx, addr, level, txt);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_vlogger(struct wpa_authenticator *wpa_auth, const u8 *addr,
[K		< 		      logger_level level, const char *fmt, ...)
[K		< {
[K		< 	char *format;
[K		< 	int maxlen;
[K		< 	va_list ap;
[K		<
[K		< 	if (wpa_auth->cb->logger == NULL)
[K		< 		return;
[K		<
[K		< 	maxlen = os_strlen(fmt) + 100;
[K		< 	format = os_malloc(maxlen);
[K		< 	if (!format)
[K		< 		return;
[K		<
[K		< 	va_start(ap, fmt);
[K		< 	vsnprintf(format, maxlen, fmt, ap);
[K		< 	va_end(ap);
[K		<
[K		< 	wpa_auth_logger(wpa_auth, addr, level, format);
[K		<
[K		< 	os_free(format);
[K		< }
[K		<
[K		<
[K		< static void wpa_sta_disconnect(struct wpa_authenticator *wpa_auth,
[K		< 			       const u8 *addr)
[K		< {
[K		< 	if (wpa_auth->cb->disconnect == NULL)
[K		< 		return;
[K		< 	wpa_printf(MSG_DEBUG, "wpa_sta_disconnect STA " MACSTR, MAC2STR(addr));
[K		< 	wpa_auth->cb->disconnect(wpa_auth->cb_ctx, addr,
[K		< 				 WLAN_REASON_PREV_AUTH_NOT_VALID);
[K		< }
[K		<
[K		<
[K		< static int wpa_use_aes_cmac(struct wpa_state_machine *sm)
[K		< {
[K		< 	int ret = 0;
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt))
[K		< 		ret = 1;
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (wpa_key_mgmt_sha256(sm->wpa_key_mgmt))
[K		< 		ret = 1;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	if (sm->wpa_key_mgmt == WPA_KEY_MGMT_OSEN)
[K		< 		ret = 1;
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< static void wpa_rekey_gmk(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = eloop_ctx;
[K		<
[K		< 	if (random_get_bytes(wpa_auth->group->GMK, WPA_GMK_LEN)) {
[K		< 		wpa_printf(MSG_ERROR, "Failed to get random data for WPA "
[K		< 			   "initialization.");
[K		< 	} else {
[K		< 		wpa_auth_logger(wpa_auth, NULL, LOGGER_DEBUG, "GMK rekeyd");
[K		< 		wpa_hexdump_key(MSG_DEBUG, "GMK",
[K		< 				wpa_auth->group->GMK, WPA_GMK_LEN);
[K		< 	}
[K		<
[K		< 	if (wpa_auth->conf.wpa_gmk_rekey) {
[K		< 		eloop_register_timeout(wpa_auth->conf.wpa_gmk_rekey, 0,
[K		< 				       wpa_rekey_gmk, wpa_auth, NULL);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< static void wpa_rekey_gtk(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = eloop_ctx;
[K		< 	struct wpa_group *group, *next;
[K		<
[K		< 	wpa_auth_logger(wpa_auth, NULL, LOGGER_DEBUG, "rekeying GTK");
[K		< 	group = wpa_auth->group;
[K		< 	while (group) {
[K		< 		wpa_group_get(wpa_auth, group);
[K		<
[K		< 		group->GTKReKey = TRUE;
[K		< 		do {
[K		< 			group->changed = FALSE;
[K		< 			wpa_group_sm_step(wpa_auth, group);
[K		< 		} while (group->changed);
[K		<
[K		< 		next = group->next;
[K		< 		wpa_group_put(wpa_auth, group);
[K		< 		group = next;
[K		< 	}
[K		<
[K		< 	if (wpa_auth->conf.wpa_group_rekey) {
[K		< 		eloop_register_timeout(wpa_auth->conf.wpa_group_rekey,
[K		< 				       0, wpa_rekey_gtk, wpa_auth, NULL);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< static void wpa_rekey_ptk(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = eloop_ctx;
[K		< 	struct wpa_state_machine *sm = timeout_ctx;
[K		<
[K		< 	wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG, "rekeying PTK");
[K		< 	wpa_request_new_ptk(sm);
[K		< 	wpa_sm_step(sm);
[K		< }
[K		<
[K		<
[K		< static int wpa_auth_pmksa_clear_cb(struct wpa_state_machine *sm, void *ctx)
[K		< {
[K		< 	if (sm->pmksa == ctx)
[K		< 		sm->pmksa = NULL;
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_auth_pmksa_free_cb(struct rsn_pmksa_cache_entry *entry,
[K		< 				   void *ctx)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = ctx;
[K		< 	wpa_auth_for_each_sta(wpa_auth, wpa_auth_pmksa_clear_cb, entry);
[K		< }
[K		<
[K		<
[K		< static int wpa_group_init_gmk_and_counter(struct wpa_authenticator *wpa_auth,
[K		< 					  struct wpa_group *group)
[K		< {
[K		< 	u8 buf[ETH_ALEN + 8 + sizeof(unsigned long)];
[K		< 	u8 rkey[32];
[K		< 	unsigned long ptr;
[K		<
[K		< 	if (random_get_bytes(group->GMK, WPA_GMK_LEN) < 0)
[K		< 		return -1;
[K		< 	wpa_hexdump_key(MSG_DEBUG, "GMK", group->GMK, WPA_GMK_LEN);
[K		<
[K		< 	/*
[K		< 	 * Counter = PRF-256(Random number, "Init Counter",
[K		< 	 *                   Local MAC Address || Time)
[K		< 	 */
[K		< 	os_memcpy(buf, wpa_auth->addr, ETH_ALEN);
[K		< 	wpa_get_ntp_timestamp(buf + ETH_ALEN);
[K		< 	ptr = (unsigned long) group;
[K		< 	os_memcpy(buf + ETH_ALEN + 8, &ptr, sizeof(ptr));
[K		< 	if (random_get_bytes(rkey, sizeof(rkey)) < 0)
[K		< 		return -1;
[K		<
[K		< 	if (sha1_prf(rkey, sizeof(rkey), "Init Counter", buf, sizeof(buf),
[K		< 		     group->Counter, WPA_NONCE_LEN) < 0)
[K		< 		return -1;
[K		< 	wpa_hexdump_key(MSG_DEBUG, "Key Counter",
[K		< 			group->Counter, WPA_NONCE_LEN);
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static struct wpa_group * wpa_group_init(struct wpa_authenticator *wpa_auth,
[K		< 					 int vlan_id, int delay_init)
[K		< {
[K		< 	struct wpa_group *group;
[K		<
[K		< 	group = os_zalloc(sizeof(struct wpa_group));
[K		< 	if (group == NULL)
[K		< 		return NULL;
[K		<
[K		< 	group->GTKAuthenticator = TRUE;
[K		< 	group->vlan_id = vlan_id;
[K		< 	group->GTK_len = wpa_cipher_key_len(wpa_auth->conf.wpa_group);
[K		<
[K		< 	if (random_pool_ready() != 1) {
[K		< 		wpa_printf(MSG_INFO, "WPA: Not enough entropy in random pool "
[K		< 			   "for secure operations - update keys later when "
[K		< 			   "the first station connects");
[K		< 	}
[K		<
[K		< 	/*
[K		< 	 * Set initial GMK/Counter value here. The actual values that will be
[K		< 	 * used in negotiations will be set once the first station tries to
[K		< 	 * connect. This allows more time for collecting additional randomness
[K		< 	 * on embedded devices.
[K		< 	 */
[K		< 	if (wpa_group_init_gmk_and_counter(wpa_auth, group) < 0) {
[K		< 		wpa_printf(MSG_ERROR, "Failed to get random data for WPA "
[K		< 			   "initialization.");
[K		< 		os_free(group);
[K		< 		return NULL;
[K		< 	}
[K		<
[K		< 	group->GInit = TRUE;
[K		< 	if (delay_init) {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Delay group state machine start "
[K		< 			   "until Beacon frames have been configured");
[K		< 		/* Initialization is completed in wpa_init_keys(). */
[K		< 	} else {
[K		< 		wpa_group_sm_step(wpa_auth, group);
[K		< 		group->GInit = FALSE;
[K		< 		wpa_group_sm_step(wpa_auth, group);
[K		< 	}
[K		<
[K		< 	return group;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_init - Initialize WPA authenticator
[K		<  * @addr: Authenticator address
[K		<  * @conf: Configuration for WPA authenticator
[K		<  * @cb: Callback functions for WPA authenticator
[K		<  * Returns: Pointer to WPA authenticator data or %NULL on failure
[K		<  */
[K		< struct wpa_authenticator * wpa_init(const u8 *addr,
[K		< 				    struct wpa_auth_config *conf,
[K		< 				    const struct wpa_auth_callbacks *cb,
[K		< 				    void *cb_ctx)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth;
[K		<
[K		< 	wpa_auth = os_zalloc(sizeof(struct wpa_authenticator));
[K		< 	if (wpa_auth == NULL)
[K		< 		return NULL;
[K		< 	os_memcpy(wpa_auth->addr, addr, ETH_ALEN);
[K		< 	os_memcpy(&wpa_auth->conf, conf, sizeof(*conf));
[K		< 	wpa_auth->cb = cb;
[K		< 	wpa_auth->cb_ctx = cb_ctx;
[K		<
[K		< 	if (wpa_auth_gen_wpa_ie(wpa_auth)) {
[K		< 		wpa_printf(MSG_ERROR, "Could not generate WPA IE.");
[K		< 		os_free(wpa_auth);
[K		< 		return NULL;
[K		< 	}
[K		<
[K		< 	wpa_auth->group = wpa_group_init(wpa_auth, 0, 1);
[K		< 	if (wpa_auth->group == NULL) {
[K		< 		os_free(wpa_auth->wpa_ie);
[K		< 		os_free(wpa_auth);
[K		< 		return NULL;
[K		< 	}
[K		<
[K		< 	wpa_auth->pmksa = pmksa_cache_auth_init(wpa_auth_pmksa_free_cb,
[K		< 						wpa_auth);
[K		< 	if (wpa_auth->pmksa == NULL) {
[K		< 		wpa_printf(MSG_ERROR, "PMKSA cache initialization failed.");
[K		< 		os_free(wpa_auth->group);
[K		< 		os_free(wpa_auth->wpa_ie);
[K		< 		os_free(wpa_auth);
[K		< 		return NULL;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	wpa_auth->ft_pmk_cache = wpa_ft_pmk_cache_init();
[K		< 	if (wpa_auth->ft_pmk_cache == NULL) {
[K		< 		wpa_printf(MSG_ERROR, "FT PMK cache initialization failed.");
[K		< 		os_free(wpa_auth->group);
[K		< 		os_free(wpa_auth->wpa_ie);
[K		< 		pmksa_cache_auth_deinit(wpa_auth->pmksa);
[K		< 		os_free(wpa_auth);
[K		< 		return NULL;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		< 	if (wpa_auth->conf.wpa_gmk_rekey) {
[K		< 		eloop_register_timeout(wpa_auth->conf.wpa_gmk_rekey, 0,
[K		< 				       wpa_rekey_gmk, wpa_auth, NULL);
[K		< 	}
[K		<
[K		< 	if (wpa_auth->conf.wpa_group_rekey) {
[K		< 		eloop_register_timeout(wpa_auth->conf.wpa_group_rekey, 0,
[K		< 				       wpa_rekey_gtk, wpa_auth, NULL);
[K		< 	}
[K		<
[K		< #ifdef CONFIG_P2P
[K		< 	if (WPA_GET_BE32(conf->ip_addr_start)) {
[K		< 		int count = WPA_GET_BE32(conf->ip_addr_end) -
[K		< 			WPA_GET_BE32(conf->ip_addr_start) + 1;
[K		< 		if (count > 1000)
[K		< 			count = 1000;
[K		< 		if (count > 0)
[K		< 			wpa_auth->ip_pool = bitfield_alloc(count);
[K		< 	}
[K		< #endif /* CONFIG_P2P */
[K		<
[K		< 	return wpa_auth;
[K		< }
[K		<
[K		<
[K		< int wpa_init_keys(struct wpa_authenticator *wpa_auth)
[K		< {
[K		< 	struct wpa_group *group = wpa_auth->group;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Start group state machine to set initial "
[K		< 		   "keys");
[K		< 	wpa_group_sm_step(wpa_auth, group);
[K		< 	group->GInit = FALSE;
[K		< 	wpa_group_sm_step(wpa_auth, group);
[K		< 	if (group->wpa_group_state == WPA_GROUP_FATAL_FAILURE)
[K		< 		return -1;
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_deinit - Deinitialize WPA authenticator
[K		<  * @wpa_auth: Pointer to WPA authenticator data from wpa_init()
[K		<  */
[K		< void wpa_deinit(struct wpa_authenticator *wpa_auth)
[K		< {
[K		< 	struct wpa_group *group, *prev;
[K		<
[K		< 	eloop_cancel_timeout(wpa_rekey_gmk, wpa_auth, NULL);
[K		< 	eloop_cancel_timeout(wpa_rekey_gtk, wpa_auth, NULL);
[K		<
[K		< 	pmksa_cache_auth_deinit(wpa_auth->pmksa);
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	wpa_ft_pmk_cache_deinit(wpa_auth->ft_pmk_cache);
[K		< 	wpa_auth->ft_pmk_cache = NULL;
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		< #ifdef CONFIG_P2P
[K		< 	bitfield_free(wpa_auth->ip_pool);
[K		< #endif /* CONFIG_P2P */
[K		<
[K		<
[K		< 	os_free(wpa_auth->wpa_ie);
[K		<
[K		< 	group = wpa_auth->group;
[K		< 	while (group) {
[K		< 		prev = group;
[K		< 		group = group->next;
[K		< 		os_free(prev);
[K		< 	}
[K		<
[K		< 	os_free(wpa_auth);
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_reconfig - Update WPA authenticator configuration
[K		<  * @wpa_auth: Pointer to WPA authenticator data from wpa_init()
[K		<  * @conf: Configuration for WPA authenticator
[K		<  */
[K		< int wpa_reconfig(struct wpa_authenticator *wpa_auth,
[K		< 		 struct wpa_auth_config *conf)
[K		< {
[K		< 	struct wpa_group *group;
[K		< 	if (wpa_auth == NULL)
[K		< 		return 0;
[K		<
[K		< 	os_memcpy(&wpa_auth->conf, conf, sizeof(*conf));
[K		< 	if (wpa_auth_gen_wpa_ie(wpa_auth)) {
[K		< 		wpa_printf(MSG_ERROR, "Could not generate WPA IE.");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	/*
[K		< 	 * Reinitialize GTK to make sure it is suitable for the new
[K		< 	 * configuration.
[K		< 	 */
[K		< 	group = wpa_auth->group;
[K		< 	group->GTK_len = wpa_cipher_key_len(wpa_auth->conf.wpa_group);
[K		< 	group->GInit = TRUE;
[K		< 	wpa_group_sm_step(wpa_auth, group);
[K		< 	group->GInit = FALSE;
[K		< 	wpa_group_sm_step(wpa_auth, group);
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< struct wpa_state_machine *
[K		< wpa_auth_sta_init(struct wpa_authenticator *wpa_auth, const u8 *addr,
[K		< 		  const u8 *p2p_dev_addr)
[K		< {
[K		< 	struct wpa_state_machine *sm;
[K		<
[K		< 	if (wpa_auth->group->wpa_group_state == WPA_GROUP_FATAL_FAILURE)
[K		< 		return NULL;
[K		<
[K		< 	sm = os_zalloc(sizeof(struct wpa_state_machine));
[K		< 	if (sm == NULL)
[K		< 		return NULL;
[K		< 	os_memcpy(sm->addr, addr, ETH_ALEN);
[K		< 	if (p2p_dev_addr)
[K		< 		os_memcpy(sm->p2p_dev_addr, p2p_dev_addr, ETH_ALEN);
[K		<
[K		< 	sm->wpa_auth = wpa_auth;
[K		< 	sm->group = wpa_auth->group;
[K		< 	wpa_group_get(sm->wpa_auth, sm->group);
[K		<
[K		< 	return sm;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_sta_associated(struct wpa_authenticator *wpa_auth,
[K		< 			    struct wpa_state_machine *sm)
[K		< {
[K		< 	if (wpa_auth == NULL || !wpa_auth->conf.wpa || sm == NULL)
[K		< 		return -1;
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (sm->ft_completed) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"FT authentication already completed - do not "
[K		< 				"start 4-way handshake");
[K		< 		/* Go to PTKINITDONE state to allow GTK rekeying */
[K		< 		sm->wpa_ptk_state = WPA_PTK_PTKINITDONE;
[K		< 		sm->Pair = TRUE;
[K		< 		return 0;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		< #ifdef CONFIG_FILS
[K		< 	if (sm->fils_completed) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"FILS authentication already completed - do not start 4-way handshake");
[K		< 		/* Go to PTKINITDONE state to allow GTK rekeying */
[K		< 		sm->wpa_ptk_state = WPA_PTK_PTKINITDONE;
[K		< 		sm->Pair = TRUE;
[K		< 		return 0;
[K		< 	}
[K		< #endif /* CONFIG_FILS */
[K		<
[K		< 	if (sm->started) {
[K		< 		os_memset(&sm->key_replay, 0, sizeof(sm->key_replay));
[K		< 		sm->ReAuthenticationRequest = TRUE;
[K		< 		return wpa_sm_step(sm);
[K		< 	}
[K		<
[K		< 	wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 			"start authentication");
[K		< 	sm->started = 1;
[K		<
[K		< 	sm->Init = TRUE;
[K		< 	if (wpa_sm_step(sm) == 1)
[K		< 		return 1; /* should not really happen */
[K		< 	sm->Init = FALSE;
[K		< 	sm->AuthenticationRequest = TRUE;
[K		< 	return wpa_sm_step(sm);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_sta_no_wpa(struct wpa_state_machine *sm)
[K		< {
[K		< 	/* WPA/RSN was not used - clear WPA state. This is needed if the STA
[K		< 	 * reassociates back to the same AP while the previous entry for the
[K		< 	 * STA has not yet been removed. */
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	sm->wpa_key_mgmt = 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_free_sta_sm(struct wpa_state_machine *sm)
[K		< {
[K		< #ifdef CONFIG_P2P
[K		< 	if (WPA_GET_BE32(sm->ip_addr)) {
[K		< 		u32 start;
[K		< 		wpa_printf(MSG_DEBUG, "P2P: Free assigned IP "
[K		< 			   "address %u.%u.%u.%u from " MACSTR,
[K		< 			   sm->ip_addr[0], sm->ip_addr[1],
[K		< 			   sm->ip_addr[2], sm->ip_addr[3],
[K		< 			   MAC2STR(sm->addr));
[K		< 		start = WPA_GET_BE32(sm->wpa_auth->conf.ip_addr_start);
[K		< 		bitfield_clear(sm->wpa_auth->ip_pool,
[K		< 			       WPA_GET_BE32(sm->ip_addr) - start);
[K		< 	}
[K		< #endif /* CONFIG_P2P */
[K		< 	if (sm->GUpdateStationKeys) {
[K		< 		sm->group->GKeyDoneStations--;
[K		< 		sm->GUpdateStationKeys = FALSE;
[K		< 	}
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	os_free(sm->assoc_resp_ftie);
[K		< 	wpabuf_free(sm->ft_pending_req_ies);
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< 	os_free(sm->last_rx_eapol_key);
[K		< 	os_free(sm->wpa_ie);
[K		< 	wpa_group_put(sm->wpa_auth, sm->group);
[K		< 	os_free(sm);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_sta_deinit(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	if (sm->wpa_auth->conf.wpa_strict_rekey && sm->has_GTK) {
[K		< 		wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"strict rekeying - force GTK rekey since STA "
[K		< 				"is leaving");
[K		< 		eloop_cancel_timeout(wpa_rekey_gtk, sm->wpa_auth, NULL);
[K		< 		eloop_register_timeout(0, 500000, wpa_rekey_gtk, sm->wpa_auth,
[K		< 				       NULL);
[K		< 	}
[K		<
[K		< 	eloop_cancel_timeout(wpa_send_eapol_timeout, sm->wpa_auth, sm);
[K		< 	sm->pending_1_of_4_timeout = 0;
[K		< 	eloop_cancel_timeout(wpa_sm_call_step, sm, NULL);
[K		< 	eloop_cancel_timeout(wpa_rekey_ptk, sm->wpa_auth, sm);
[K		< 	if (sm->in_step_loop) {
[K		< 		/* Must not free state machine while wpa_sm_step() is running.
[K		< 		 * Freeing will be completed in the end of wpa_sm_step(). */
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Registering pending STA state "
[K		< 			   "machine deinit for " MACSTR, MAC2STR(sm->addr));
[K		< 		sm->pending_deinit = 1;
[K		< 	} else
[K		< 		wpa_free_sta_sm(sm);
[K		< }
[K		<
[K		<
[K		< static void wpa_request_new_ptk(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	sm->PTKRequest = TRUE;
[K		< 	sm->PTK_valid = 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_replay_counter_valid(struct wpa_key_replay_counter *ctr,
[K		< 				    const u8 *replay_counter)
[K		< {
[K		< 	int i;
[K		< 	for (i = 0; i < RSNA_MAX_EAPOL_RETRIES; i++) {
[K		< 		if (!ctr[i].valid)
[K		< 			break;
[K		< 		if (os_memcmp(replay_counter, ctr[i].counter,
[K		< 			      WPA_REPLAY_COUNTER_LEN) == 0)
[K		< 			return 1;
[K		< 	}
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_replay_counter_mark_invalid(struct wpa_key_replay_counter *ctr,
[K		< 					    const u8 *replay_counter)
[K		< {
[K		< 	int i;
[K		< 	for (i = 0; i < RSNA_MAX_EAPOL_RETRIES; i++) {
[K		< 		if (ctr[i].valid &&
[K		< 		    (replay_counter == NULL ||
[K		< 		     os_memcmp(replay_counter, ctr[i].counter,
[K		< 			       WPA_REPLAY_COUNTER_LEN) == 0))
[K		< 			ctr[i].valid = FALSE;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< static int ft_check_msg_2_of_4(struct wpa_authenticator *wpa_auth,
[K		< 			       struct wpa_state_machine *sm,
[K		< 			       struct wpa_eapol_ie_parse *kde)
[K		< {
[K		< 	struct wpa_ie_data ie;
[K		< 	struct rsn_mdie *mdie;
[K		<
[K		< 	if (wpa_parse_wpa_ie_rsn(kde->rsn_ie, kde->rsn_ie_len, &ie) < 0 ||
[K		< 	    ie.num_pmkid != 1 || ie.pmkid == NULL) {
[K		< 		wpa_printf(MSG_DEBUG, "FT: No PMKR1Name in "
[K		< 			   "FT 4-way handshake message 2/4");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	os_memcpy(sm->sup_pmk_r1_name, ie.pmkid, PMKID_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "FT: PMKR1Name from Supplicant",
[K		< 		    sm->sup_pmk_r1_name, PMKID_LEN);
[K		<
[K		< 	if (!kde->mdie || !kde->ftie) {
[K		< 		wpa_printf(MSG_DEBUG, "FT: No %s in FT 4-way handshake "
[K		< 			   "message 2/4", kde->mdie ? "FTIE" : "MDIE");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	mdie = (struct rsn_mdie *) (kde->mdie + 2);
[K		< 	if (kde->mdie[1] < sizeof(struct rsn_mdie) ||
[K		< 	    os_memcmp(wpa_auth->conf.mobility_domain, mdie->mobility_domain,
[K		< 		      MOBILITY_DOMAIN_ID_LEN) != 0) {
[K		< 		wpa_printf(MSG_DEBUG, "FT: MDIE mismatch");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (sm->assoc_resp_ftie &&
[K		< 	    (kde->ftie[1] != sm->assoc_resp_ftie[1] ||
[K		< 	     os_memcmp(kde->ftie, sm->assoc_resp_ftie,
[K		< 		       2 + sm->assoc_resp_ftie[1]) != 0)) {
[K		< 		wpa_printf(MSG_DEBUG, "FT: FTIE mismatch");
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: FTIE in EAPOL-Key msg 2/4",
[K		< 			    kde->ftie, kde->ftie_len);
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: FTIE in (Re)AssocResp",
[K		< 			    sm->assoc_resp_ftie, 2 + sm->assoc_resp_ftie[1]);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		<
[K		< static int wpa_receive_error_report(struct wpa_authenticator *wpa_auth,
[K		< 				    struct wpa_state_machine *sm, int group)
[K		< {
[K		< 	/* Supplicant reported a Michael MIC error */
[K		< 	wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 			 "received EAPOL-Key Error Request "
[K		< 			 "(STA detected Michael MIC failure (group=%d))",
[K		< 			 group);
[K		<
[K		< 	if (group && wpa_auth->conf.wpa_group != WPA_CIPHER_TKIP) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"ignore Michael MIC failure report since "
[K		< 				"group cipher is not TKIP");
[K		< 	} else if (!group && sm->pairwise != WPA_CIPHER_TKIP) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"ignore Michael MIC failure report since "
[K		< 				"pairwise cipher is not TKIP");
[K		< 	} else {
[K		< 		if (wpa_auth_mic_failure_report(wpa_auth, sm->addr) > 0)
[K		< 			return 1; /* STA entry was removed */
[K		< 		sm->dot11RSNAStatsTKIPRemoteMICFailures++;
[K		< 		wpa_auth->dot11RSNAStatsTKIPRemoteMICFailures++;
[K		< 	}
[K		<
[K		< 	/*
[K		< 	 * Error report is not a request for a new key handshake, but since
[K		< 	 * Authenticator may do it, let's change the keys now anyway.
[K		< 	 */
[K		< 	wpa_request_new_ptk(sm);
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_try_alt_snonce(struct wpa_state_machine *sm, u8 *data,
[K		< 			      size_t data_len)
[K		< {
[K		< 	struct wpa_ptk PTK;
[K		< 	int ok = 0;
[K		< 	const u8 *pmk = NULL;
[K		< 	unsigned int pmk_len;
[K		<
[K		< 	os_memset(&PTK, 0, sizeof(PTK));
[K		< 	for (;;) {
[K		< 		if (wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt)) {
[K		< 			pmk = wpa_auth_get_psk(sm->wpa_auth, sm->addr,
[K		< 					       sm->p2p_dev_addr, pmk);
[K		< 			if (pmk == NULL)
[K		< 				break;
[K		< 			pmk_len = PMK_LEN;
[K		< 		} else {
[K		< 			pmk = sm->PMK;
[K		< 			pmk_len = sm->pmk_len;
[K		< 		}
[K		<
[K		< 		if (wpa_derive_ptk(sm, sm->alt_SNonce, pmk, pmk_len, &PTK) < 0)
[K		< 			break;
[K		<
[K		< 		if (wpa_verify_key_mic(sm->wpa_key_mgmt, &PTK, data, data_len)
[K		< 		    == 0) {
[K		< 			ok = 1;
[K		< 			break;
[K		< 		}
[K		<
[K		< 		if (!wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt))
[K		< 			break;
[K		< 	}
[K		<
[K		< 	if (!ok) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "WPA: Earlier SNonce did not result in matching MIC");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	wpa_printf(MSG_DEBUG,
[K		< 		   "WPA: Earlier SNonce resulted in matching MIC");
[K		< 	sm->alt_snonce_valid = 0;
[K		< 	os_memcpy(sm->SNonce, sm->alt_SNonce, WPA_NONCE_LEN);
[K		< 	os_memcpy(&sm->PTK, &PTK, sizeof(PTK));
[K		< 	sm->PTK_valid = TRUE;
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< void wpa_receive(struct wpa_authenticator *wpa_auth,
[K		< 		 struct wpa_state_machine *sm,
[K		< 		 u8 *data, size_t data_len)
[K		< {
[K		< 	struct ieee802_1x_hdr *hdr;
[K		< 	struct wpa_eapol_key *key;
[K		< 	u16 key_info, key_data_length;
[K		< 	enum { PAIRWISE_2, PAIRWISE_4, GROUP_2, REQUEST,
[K		< 	       SMK_M1, SMK_M3, SMK_ERROR } msg;
[K		< 	char *msgtxt;
[K		< 	struct wpa_eapol_ie_parse kde;
[K		< 	const u8 *key_data;
[K		< 	size_t keyhdrlen, mic_len;
[K		< 	u8 *mic;
[K		<
[K		< 	if (wpa_auth == NULL || !wpa_auth->conf.wpa || sm == NULL)
[K		< 		return;
[K		< 	wpa_hexdump(MSG_MSGDUMP, "WPA: RX EAPOL data", data, data_len);
[K		<
[K		< 	mic_len = wpa_mic_len(sm->wpa_key_mgmt);
[K		< 	keyhdrlen = sizeof(*key) + mic_len + 2;
[K		<
[K		< 	if (data_len < sizeof(*hdr) + keyhdrlen) {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Ignore too short EAPOL-Key frame");
[K		< 		return;
[K		< 	}
[K		<
[K		< 	hdr = (struct ieee802_1x_hdr *) data;
[K		< 	key = (struct wpa_eapol_key *) (hdr + 1);
[K		< 	mic = (u8 *) (key + 1);
[K		< 	key_info = WPA_GET_BE16(key->key_info);
[K		< 	key_data = mic + mic_len + 2;
[K		< 	key_data_length = WPA_GET_BE16(mic + mic_len);
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Received EAPOL-Key from " MACSTR
[K		< 		   " key_info=0x%x type=%u mic_len=%u key_data_length=%u",
[K		< 		   MAC2STR(sm->addr), key_info, key->type,
[K		< 		   (unsigned int) mic_len, key_data_length);
[K		< 	wpa_hexdump(MSG_MSGDUMP,
[K		< 		    "WPA: EAPOL-Key header (ending before Key MIC)",
[K		< 		    key, sizeof(*key));
[K		< 	wpa_hexdump(MSG_MSGDUMP, "WPA: EAPOL-Key Key MIC",
[K		< 		    mic, mic_len);
[K		< 	if (key_data_length > data_len - sizeof(*hdr) - keyhdrlen) {
[K		< 		wpa_printf(MSG_INFO, "WPA: Invalid EAPOL-Key frame - "
[K		< 			   "key_data overflow (%d > %lu)",
[K		< 			   key_data_length,
[K		< 			   (unsigned long) (data_len - sizeof(*hdr) -
[K		< 					    keyhdrlen));
[K		< 		return;
[K		< 	}
[K		<
[K		< 	if (sm->wpa == WPA_VERSION_WPA2) {
[K		< 		if (key->type == EAPOL_KEY_TYPE_WPA) {
[K		< 			/*
[K		< 			 * Some deployed station implementations seem to send
[K		< 			 * msg 4/4 with incorrect type value in WPA2 mode.
[K		< 			 */
[K		< 			wpa_printf(MSG_DEBUG, "Workaround: Allow EAPOL-Key "
[K		< 				   "with unexpected WPA type in RSN mode");
[K		< 		} else if (key->type != EAPOL_KEY_TYPE_RSN) {
[K		< 			wpa_printf(MSG_DEBUG, "Ignore EAPOL-Key with "
[K		< 				   "unexpected type %d in RSN mode",
[K		< 				   key->type);
[K		< 			return;
[K		< 		}
[K		< 	} else {
[K		< 		if (key->type != EAPOL_KEY_TYPE_WPA) {
[K		< 			wpa_printf(MSG_DEBUG, "Ignore EAPOL-Key with "
[K		< 				   "unexpected type %d in WPA mode",
[K		< 				   key->type);
[K		< 			return;
[K		< 		}
[K		< 	}
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: Received Key Nonce", key->key_nonce,
[K		< 		    WPA_NONCE_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: Received Replay Counter",
[K		< 		    key->replay_counter, WPA_REPLAY_COUNTER_LEN);
[K		<
[K		< 	/* FIX: verify that the EAPOL-Key frame was encrypted if pairwise keys
[K		< 	 * are set */
[K		<
[K		< 	if ((key_info & (WPA_KEY_INFO_SMK_MESSAGE | WPA_KEY_INFO_REQUEST)) ==
[K		< 	    (WPA_KEY_INFO_SMK_MESSAGE | WPA_KEY_INFO_REQUEST)) {
[K		< 		if (key_info & WPA_KEY_INFO_ERROR) {
[K		< 			msg = SMK_ERROR;
[K		< 			msgtxt = "SMK Error";
[K		< 		} else {
[K		< 			msg = SMK_M1;
[K		< 			msgtxt = "SMK M1";
[K		< 		}
[K		< 	} else if (key_info & WPA_KEY_INFO_SMK_MESSAGE) {
[K		< 		msg = SMK_M3;
[K		< 		msgtxt = "SMK M3";
[K		< 	} else if (key_info & WPA_KEY_INFO_REQUEST) {
[K		< 		msg = REQUEST;
[K		< 		msgtxt = "Request";
[K		< 	} else if (!(key_info & WPA_KEY_INFO_KEY_TYPE)) {
[K		< 		msg = GROUP_2;
[K		< 		msgtxt = "2/2 Group";
[K		< 	} else if (key_data_length == 0 ||
[K		< 		   (mic_len == 0 && (key_info & WPA_KEY_INFO_ENCR_KEY_DATA) &&
[K		< 		    key_data_length == AES_BLOCK_SIZE)) {
[K		< 		msg = PAIRWISE_4;
[K		< 		msgtxt = "4/4 Pairwise";
[K		< 	} else {
[K		< 		msg = PAIRWISE_2;
[K		< 		msgtxt = "2/4 Pairwise";
[K		< 	}
[K		<
[K		< 	/* TODO: key_info type validation for PeerKey */
[K		< 	if (msg == REQUEST || msg == PAIRWISE_2 || msg == PAIRWISE_4 ||
[K		< 	    msg == GROUP_2) {
[K		< 		u16 ver = key_info & WPA_KEY_INFO_TYPE_MASK;
[K		< 		if (sm->pairwise == WPA_CIPHER_CCMP ||
[K		< 		    sm->pairwise == WPA_CIPHER_GCMP) {
[K		< 			if (wpa_use_aes_cmac(sm) &&
[K		< 			    sm->wpa_key_mgmt != WPA_KEY_MGMT_OSEN &&
[K		< 			    !wpa_key_mgmt_suite_b(sm->wpa_key_mgmt) &&
[K		< 			    !wpa_key_mgmt_fils(sm->wpa_key_mgmt) &&
[K		< 			    ver != WPA_KEY_INFO_TYPE_AES_128_CMAC) {
[K		< 				wpa_auth_logger(wpa_auth, sm->addr,
[K		< 						LOGGER_WARNING,
[K		< 						"advertised support for "
[K		< 						"AES-128-CMAC, but did not "
[K		< 						"use it");
[K		< 				return;
[K		< 			}
[K		<
[K		< 			if (!wpa_use_aes_cmac(sm) &&
[K		< 			    !wpa_key_mgmt_fils(sm->wpa_key_mgmt) &&
[K		< 			    ver != WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
[K		< 				wpa_auth_logger(wpa_auth, sm->addr,
[K		< 						LOGGER_WARNING,
[K		< 						"did not use HMAC-SHA1-AES "
[K		< 						"with CCMP/GCMP");
[K		< 				return;
[K		< 			}
[K		< 		}
[K		<
[K		< 		if ((wpa_key_mgmt_suite_b(sm->wpa_key_mgmt) ||
[K		< 		     wpa_key_mgmt_fils(sm->wpa_key_mgmt)) &&
[K		< 		    ver != WPA_KEY_INFO_TYPE_AKM_DEFINED) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_WARNING,
[K		< 					"did not use EAPOL-Key descriptor version 0 as required for AKM-defined cases");
[K		< 			return;
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_REQUEST) {
[K		< 		if (sm->req_replay_counter_used &&
[K		< 		    os_memcmp(key->replay_counter, sm->req_replay_counter,
[K		< 			      WPA_REPLAY_COUNTER_LEN) <= 0) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_WARNING,
[K		< 					"received EAPOL-Key request with "
[K		< 					"replayed counter");
[K		< 			return;
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (!(key_info & WPA_KEY_INFO_REQUEST) &&
[K		< 	    !wpa_replay_counter_valid(sm->key_replay, key->replay_counter)) {
[K		< 		int i;
[K		<
[K		< 		if (msg == PAIRWISE_2 &&
[K		< 		    wpa_replay_counter_valid(sm->prev_key_replay,
[K		< 					     key->replay_counter) &&
[K		< 		    sm->wpa_ptk_state == WPA_PTK_PTKINITNEGOTIATING &&
[K		< 		    os_memcmp(sm->SNonce, key->key_nonce, WPA_NONCE_LEN) != 0)
[K		< 		{
[K		< 			/*
[K		< 			 * Some supplicant implementations (e.g., Windows XP
[K		< 			 * WZC) update SNonce for each EAPOL-Key 2/4. This
[K		< 			 * breaks the workaround on accepting any of the
[K		< 			 * pending requests, so allow the SNonce to be updated
[K		< 			 * even if we have already sent out EAPOL-Key 3/4.
[K		< 			 */
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					 "Process SNonce update from STA "
[K		< 					 "based on retransmitted EAPOL-Key "
[K		< 					 "1/4");
[K		< 			sm->update_snonce = 1;
[K		< 			os_memcpy(sm->alt_SNonce, sm->SNonce, WPA_NONCE_LEN);
[K		< 			sm->alt_snonce_valid = TRUE;
[K		< 			os_memcpy(sm->alt_replay_counter,
[K		< 				  sm->key_replay[0].counter,
[K		< 				  WPA_REPLAY_COUNTER_LEN);
[K		< 			goto continue_processing;
[K		< 		}
[K		<
[K		< 		if (msg == PAIRWISE_4 && sm->alt_snonce_valid &&
[K		< 		    sm->wpa_ptk_state == WPA_PTK_PTKINITNEGOTIATING &&
[K		< 		    os_memcmp(key->replay_counter, sm->alt_replay_counter,
[K		< 			      WPA_REPLAY_COUNTER_LEN) == 0) {
[K		< 			/*
[K		< 			 * Supplicant may still be using the old SNonce since
[K		< 			 * there was two EAPOL-Key 2/4 messages and they had
[K		< 			 * different SNonce values.
[K		< 			 */
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					 "Try to process received EAPOL-Key 4/4 based on old Replay Counter and SNonce from an earlier EAPOL-Key 1/4");
[K		< 			goto continue_processing;
[K		< 		}
[K		<
[K		< 		if (msg == PAIRWISE_2 &&
[K		< 		    wpa_replay_counter_valid(sm->prev_key_replay,
[K		< 					     key->replay_counter) &&
[K		< 		    sm->wpa_ptk_state == WPA_PTK_PTKINITNEGOTIATING) {
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					 "ignore retransmitted EAPOL-Key %s - "
[K		< 					 "SNonce did not change", msgtxt);
[K		< 		} else {
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					 "received EAPOL-Key %s with "
[K		< 					 "unexpected replay counter", msgtxt);
[K		< 		}
[K		< 		for (i = 0; i < RSNA_MAX_EAPOL_RETRIES; i++) {
[K		< 			if (!sm->key_replay[i].valid)
[K		< 				break;
[K		< 			wpa_hexdump(MSG_DEBUG, "pending replay counter",
[K		< 				    sm->key_replay[i].counter,
[K		< 				    WPA_REPLAY_COUNTER_LEN);
[K		< 		}
[K		< 		wpa_hexdump(MSG_DEBUG, "received replay counter",
[K		< 			    key->replay_counter, WPA_REPLAY_COUNTER_LEN);
[K		< 		return;
[K		< 	}
[K		<
[K		< continue_processing:
[K		< #ifdef CONFIG_FILS
[K		< 	if (sm->wpa == WPA_VERSION_WPA2 && mic_len == 0 &&
[K		< 	    !(key_info & WPA_KEY_INFO_ENCR_KEY_DATA)) {
[K		< 		wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				 "WPA: Encr Key Data bit not set even though AEAD cipher is supposed to be used - drop frame");
[K		< 		return;
[K		< 	}
[K		< #endif /* CONFIG_FILS */
[K		<
[K		< 	switch (msg) {
[K		< 	case PAIRWISE_2:
[K		< 		if (sm->wpa_ptk_state != WPA_PTK_PTKSTART &&
[K		< 		    sm->wpa_ptk_state != WPA_PTK_PTKCALCNEGOTIATING &&
[K		< 		    (!sm->update_snonce ||
[K		< 		     sm->wpa_ptk_state != WPA_PTK_PTKINITNEGOTIATING)) {
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					 "received EAPOL-Key msg 2/4 in "
[K		< 					 "invalid state (%d) - dropped",
[K		< 					 sm->wpa_ptk_state);
[K		< 			return;
[K		< 		}
[K		< 		random_add_randomness(key->key_nonce, WPA_NONCE_LEN);
[K		< 		if (sm->group->reject_4way_hs_for_entropy) {
[K		< 			/*
[K		< 			 * The system did not have enough entropy to generate
[K		< 			 * strong random numbers. Reject the first 4-way
[K		< 			 * handshake(s) and collect some entropy based on the
[K		< 			 * information from it. Once enough entropy is
[K		< 			 * available, the next atempt will trigger GMK/Key
[K		< 			 * Counter update and the station will be allowed to
[K		< 			 * continue.
[K		< 			 */
[K		< 			wpa_printf(MSG_DEBUG, "WPA: Reject 4-way handshake to "
[K		< 				   "collect more entropy for random number "
[K		< 				   "generation");
[K		< 			random_mark_pool_ready();
[K		< 			wpa_sta_disconnect(wpa_auth, sm->addr);
[K		< 			return;
[K		< 		}
[K		< 		break;
[K		< 	case PAIRWISE_4:
[K		< 		if (sm->wpa_ptk_state != WPA_PTK_PTKINITNEGOTIATING ||
[K		< 		    !sm->PTK_valid) {
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					 "received EAPOL-Key msg 4/4 in "
[K		< 					 "invalid state (%d) - dropped",
[K		< 					 sm->wpa_ptk_state);
[K		< 			return;
[K		< 		}
[K		< 		break;
[K		< 	case GROUP_2:
[K		< 		if (sm->wpa_ptk_group_state != WPA_PTK_GROUP_REKEYNEGOTIATING
[K		< 		    || !sm->PTK_valid) {
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					 "received EAPOL-Key msg 2/2 in "
[K		< 					 "invalid state (%d) - dropped",
[K		< 					 sm->wpa_ptk_group_state);
[K		< 			return;
[K		< 		}
[K		< 		break;
[K		< #ifdef CONFIG_PEERKEY
[K		< 	case SMK_M1:
[K		< 	case SMK_M3:
[K		< 	case SMK_ERROR:
[K		< 		if (!wpa_auth->conf.peerkey) {
[K		< 			wpa_printf(MSG_DEBUG, "RSN: SMK M1/M3/Error, but "
[K		< 				   "PeerKey use disabled - ignoring message");
[K		< 			return;
[K		< 		}
[K		< 		if (!sm->PTK_valid) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"received EAPOL-Key msg SMK in "
[K		< 					"invalid state - dropped");
[K		< 			return;
[K		< 		}
[K		< 		break;
[K		< #else /* CONFIG_PEERKEY */
[K		< 	case SMK_M1:
[K		< 	case SMK_M3:
[K		< 	case SMK_ERROR:
[K		< 		return; /* STSL disabled - ignore SMK messages */
[K		< #endif /* CONFIG_PEERKEY */
[K		< 	case REQUEST:
[K		< 		break;
[K		< 	}
[K		<
[K		< 	wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 			 "received EAPOL-Key frame (%s)", msgtxt);
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_ACK) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"received invalid EAPOL-Key: Key Ack set");
[K		< 		return;
[K		< 	}
[K		<
[K		< 	if (!wpa_key_mgmt_fils(sm->wpa_key_mgmt) &&
[K		< 	    !(key_info & WPA_KEY_INFO_MIC)) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"received invalid EAPOL-Key: Key MIC not set");
[K		< 		return;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_FILS
[K		< 	if (wpa_key_mgmt_fils(sm->wpa_key_mgmt) &&
[K		< 	    (key_info & WPA_KEY_INFO_MIC)) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"received invalid EAPOL-Key: Key MIC set");
[K		< 		return;
[K		< 	}
[K		< #endif /* CONFIG_FILS */
[K		<
[K		< 	sm->MICVerified = FALSE;
[K		< 	if (sm->PTK_valid && !sm->update_snonce) {
[K		< 		if (mic_len &&
[K		< 		    wpa_verify_key_mic(sm->wpa_key_mgmt, &sm->PTK, data,
[K		< 				       data_len) &&
[K		< 		    (msg != PAIRWISE_4 || !sm->alt_snonce_valid ||
[K		< 		     wpa_try_alt_snonce(sm, data, data_len))) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"received EAPOL-Key with invalid MIC");
[K		< 			return;
[K		< 		}
[K		< #ifdef CONFIG_FILS
[K		< 		if (!mic_len &&
[K		< 		    wpa_aead_decrypt(sm, &sm->PTK, data, data_len,
[K		< 				     &key_data_length) < 0) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"received EAPOL-Key with invalid MIC");
[K		< 			return;
[K		< 		}
[K		< #endif /* CONFIG_FILS */
[K		< 		sm->MICVerified = TRUE;
[K		< 		eloop_cancel_timeout(wpa_send_eapol_timeout, wpa_auth, sm);
[K		< 		sm->pending_1_of_4_timeout = 0;
[K		< 	}
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_REQUEST) {
[K		< 		if (sm->MICVerified) {
[K		< 			sm->req_replay_counter_used = 1;
[K		< 			os_memcpy(sm->req_replay_counter, key->replay_counter,
[K		< 				  WPA_REPLAY_COUNTER_LEN);
[K		< 		} else {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"received EAPOL-Key request with "
[K		< 					"invalid MIC");
[K		< 			return;
[K		< 		}
[K		<
[K		< 		/*
[K		< 		 * TODO: should decrypt key data field if encryption was used;
[K		< 		 * even though MAC address KDE is not normally encrypted,
[K		< 		 * supplicant is allowed to encrypt it.
[K		< 		 */
[K		< 		if (msg == SMK_ERROR) {
[K		< #ifdef CONFIG_PEERKEY
[K		< 			wpa_smk_error(wpa_auth, sm, key_data, key_data_length);
[K		< #endif /* CONFIG_PEERKEY */
[K		< 			return;
[K		< 		} else if (key_info & WPA_KEY_INFO_ERROR) {
[K		< 			if (wpa_receive_error_report(
[K		< 				    wpa_auth, sm,
[K		< 				    !(key_info & WPA_KEY_INFO_KEY_TYPE)) > 0)
[K		< 				return; /* STA entry was removed */
[K		< 		} else if (key_info & WPA_KEY_INFO_KEY_TYPE) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"received EAPOL-Key Request for new "
[K		< 					"4-Way Handshake");
[K		< 			wpa_request_new_ptk(sm);
[K		< #ifdef CONFIG_PEERKEY
[K		< 		} else if (msg == SMK_M1) {
[K		< 			wpa_smk_m1(wpa_auth, sm, key, key_data,
[K		< 				   key_data_length);
[K		< #endif /* CONFIG_PEERKEY */
[K		< 		} else if (key_data_length > 0 &&
[K		< 			   wpa_parse_kde_ies(key_data, key_data_length,
[K		< 					     &kde) == 0 &&
[K		< 			   kde.mac_addr) {
[K		< 		} else {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"received EAPOL-Key Request for GTK "
[K		< 					"rekeying");
[K		< 			eloop_cancel_timeout(wpa_rekey_gtk, wpa_auth, NULL);
[K		< 			wpa_rekey_gtk(wpa_auth, NULL);
[K		< 		}
[K		< 	} else {
[K		< 		/* Do not allow the same key replay counter to be reused. */
[K		< 		wpa_replay_counter_mark_invalid(sm->key_replay,
[K		< 						key->replay_counter);
[K		<
[K		< 		if (msg == PAIRWISE_2) {
[K		< 			/*
[K		< 			 * Maintain a copy of the pending EAPOL-Key frames in
[K		< 			 * case the EAPOL-Key frame was retransmitted. This is
[K		< 			 * needed to allow EAPOL-Key msg 2/4 reply to another
[K		< 			 * pending msg 1/4 to update the SNonce to work around
[K		< 			 * unexpected supplicant behavior.
[K		< 			 */
[K		< 			os_memcpy(sm->prev_key_replay, sm->key_replay,
[K		< 				  sizeof(sm->key_replay));
[K		< 		} else {
[K		< 			os_memset(sm->prev_key_replay, 0,
[K		< 				  sizeof(sm->prev_key_replay));
[K		< 		}
[K		<
[K		< 		/*
[K		< 		 * Make sure old valid counters are not accepted anymore and
[K		< 		 * do not get copied again.
[K		< 		 */
[K		< 		wpa_replay_counter_mark_invalid(sm->key_replay, NULL);
[K		< 	}
[K		<
[K		< #ifdef CONFIG_PEERKEY
[K		< 	if (msg == SMK_M3) {
[K		< 		wpa_smk_m3(wpa_auth, sm, key, key_data, key_data_length);
[K		< 		return;
[K		< 	}
[K		< #endif /* CONFIG_PEERKEY */
[K		<
[K		< 	os_free(sm->last_rx_eapol_key);
[K		< 	sm->last_rx_eapol_key = os_malloc(data_len);
[K		< 	if (sm->last_rx_eapol_key == NULL)
[K		< 		return;
[K		< 	os_memcpy(sm->last_rx_eapol_key, data, data_len);
[K		< 	sm->last_rx_eapol_key_len = data_len;
[K		<
[K		< 	sm->rx_eapol_key_secure = !!(key_info & WPA_KEY_INFO_SECURE);
[K		< 	sm->EAPOLKeyReceived = TRUE;
[K		< 	sm->EAPOLKeyPairwise = !!(key_info & WPA_KEY_INFO_KEY_TYPE);
[K		< 	sm->EAPOLKeyRequest = !!(key_info & WPA_KEY_INFO_REQUEST);
[K		< 	os_memcpy(sm->SNonce, key->key_nonce, WPA_NONCE_LEN);
[K		< 	wpa_sm_step(sm);
[K		< }
[K		<
[K		<
[K		< static int wpa_gmk_to_gtk(const u8 *gmk, const char *label, const u8 *addr,
[K		< 			  const u8 *gnonce, u8 *gtk, size_t gtk_len)
[K		< {
[K		< 	u8 data[ETH_ALEN + WPA_NONCE_LEN + 8 + 16];
[K		< 	u8 *pos;
[K		< 	int ret = 0;
[K		<
[K		< 	/* GTK = PRF-X(GMK, "Group key expansion",
[K		< 	 *	AA || GNonce || Time || random data)
[K		< 	 * The example described in the IEEE 802.11 standard uses only AA and
[K		< 	 * GNonce as inputs here. Add some more entropy since this derivation
[K		< 	 * is done only at the Authenticator and as such, does not need to be
[K		< 	 * exactly same.
[K		< 	 */
[K		< 	os_memcpy(data, addr, ETH_ALEN);
[K		< 	os_memcpy(data + ETH_ALEN, gnonce, WPA_NONCE_LEN);
[K		< 	pos = data + ETH_ALEN + WPA_NONCE_LEN;
[K		< 	wpa_get_ntp_timestamp(pos);
[K		< 	pos += 8;
[K		< 	if (random_get_bytes(pos, 16) < 0)
[K		< 		ret = -1;
[K		<
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	sha256_prf(gmk, WPA_GMK_LEN, label, data, sizeof(data), gtk, gtk_len);
[K		< #else /* CONFIG_IEEE80211W */
[K		< 	if (sha1_prf(gmk, WPA_GMK_LEN, label, data, sizeof(data), gtk, gtk_len)
[K		< 	    < 0)
[K		< 		ret = -1;
[K		< #endif /* CONFIG_IEEE80211W */
[K		<
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< static void wpa_send_eapol_timeout(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = eloop_ctx;
[K		< 	struct wpa_state_machine *sm = timeout_ctx;
[K		<
[K		< 	sm->pending_1_of_4_timeout = 0;
[K		< 	wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG, "EAPOL-Key timeout");
[K		< 	sm->TimeoutEvt = TRUE;
[K		< 	wpa_sm_step(sm);
[K		< }
[K		<
[K		<
[K		< void __wpa_send_eapol(struct wpa_authenticator *wpa_auth,
[K		< 		      struct wpa_state_machine *sm, int key_info,
[K		< 		      const u8 *key_rsc, const u8 *nonce,
[K		< 		      const u8 *kde, size_t kde_len,
[K		< 		      int keyidx, int encr, int force_version)
[K		< {
[K		< 	struct ieee802_1x_hdr *hdr;
[K		< 	struct wpa_eapol_key *key;
[K		< 	size_t len, mic_len, keyhdrlen;
[K		< 	int alg;
[K		< 	int key_data_len, pad_len = 0;
[K		< 	u8 *buf, *pos;
[K		< 	int version, pairwise;
[K		< 	int i;
[K		< 	u8 *key_mic, *key_data;
[K		<
[K		< 	mic_len = wpa_mic_len(sm->wpa_key_mgmt);
[K		< 	keyhdrlen = sizeof(*key) + mic_len + 2;
[K		<
[K		< 	len = sizeof(struct ieee802_1x_hdr) + keyhdrlen;
[K		<
[K		< 	if (force_version)
[K		< 		version = force_version;
[K		< 	else if (sm->wpa_key_mgmt == WPA_KEY_MGMT_OSEN ||
[K		< 		 wpa_key_mgmt_suite_b(sm->wpa_key_mgmt) ||
[K		< 		 wpa_key_mgmt_fils(sm->wpa_key_mgmt))
[K		< 		version = WPA_KEY_INFO_TYPE_AKM_DEFINED;
[K		< 	else if (wpa_use_aes_cmac(sm))
[K		< 		version = WPA_KEY_INFO_TYPE_AES_128_CMAC;
[K		< 	else if (sm->pairwise != WPA_CIPHER_TKIP)
[K		< 		version = WPA_KEY_INFO_TYPE_HMAC_SHA1_AES;
[K		< 	else
[K		< 		version = WPA_KEY_INFO_TYPE_HMAC_MD5_RC4;
[K		<
[K		< 	pairwise = !!(key_info & WPA_KEY_INFO_KEY_TYPE);
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Send EAPOL(version=%d secure=%d mic=%d "
[K		< 		   "ack=%d install=%d pairwise=%d kde_len=%lu keyidx=%d "
[K		< 		   "encr=%d)",
[K		< 		   version,
[K		< 		   (key_info & WPA_KEY_INFO_SECURE) ? 1 : 0,
[K		< 		   (key_info & WPA_KEY_INFO_MIC) ? 1 : 0,
[K		< 		   (key_info & WPA_KEY_INFO_ACK) ? 1 : 0,
[K		< 		   (key_info & WPA_KEY_INFO_INSTALL) ? 1 : 0,
[K		< 		   pairwise, (unsigned long) kde_len, keyidx, encr);
[K		<
[K		< 	key_data_len = kde_len;
[K		<
[K		< 	if ((version == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES ||
[K		< 	     sm->wpa_key_mgmt == WPA_KEY_MGMT_OSEN ||
[K		< 	     wpa_key_mgmt_suite_b(sm->wpa_key_mgmt) ||
[K		< 	     version == WPA_KEY_INFO_TYPE_AES_128_CMAC) && encr) {
[K		< 		pad_len = key_data_len % 8;
[K		< 		if (pad_len)
[K		< 			pad_len = 8 - pad_len;
[K		< 		key_data_len += pad_len + 8;
[K		< 	}
[K		<
[K		< 	len += key_data_len;
[K		< 	if (!mic_len && encr)
[K		< 		len += AES_BLOCK_SIZE;
[K		<
[K		< 	hdr = os_zalloc(len);
[K		< 	if (hdr == NULL)
[K		< 		return;
[K		< 	hdr->version = wpa_auth->conf.eapol_version;
[K		< 	hdr->type = IEEE802_1X_TYPE_EAPOL_KEY;
[K		< 	hdr->length = host_to_be16(len  - sizeof(*hdr));
[K		< 	key = (struct wpa_eapol_key *) (hdr + 1);
[K		< 	key_mic = (u8 *) (key + 1);
[K		< 	key_data = ((u8 *) (hdr + 1)) + keyhdrlen;
[K		<
[K		< 	key->type = sm->wpa == WPA_VERSION_WPA2 ?
[K		< 		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
[K		< 	key_info |= version;
[K		< 	if (encr && sm->wpa == WPA_VERSION_WPA2)
[K		< 		key_info |= WPA_KEY_INFO_ENCR_KEY_DATA;
[K		< 	if (sm->wpa != WPA_VERSION_WPA2)
[K		< 		key_info |= keyidx << WPA_KEY_INFO_KEY_INDEX_SHIFT;
[K		< 	WPA_PUT_BE16(key->key_info, key_info);
[K		<
[K		< 	alg = pairwise ? sm->pairwise : wpa_auth->conf.wpa_group;
[K		< 	if ((key_info & WPA_KEY_INFO_SMK_MESSAGE) ||
[K		< 	    (sm->wpa == WPA_VERSION_WPA2 && !pairwise))
[K		< 		WPA_PUT_BE16(key->key_length, 0);
[K		< 	else
[K		< 		WPA_PUT_BE16(key->key_length, wpa_cipher_key_len(alg));
[K		<
[K		< 	/* FIX: STSL: what to use as key_replay_counter? */
[K		< 	for (i = RSNA_MAX_EAPOL_RETRIES - 1; i > 0; i--) {
[K		< 		sm->key_replay[i].valid = sm->key_replay[i - 1].valid;
[K		< 		os_memcpy(sm->key_replay[i].counter,
[K		< 			  sm->key_replay[i - 1].counter,
[K		< 			  WPA_REPLAY_COUNTER_LEN);
[K		< 	}
[K		< 	inc_byte_array(sm->key_replay[0].counter, WPA_REPLAY_COUNTER_LEN);
[K		< 	os_memcpy(key->replay_counter, sm->key_replay[0].counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: Replay Counter",
[K		< 		    key->replay_counter, WPA_REPLAY_COUNTER_LEN);
[K		< 	sm->key_replay[0].valid = TRUE;
[K		<
[K		< 	if (nonce)
[K		< 		os_memcpy(key->key_nonce, nonce, WPA_NONCE_LEN);
[K		<
[K		< 	if (key_rsc)
[K		< 		os_memcpy(key->key_rsc, key_rsc, WPA_KEY_RSC_LEN);
[K		<
[K		< 	if (kde && !encr) {
[K		< 		os_memcpy(key_data, kde, kde_len);
[K		< 		WPA_PUT_BE16(key_mic + mic_len, kde_len);
[K		< #ifdef CONFIG_FILS
[K		< 	} else if (!mic_len) {
[K		< 		const u8 *aad[1];
[K		< 		size_t aad_len[1];
[K		<
[K		< 		WPA_PUT_BE16(key_mic, AES_BLOCK_SIZE + kde_len);
[K		< 		wpa_hexdump_key(MSG_DEBUG, "Plaintext EAPOL-Key Key Data",
[K		< 				kde, kde_len);
[K		<
[K		< 		wpa_hexdump_key(MSG_DEBUG, "WPA: KEK",
[K		< 				sm->PTK.kek, sm->PTK.kek_len);
[K		< 		/* AES-SIV AAD from EAPOL protocol version field (inclusive) to
[K		< 		 * to Key Data (exclusive). */
[K		< 		aad[0] = (u8 *) hdr;
[K		< 		aad_len[0] = key_mic + 2 - (u8 *) hdr;
[K		< 		if (aes_siv_encrypt(sm->PTK.kek, sm->PTK.kek_len, kde, kde_len,
[K		< 				    1, aad, aad_len, key_mic + 2) < 0) {
[K		< 			wpa_printf(MSG_DEBUG, "WPA: AES-SIV encryption failed");
[K		< 			return;
[K		< 		}
[K		<
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: Encrypted Key Data from SIV",
[K		< 			    key_mic + 2, AES_BLOCK_SIZE + kde_len);
[K		< #endif /* CONFIG_FILS */
[K		< 	} else if (encr && kde) {
[K		< 		buf = os_zalloc(key_data_len);
[K		< 		if (buf == NULL) {
[K		< 			os_free(hdr);
[K		< 			return;
[K		< 		}
[K		< 		pos = buf;
[K		< 		os_memcpy(pos, kde, kde_len);
[K		< 		pos += kde_len;
[K		<
[K		< 		if (pad_len)
[K		< 			*pos++ = 0xdd;
[K		<
[K		< 		wpa_hexdump_key(MSG_DEBUG, "Plaintext EAPOL-Key Key Data",
[K		< 				buf, key_data_len);
[K		< 		if (version == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES ||
[K		< 		    sm->wpa_key_mgmt == WPA_KEY_MGMT_OSEN ||
[K		< 		    wpa_key_mgmt_suite_b(sm->wpa_key_mgmt) ||
[K		< 		    version == WPA_KEY_INFO_TYPE_AES_128_CMAC) {
[K		< 			if (aes_wrap(sm->PTK.kek, sm->PTK.kek_len,
[K		< 				     (key_data_len - 8) / 8, buf, key_data)) {
[K		< 				os_free(hdr);
[K		< 				os_free(buf);
[K		< 				return;
[K		< 			}
[K		< 			WPA_PUT_BE16(key_mic + mic_len, key_data_len);
[K		< #ifndef CONFIG_NO_RC4
[K		< 		} else if (sm->PTK.kek_len == 16) {
[K		< 			u8 ek[32];
[K		< 			os_memcpy(key->key_iv,
[K		< 				  sm->group->Counter + WPA_NONCE_LEN - 16, 16);
[K		< 			inc_byte_array(sm->group->Counter, WPA_NONCE_LEN);
[K		< 			os_memcpy(ek, key->key_iv, 16);
[K		< 			os_memcpy(ek + 16, sm->PTK.kek, sm->PTK.kek_len);
[K		< 			os_memcpy(key_data, buf, key_data_len);
[K		< 			rc4_skip(ek, 32, 256, key_data, key_data_len);
[K		< 			WPA_PUT_BE16(key_mic + mic_len, key_data_len);
[K		< #endif /* CONFIG_NO_RC4 */
[K		< 		} else {
[K		< 			os_free(hdr);
[K		< 			os_free(buf);
[K		< 			return;
[K		< 		}
[K		< 		os_free(buf);
[K		< 	}
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_MIC) {
[K		< 		if (!sm->PTK_valid || !mic_len) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					"PTK not valid when sending EAPOL-Key "
[K		< 					"frame");
[K		< 			os_free(hdr);
[K		< 			return;
[K		< 		}
[K		<
[K		< 		wpa_eapol_key_mic(sm->PTK.kck, sm->PTK.kck_len,
[K		< 				  sm->wpa_key_mgmt, version,
[K		< 				  (u8 *) hdr, len, key_mic);
[K		< #ifdef CONFIG_TESTING_OPTIONS
[K		< 		if (!pairwise &&
[K		< 		    wpa_auth->conf.corrupt_gtk_rekey_mic_probability > 0.0 &&
[K		< 		    drand48() <
[K		< 		    wpa_auth->conf.corrupt_gtk_rekey_mic_probability) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"Corrupting group EAPOL-Key Key MIC");
[K		< 			key_mic[0]++;
[K		< 		}
[K		< #endif /* CONFIG_TESTING_OPTIONS */
[K		< 	}
[K		<
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_inc_EapolFramesTx,
[K		< 			   1);
[K		< 	wpa_auth_send_eapol(wpa_auth, sm->addr, (u8 *) hdr, len,
[K		< 			    sm->pairwise_set);
[K		< 	os_free(hdr);
[K		< }
[K		<
[K		<
[K		< static void wpa_send_eapol(struct wpa_authenticator *wpa_auth,
[K		< 			   struct wpa_state_machine *sm, int key_info,
[K		< 			   const u8 *key_rsc, const u8 *nonce,
[K		< 			   const u8 *kde, size_t kde_len,
[K		< 			   int keyidx, int encr)
[K		< {
[K		< 	int timeout_ms;
[K		< 	int pairwise = key_info & WPA_KEY_INFO_KEY_TYPE;
[K		< 	u32 ctr;
[K		<
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	__wpa_send_eapol(wpa_auth, sm, key_info, key_rsc, nonce, kde, kde_len,
[K		< 			 keyidx, encr, 0);
[K		<
[K		< 	ctr = pairwise ? sm->TimeoutCtr : sm->GTimeoutCtr;
[K		< 	if (ctr == 1 && wpa_auth->conf.tx_status)
[K		< 		timeout_ms = pairwise ? eapol_key_timeout_first :
[K		< 			eapol_key_timeout_first_group;
[K		< 	else
[K		< 		timeout_ms = eapol_key_timeout_subseq;
[K		< 	if (pairwise && ctr == 1 && !(key_info & WPA_KEY_INFO_MIC))
[K		< 		sm->pending_1_of_4_timeout = 1;
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Use EAPOL-Key timeout of %u ms (retry "
[K		< 		   "counter %u)", timeout_ms, ctr);
[K		< 	eloop_register_timeout(timeout_ms / 1000, (timeout_ms % 1000) * 1000,
[K		< 			       wpa_send_eapol_timeout, wpa_auth, sm);
[K		< }
[K		<
[K		<
[K		< static int wpa_verify_key_mic(int akmp, struct wpa_ptk *PTK, u8 *data,
[K		< 			      size_t data_len)
[K		< {
[K		< 	struct ieee802_1x_hdr *hdr;
[K		< 	struct wpa_eapol_key *key;
[K		< 	u16 key_info;
[K		< 	int ret = 0;
[K		< 	u8 mic[WPA_EAPOL_KEY_MIC_MAX_LEN], *mic_pos;
[K		< 	size_t mic_len = wpa_mic_len(akmp);
[K		<
[K		< 	if (data_len < sizeof(*hdr) + sizeof(*key))
[K		< 		return -1;
[K		<
[K		< 	hdr = (struct ieee802_1x_hdr *) data;
[K		< 	key = (struct wpa_eapol_key *) (hdr + 1);
[K		< 	mic_pos = (u8 *) (key + 1);
[K		< 	key_info = WPA_GET_BE16(key->key_info);
[K		< 	os_memcpy(mic, mic_pos, mic_len);
[K		< 	os_memset(mic_pos, 0, mic_len);
[K		< 	if (wpa_eapol_key_mic(PTK->kck, PTK->kck_len, akmp,
[K		< 			      key_info & WPA_KEY_INFO_TYPE_MASK,
[K		< 			      data, data_len, mic_pos) ||
[K		< 	    os_memcmp_const(mic, mic_pos, mic_len) != 0)
[K		< 		ret = -1;
[K		< 	os_memcpy(mic_pos, mic, mic_len);
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< void wpa_remove_ptk(struct wpa_state_machine *sm)
[K		< {
[K		< 	sm->PTK_valid = FALSE;
[K		< 	os_memset(&sm->PTK, 0, sizeof(sm->PTK));
[K		< 	if (wpa_auth_set_key(sm->wpa_auth, 0, WPA_ALG_NONE, sm->addr, 0, NULL,
[K		< 			     0))
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "RSN: PTK removal from the driver failed");
[K		< 	sm->pairwise_set = FALSE;
[K		< 	eloop_cancel_timeout(wpa_rekey_ptk, sm->wpa_auth, sm);
[K		< }
[K		<
[K		<
[K		< int wpa_auth_sm_event(struct wpa_state_machine *sm, enum wpa_event event)
[K		< {
[K		< 	int remove_ptk = 1;
[K		<
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< 	wpa_auth_vlogger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 			 "event %d notification", event);
[K		<
[K		< 	switch (event) {
[K		< 	case WPA_AUTH:
[K		< #ifdef CONFIG_MESH
[K		< 		/* PTKs are derived through AMPE */
[K		< 		if (wpa_auth_start_ampe(sm->wpa_auth, sm->addr)) {
[K		< 			/* not mesh */
[K		< 			break;
[K		< 		}
[K		< 		return 0;
[K		< #endif /* CONFIG_MESH */
[K		< 	case WPA_ASSOC:
[K		< 		break;
[K		< 	case WPA_DEAUTH:
[K		< 	case WPA_DISASSOC:
[K		< 		sm->DeauthenticationRequest = TRUE;
[K		< 		break;
[K		< 	case WPA_REAUTH:
[K		< 	case WPA_REAUTH_EAPOL:
[K		< 		if (!sm->started) {
[K		< 			/*
[K		< 			 * When using WPS, we may end up here if the STA
[K		< 			 * manages to re-associate without the previous STA
[K		< 			 * entry getting removed. Consequently, we need to make
[K		< 			 * sure that the WPA state machines gets initialized
[K		< 			 * properly at this point.
[K		< 			 */
[K		< 			wpa_printf(MSG_DEBUG, "WPA state machine had not been "
[K		< 				   "started - initialize now");
[K		< 			sm->started = 1;
[K		< 			sm->Init = TRUE;
[K		< 			if (wpa_sm_step(sm) == 1)
[K		< 				return 1; /* should not really happen */
[K		< 			sm->Init = FALSE;
[K		< 			sm->AuthenticationRequest = TRUE;
[K		< 			break;
[K		< 		}
[K		< 		if (sm->GUpdateStationKeys) {
[K		< 			/*
[K		< 			 * Reauthentication cancels the pending group key
[K		< 			 * update for this STA.
[K		< 			 */
[K		< 			sm->group->GKeyDoneStations--;
[K		< 			sm->GUpdateStationKeys = FALSE;
[K		< 			sm->PtkGroupInit = TRUE;
[K		< 		}
[K		< 		sm->ReAuthenticationRequest = TRUE;
[K		< 		break;
[K		< 	case WPA_ASSOC_FT:
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 		wpa_printf(MSG_DEBUG, "FT: Retry PTK configuration "
[K		< 			   "after association");
[K		< 		wpa_ft_install_ptk(sm);
[K		<
[K		< 		/* Using FT protocol, not WPA auth state machine */
[K		< 		sm->ft_completed = 1;
[K		< 		return 0;
[K		< #else /* CONFIG_IEEE80211R_AP */
[K		< 		break;
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< 	}
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	sm->ft_completed = 0;
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (sm->mgmt_frame_prot && event == WPA_AUTH)
[K		< 		remove_ptk = 0;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< #ifdef CONFIG_FILS
[K		< 	if (wpa_key_mgmt_fils(sm->wpa_key_mgmt) &&
[K		< 	    (event == WPA_AUTH || event == WPA_ASSOC))
[K		< 		remove_ptk = 0;
[K		< #endif /* CONFIG_FILS */
[K		<
[K		< 	if (remove_ptk) {
[K		< 		sm->PTK_valid = FALSE;
[K		< 		os_memset(&sm->PTK, 0, sizeof(sm->PTK));
[K		<
[K		< 		if (event != WPA_REAUTH_EAPOL)
[K		< 			wpa_remove_ptk(sm);
[K		< 	}
[K		<
[K		< 	if (sm->in_step_loop) {
[K		< 		/*
[K		< 		 * wpa_sm_step() is already running - avoid recursive call to
[K		< 		 * it by making the existing loop process the new update.
[K		< 		 */
[K		< 		sm->changed = TRUE;
[K		< 		return 0;
[K		< 	}
[K		< 	return wpa_sm_step(sm);
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, INITIALIZE)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, INITIALIZE, wpa_ptk);
[K		< 	if (sm->Init) {
[K		< 		/* Init flag is not cleared here, so avoid busy
[K		< 		 * loop by claiming nothing changed. */
[K		< 		sm->changed = FALSE;
[K		< 	}
[K		<
[K		< 	sm->keycount = 0;
[K		< 	if (sm->GUpdateStationKeys)
[K		< 		sm->group->GKeyDoneStations--;
[K		< 	sm->GUpdateStationKeys = FALSE;
[K		< 	if (sm->wpa == WPA_VERSION_WPA)
[K		< 		sm->PInitAKeys = FALSE;
[K		< 	if (1 /* Unicast cipher supported AND (ESS OR ((IBSS or WDS) and
[K		< 	       * Local AA > Remote AA)) */) {
[K		< 		sm->Pair = TRUE;
[K		< 	}
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_portEnabled, 0);
[K		< 	wpa_remove_ptk(sm);
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_portValid, 0);
[K		< 	sm->TimeoutCtr = 0;
[K		< 	if (wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt)) {
[K		< 		wpa_auth_set_eapol(sm->wpa_auth, sm->addr,
[K		< 				   WPA_EAPOL_authorized, 0);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, DISCONNECT)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, DISCONNECT, wpa_ptk);
[K		< 	sm->Disconnect = FALSE;
[K		< 	wpa_sta_disconnect(sm->wpa_auth, sm->addr);
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, DISCONNECTED)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, DISCONNECTED, wpa_ptk);
[K		< 	sm->DeauthenticationRequest = FALSE;
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, AUTHENTICATION)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, AUTHENTICATION, wpa_ptk);
[K		< 	os_memset(&sm->PTK, 0, sizeof(sm->PTK));
[K		< 	sm->PTK_valid = FALSE;
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_portControl_Auto,
[K		< 			   1);
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_portEnabled, 1);
[K		< 	sm->AuthenticationRequest = FALSE;
[K		< }
[K		<
[K		<
[K		< static void wpa_group_ensure_init(struct wpa_authenticator *wpa_auth,
[K		< 				  struct wpa_group *group)
[K		< {
[K		< 	if (group->first_sta_seen)
[K		< 		return;
[K		< 	/*
[K		< 	 * System has run bit further than at the time hostapd was started
[K		< 	 * potentially very early during boot up. This provides better chances
[K		< 	 * of collecting more randomness on embedded systems. Re-initialize the
[K		< 	 * GMK and Counter here to improve their strength if there was not
[K		< 	 * enough entropy available immediately after system startup.
[K		< 	 */
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Re-initialize GMK/Counter on first "
[K		< 		   "station");
[K		< 	if (random_pool_ready() != 1) {
[K		< 		wpa_printf(MSG_INFO, "WPA: Not enough entropy in random pool "
[K		< 			   "to proceed - reject first 4-way handshake");
[K		< 		group->reject_4way_hs_for_entropy = TRUE;
[K		< 	} else {
[K		< 		group->first_sta_seen = TRUE;
[K		< 		group->reject_4way_hs_for_entropy = FALSE;
[K		< 	}
[K		<
[K		< 	if (wpa_group_init_gmk_and_counter(wpa_auth, group) < 0 ||
[K		< 	    wpa_gtk_update(wpa_auth, group) < 0 ||
[K		< 	    wpa_group_config_group_keys(wpa_auth, group) < 0) {
[K		< 		wpa_printf(MSG_INFO, "WPA: GMK/GTK setup failed");
[K		< 		group->first_sta_seen = FALSE;
[K		< 		group->reject_4way_hs_for_entropy = TRUE;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, AUTHENTICATION2)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, AUTHENTICATION2, wpa_ptk);
[K		<
[K		< 	wpa_group_ensure_init(sm->wpa_auth, sm->group);
[K		< 	sm->ReAuthenticationRequest = FALSE;
[K		<
[K		< 	/*
[K		< 	 * Definition of ANonce selection in IEEE Std 802.11i-2004 is somewhat
[K		< 	 * ambiguous. The Authenticator state machine uses a counter that is
[K		< 	 * incremented by one for each 4-way handshake. However, the security
[K		< 	 * analysis of 4-way handshake points out that unpredictable nonces
[K		< 	 * help in preventing precomputation attacks. Instead of the state
[K		< 	 * machine definition, use an unpredictable nonce value here to provide
[K		< 	 * stronger protection against potential precomputation attacks.
[K		< 	 */
[K		< 	if (random_get_bytes(sm->ANonce, WPA_NONCE_LEN)) {
[K		< 		wpa_printf(MSG_ERROR, "WPA: Failed to get random data for "
[K		< 			   "ANonce.");
[K		< 		sm->Disconnect = TRUE;
[K		< 		return;
[K		< 	}
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: Assign ANonce", sm->ANonce,
[K		< 		    WPA_NONCE_LEN);
[K		< 	/* IEEE 802.11i does not clear TimeoutCtr here, but this is more
[K		< 	 * logical place than INITIALIZE since AUTHENTICATION2 can be
[K		< 	 * re-entered on ReAuthenticationRequest without going through
[K		< 	 * INITIALIZE. */
[K		< 	sm->TimeoutCtr = 0;
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, INITPMK)
[K		< {
[K		< 	u8 msk[2 * PMK_LEN];
[K		< 	size_t len = 2 * PMK_LEN;
[K		<
[K		< 	SM_ENTRY_MA(WPA_PTK, INITPMK, wpa_ptk);
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	sm->xxkey_len = 0;
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< 	if (sm->pmksa) {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: PMK from PMKSA cache");
[K		< 		os_memcpy(sm->PMK, sm->pmksa->pmk, sm->pmksa->pmk_len);
[K		< 		sm->pmk_len = sm->pmksa->pmk_len;
[K		< 	} else if (wpa_auth_get_msk(sm->wpa_auth, sm->addr, msk, &len) == 0) {
[K		< 		unsigned int pmk_len;
[K		<
[K		< 		if (wpa_key_mgmt_sha384(sm->wpa_key_mgmt))
[K		< 			pmk_len = PMK_LEN_SUITE_B_192;
[K		< 		else
[K		< 			pmk_len = PMK_LEN;
[K		< 		wpa_printf(MSG_DEBUG, "WPA: PMK from EAPOL state machine "
[K		< 			   "(MSK len=%lu PMK len=%u)", (unsigned long) len,
[K		< 			   pmk_len);
[K		< 		if (len < pmk_len) {
[K		< 			wpa_printf(MSG_DEBUG,
[K		< 				   "WPA: MSK not long enough (%u) to create PMK (%u)",
[K		< 				   (unsigned int) len, (unsigned int) pmk_len);
[K		< 			sm->Disconnect = TRUE;
[K		< 			return;
[K		< 		}
[K		< 		os_memcpy(sm->PMK, msk, pmk_len);
[K		< 		sm->pmk_len = pmk_len;
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 		if (len >= 2 * PMK_LEN) {
[K		< 			os_memcpy(sm->xxkey, msk + PMK_LEN, PMK_LEN);
[K		< 			sm->xxkey_len = PMK_LEN;
[K		< 		}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< 	} else {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Could not get PMK, get_msk: %p",
[K		< 			   sm->wpa_auth->cb->get_msk);
[K		< 		sm->Disconnect = TRUE;
[K		< 		return;
[K		< 	}
[K		< 	os_memset(msk, 0, sizeof(msk));
[K		<
[K		< 	sm->req_replay_counter_used = 0;
[K		< 	/* IEEE 802.11i does not set keyRun to FALSE, but not doing this
[K		< 	 * will break reauthentication since EAPOL state machines may not be
[K		< 	 * get into AUTHENTICATING state that clears keyRun before WPA state
[K		< 	 * machine enters AUTHENTICATION2 state and goes immediately to INITPMK
[K		< 	 * state and takes PMK from the previously used AAA Key. This will
[K		< 	 * eventually fail in 4-Way Handshake because Supplicant uses PMK
[K		< 	 * derived from the new AAA Key. Setting keyRun = FALSE here seems to
[K		< 	 * be good workaround for this issue. */
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_keyRun, 0);
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, INITPSK)
[K		< {
[K		< 	const u8 *psk;
[K		< 	SM_ENTRY_MA(WPA_PTK, INITPSK, wpa_ptk);
[K		< 	psk = wpa_auth_get_psk(sm->wpa_auth, sm->addr, sm->p2p_dev_addr, NULL);
[K		< 	if (psk) {
[K		< 		os_memcpy(sm->PMK, psk, PMK_LEN);
[K		< 		sm->pmk_len = PMK_LEN;
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 		os_memcpy(sm->xxkey, psk, PMK_LEN);
[K		< 		sm->xxkey_len = PMK_LEN;
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< 	}
[K		< 	sm->req_replay_counter_used = 0;
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, PTKSTART)
[K		< {
[K		< 	u8 buf[2 + RSN_SELECTOR_LEN + PMKID_LEN], *pmkid = NULL;
[K		< 	size_t pmkid_len = 0;
[K		<
[K		< 	SM_ENTRY_MA(WPA_PTK, PTKSTART, wpa_ptk);
[K		< 	sm->PTKRequest = FALSE;
[K		< 	sm->TimeoutEvt = FALSE;
[K		< 	sm->alt_snonce_valid = FALSE;
[K		<
[K		< 	sm->TimeoutCtr++;
[K		< 	if (sm->TimeoutCtr > sm->wpa_auth->conf.wpa_pairwise_update_count) {
[K		< 		/* No point in sending the EAPOL-Key - we will disconnect
[K		< 		 * immediately following this. */
[K		< 		return;
[K		< 	}
[K		<
[K		< 	wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 			"sending 1/4 msg of 4-Way Handshake");
[K		< 	/*
[K		< 	 * TODO: Could add PMKID even with WPA2-PSK, but only if there is only
[K		< 	 * one possible PSK for this STA.
[K		< 	 */
[K		< 	if (sm->wpa == WPA_VERSION_WPA2 &&
[K		< 	    wpa_key_mgmt_wpa_ieee8021x(sm->wpa_key_mgmt) &&
[K		< 	    sm->wpa_key_mgmt != WPA_KEY_MGMT_OSEN) {
[K		< 		pmkid = buf;
[K		< 		pmkid_len = 2 + RSN_SELECTOR_LEN + PMKID_LEN;
[K		< 		pmkid[0] = WLAN_EID_VENDOR_SPECIFIC;
[K		< 		pmkid[1] = RSN_SELECTOR_LEN + PMKID_LEN;
[K		< 		RSN_SELECTOR_PUT(&pmkid[2], RSN_KEY_DATA_PMKID);
[K		< 		if (sm->pmksa) {
[K		< 			os_memcpy(&pmkid[2 + RSN_SELECTOR_LEN],
[K		< 				  sm->pmksa->pmkid, PMKID_LEN);
[K		< 		} else if (wpa_key_mgmt_suite_b(sm->wpa_key_mgmt)) {
[K		< 			/* No KCK available to derive PMKID */
[K		< 			pmkid = NULL;
[K		< 		} else {
[K		< 			/*
[K		< 			 * Calculate PMKID since no PMKSA cache entry was
[K		< 			 * available with pre-calculated PMKID.
[K		< 			 */
[K		< 			rsn_pmkid(sm->PMK, sm->pmk_len, sm->wpa_auth->addr,
[K		< 				  sm->addr, &pmkid[2 + RSN_SELECTOR_LEN],
[K		< 				  wpa_key_mgmt_sha256(sm->wpa_key_mgmt));
[K		< 		}
[K		< 	}
[K		< 	wpa_send_eapol(sm->wpa_auth, sm,
[K		< 		       WPA_KEY_INFO_ACK | WPA_KEY_INFO_KEY_TYPE, NULL,
[K		< 		       sm->ANonce, pmkid, pmkid_len, 0, 0);
[K		< }
[K		<
[K		<
[K		< static int wpa_derive_ptk(struct wpa_state_machine *sm, const u8 *snonce,
[K		< 			  const u8 *pmk, unsigned int pmk_len,
[K		< 			  struct wpa_ptk *ptk)
[K		< {
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt))
[K		< 		return wpa_auth_derive_ptk_ft(sm, pmk, ptk);
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		< 	return wpa_pmk_to_ptk(pmk, pmk_len, "Pairwise key expansion",
[K		< 			      sm->wpa_auth->addr, sm->addr, sm->ANonce, snonce,
[K		< 			      ptk, sm->wpa_key_mgmt, sm->pairwise);
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_FILS
[K		<
[K		< int fils_auth_pmk_to_ptk(struct wpa_state_machine *sm, const u8 *pmk,
[K		< 			 size_t pmk_len, const u8 *snonce, const u8 *anonce)
[K		< {
[K		< 	u8 ick[FILS_ICK_MAX_LEN];
[K		< 	size_t ick_len;
[K		< 	int res;
[K		<
[K		< 	res = fils_pmk_to_ptk(pmk, pmk_len, sm->addr, sm->wpa_auth->addr,
[K		< 			      snonce, anonce, &sm->PTK, ick, &ick_len,
[K		< 			      sm->wpa_key_mgmt, sm->pairwise);
[K		< 	if (res < 0)
[K		< 		return res;
[K		< 	sm->PTK_valid = TRUE;
[K		<
[K		< 	res = fils_key_auth_sk(ick, ick_len, snonce, anonce,
[K		< 			       sm->addr, sm->wpa_auth->addr,
[K		< 			       NULL, 0, NULL, 0, /* TODO: SK+PFS */
[K		< 			       sm->wpa_key_mgmt, sm->fils_key_auth_sta,
[K		< 			       sm->fils_key_auth_ap,
[K		< 			       &sm->fils_key_auth_len);
[K		< 	os_memset(ick, 0, sizeof(ick));
[K		<
[K		< 	/* Store nonces for (Re)Association Request/Response frame processing */
[K		< 	os_memcpy(sm->SNonce, snonce, FILS_NONCE_LEN);
[K		< 	os_memcpy(sm->ANonce, anonce, FILS_NONCE_LEN);
[K		<
[K		< 	return res;
[K		< }
[K		<
[K		<
[K		< static int wpa_aead_decrypt(struct wpa_state_machine *sm, struct wpa_ptk *ptk,
[K		< 			    u8 *buf, size_t buf_len, u16 *_key_data_len)
[K		< {
[K		< 	struct ieee802_1x_hdr *hdr;
[K		< 	struct wpa_eapol_key *key;
[K		< 	u8 *pos;
[K		< 	u16 key_data_len;
[K		< 	u8 *tmp;
[K		< 	const u8 *aad[1];
[K		< 	size_t aad_len[1];
[K		<
[K		< 	hdr = (struct ieee802_1x_hdr *) buf;
[K		< 	key = (struct wpa_eapol_key *) (hdr + 1);
[K		< 	pos = (u8 *) (key + 1);
[K		< 	key_data_len = WPA_GET_BE16(pos);
[K		< 	if (key_data_len < AES_BLOCK_SIZE ||
[K		< 	    key_data_len > buf_len - sizeof(*hdr) - sizeof(*key) - 2) {
[K		< 		wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"No room for AES-SIV data in the frame");
[K		< 		return -1;
[K		< 	}
[K		< 	pos += 2; /* Pointing at the Encrypted Key Data field */
[K		<
[K		< 	tmp = os_malloc(key_data_len);
[K		< 	if (!tmp)
[K		< 		return -1;
[K		<
[K		< 	/* AES-SIV AAD from EAPOL protocol version field (inclusive) to
[K		< 	 * to Key Data (exclusive). */
[K		< 	aad[0] = buf;
[K		< 	aad_len[0] = pos - buf;
[K		< 	if (aes_siv_decrypt(ptk->kek, ptk->kek_len, pos, key_data_len,
[K		< 			    1, aad, aad_len, tmp) < 0) {
[K		< 		wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"Invalid AES-SIV data in the frame");
[K		< 		bin_clear_free(tmp, key_data_len);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	/* AEAD decryption and validation completed successfully */
[K		< 	key_data_len -= AES_BLOCK_SIZE;
[K		< 	wpa_hexdump_key(MSG_DEBUG, "WPA: Decrypted Key Data",
[K		< 			tmp, key_data_len);
[K		<
[K		< 	/* Replace Key Data field with the decrypted version */
[K		< 	os_memcpy(pos, tmp, key_data_len);
[K		< 	pos -= 2; /* Key Data Length field */
[K		< 	WPA_PUT_BE16(pos, key_data_len);
[K		< 	bin_clear_free(tmp, key_data_len);
[K		< 	if (_key_data_len)
[K		< 		*_key_data_len = key_data_len;
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< int fils_decrypt_assoc(struct wpa_state_machine *sm, const u8 *fils_session,
[K		< 		       const struct ieee80211_mgmt *mgmt, size_t frame_len,
[K		< 		       u8 *pos, size_t left)
[K		< {
[K		< 	u16 fc, stype;
[K		< 	const u8 *end, *ie_start, *ie, *session, *crypt;
[K		< 	struct ieee802_11_elems elems;
[K		< 	const u8 *aad[5];
[K		< 	size_t aad_len[5];
[K		<
[K		< 	if (!sm || !sm->PTK_valid) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: No KEK to decrypt Assocication Request frame");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (!wpa_key_mgmt_fils(sm->wpa_key_mgmt)) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Not a FILS AKM - reject association");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	end = ((const u8 *) mgmt) + frame_len;
[K		< 	fc = le_to_host16(mgmt->frame_control);
[K		< 	stype = WLAN_FC_GET_STYPE(fc);
[K		< 	if (stype == WLAN_FC_STYPE_REASSOC_REQ)
[K		< 		ie_start = mgmt->u.reassoc_req.variable;
[K		< 	else
[K		< 		ie_start = mgmt->u.assoc_req.variable;
[K		< 	ie = ie_start;
[K		<
[K		< 	/*
[K		< 	 * Find FILS Session element which is the last unencrypted element in
[K		< 	 * the frame.
[K		< 	 */
[K		< 	session = NULL;
[K		< 	while (ie + 1 < end) {
[K		< 		if (ie + 2 + ie[1] > end)
[K		< 			break;
[K		< 		if (ie[0] == WLAN_EID_EXTENSION &&
[K		< 		    ie[1] >= 1 + FILS_SESSION_LEN &&
[K		< 		    ie[2] == WLAN_EID_EXT_FILS_SESSION) {
[K		< 			session = ie;
[K		< 			break;
[K		< 		}
[K		< 		ie += 2 + ie[1];
[K		< 	}
[K		<
[K		< 	if (!session) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Could not find FILS Session element in Association Request frame - reject");
[K		< 		return -1;
[K		< 	}
[K		< 	if (os_memcmp(fils_session, session + 3, FILS_SESSION_LEN) != 0) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Session mismatch");
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Expected FILS Session",
[K		< 			    fils_session, FILS_SESSION_LEN);
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Received FILS Session",
[K		< 			    session + 3, FILS_SESSION_LEN);
[K		< 		return -1;
[K		< 	}
[K		< 	crypt = session + 2 + session[1];
[K		<
[K		< 	if (end - crypt < AES_BLOCK_SIZE) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Too short frame to include AES-SIV data");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	/* AES-SIV AAD vectors */
[K		<
[K		< 	/* The STA's MAC address */
[K		< 	aad[0] = mgmt->sa;
[K		< 	aad_len[0] = ETH_ALEN;
[K		< 	/* The AP's BSSID */
[K		< 	aad[1] = mgmt->da;
[K		< 	aad_len[1] = ETH_ALEN;
[K		< 	/* The STA's nonce */
[K		< 	aad[2] = sm->SNonce;
[K		< 	aad_len[2] = FILS_NONCE_LEN;
[K		< 	/* The AP's nonce */
[K		< 	aad[3] = sm->ANonce;
[K		< 	aad_len[3] = FILS_NONCE_LEN;
[K		< 	/*
[K		< 	 * The (Re)Association Request frame from the Capability Information
[K		< 	 * field to the FILS Session element (both inclusive).
[K		< 	 */
[K		< 	aad[4] = (const u8 *) &mgmt->u.assoc_req.capab_info;
[K		< 	aad_len[4] = crypt - aad[4];
[K		<
[K		< 	if (aes_siv_decrypt(sm->PTK.kek, sm->PTK.kek_len, crypt, end - crypt,
[K		< 			    5, aad, aad_len, pos + (crypt - ie_start)) < 0) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Invalid AES-SIV data in the frame");
[K		< 		return -1;
[K		< 	}
[K		< 	wpa_hexdump(MSG_DEBUG, "FILS: Decrypted Association Request elements",
[K		< 		    pos, left - AES_BLOCK_SIZE);
[K		<
[K		< 	if (ieee802_11_parse_elems(pos, left - AES_BLOCK_SIZE, &elems, 1) ==
[K		< 	    ParseFailed) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Failed to parse decrypted elements");
[K		< 		return -1;
[K		< 	}
[K		< 	if (!elems.fils_key_confirm) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: No FILS Key Confirm element");
[K		< 		return -1;
[K		< 	}
[K		< 	if (elems.fils_key_confirm_len != sm->fils_key_auth_len) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Unexpected Key-Auth length %d (expected %d)",
[K		< 			   elems.fils_key_confirm_len,
[K		< 			   (int) sm->fils_key_auth_len);
[K		< 		return -1;
[K		< 	}
[K		< 	if (os_memcmp(elems.fils_key_confirm, sm->fils_key_auth_sta,
[K		< 		      sm->fils_key_auth_len) != 0) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Key-Auth mismatch");
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Received Key-Auth",
[K		< 			    elems.fils_key_confirm,
[K		< 			    elems.fils_key_confirm_len);
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Expected Key-Auth",
[K		< 			    sm->fils_key_auth_sta, sm->fils_key_auth_len);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return left - AES_BLOCK_SIZE;
[K		< }
[K		<
[K		<
[K		< int fils_encrypt_assoc(struct wpa_state_machine *sm, u8 *buf,
[K		< 		       size_t current_len, size_t max_len,
[K		< 		       const struct wpabuf *hlp)
[K		< {
[K		< 	u8 *end = buf + max_len;
[K		< 	u8 *pos = buf + current_len;
[K		< 	struct ieee80211_mgmt *mgmt;
[K		< 	struct wpabuf *plain;
[K		< 	u8 *len, *tmp, *tmp2;
[K		< 	u8 hdr[2];
[K		< 	u8 *gtk, dummy_gtk[32];
[K		< 	size_t gtk_len;
[K		< 	struct wpa_group *gsm;
[K		< 	const u8 *aad[5];
[K		< 	size_t aad_len[5];
[K		<
[K		< 	if (!sm || !sm->PTK_valid)
[K		< 		return -1;
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG,
[K		< 		    "FILS: Association Response frame before FILS processing",
[K		< 		    buf, current_len);
[K		<
[K		< 	mgmt = (struct ieee80211_mgmt *) buf;
[K		<
[K		< 	/* AES-SIV AAD vectors */
[K		<
[K		< 	/* The AP's BSSID */
[K		< 	aad[0] = mgmt->sa;
[K		< 	aad_len[0] = ETH_ALEN;
[K		< 	/* The STA's MAC address */
[K		< 	aad[1] = mgmt->da;
[K		< 	aad_len[1] = ETH_ALEN;
[K		< 	/* The AP's nonce */
[K		< 	aad[2] = sm->ANonce;
[K		< 	aad_len[2] = FILS_NONCE_LEN;
[K		< 	/* The STA's nonce */
[K		< 	aad[3] = sm->SNonce;
[K		< 	aad_len[3] = FILS_NONCE_LEN;
[K		< 	/*
[K		< 	 * The (Re)Association Response frame from the Capability Information
[K		< 	 * field (the same offset in both Association and Reassociation
[K		< 	 * Response frames) to the FILS Session element (both inclusive).
[K		< 	 */
[K		< 	aad[4] = (const u8 *) &mgmt->u.assoc_resp.capab_info;
[K		< 	aad_len[4] = pos - aad[4];
[K		<
[K		< 	/* The following elements will be encrypted with AES-SIV */
[K		<
[K		< 	plain = wpabuf_alloc(1000);
[K		< 	if (!plain)
[K		< 		return -1;
[K		<
[K		< 	/* TODO: FILS Public Key */
[K		<
[K		< 	/* FILS Key Confirmation */
[K		< 	wpabuf_put_u8(plain, WLAN_EID_EXTENSION); /* Element ID */
[K		< 	wpabuf_put_u8(plain, 1 + sm->fils_key_auth_len); /* Length */
[K		< 	/* Element ID Extension */
[K		< 	wpabuf_put_u8(plain, WLAN_EID_EXT_FILS_KEY_CONFIRM);
[K		< 	wpabuf_put_data(plain, sm->fils_key_auth_ap, sm->fils_key_auth_len);
[K		<
[K		< 	/* FILS HLP Container */
[K		< 	if (hlp)
[K		< 		wpabuf_put_buf(plain, hlp);
[K		<
[K		< 	/* TODO: FILS IP Address Assignment */
[K		<
[K		< 	/* Key Delivery */
[K		< 	gsm = sm->group;
[K		< 	wpabuf_put_u8(plain, WLAN_EID_EXTENSION); /* Element ID */
[K		< 	len = wpabuf_put(plain, 1);
[K		< 	wpabuf_put_u8(plain, WLAN_EID_EXT_KEY_DELIVERY);
[K		< 	wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN,
[K		< 			    wpabuf_put(plain, WPA_KEY_RSC_LEN));
[K		< 	/* GTK KDE */
[K		< 	gtk = gsm->GTK[gsm->GN - 1];
[K		< 	gtk_len = gsm->GTK_len;
[K		< 	if (sm->wpa_auth->conf.disable_gtk) {
[K		< 		/*
[K		< 		 * Provide unique random GTK to each STA to prevent use
[K		< 		 * of GTK in the BSS.
[K		< 		 */
[K		< 		if (random_get_bytes(dummy_gtk, gtk_len) < 0) {
[K		< 			wpabuf_free(plain);
[K		< 			return -1;
[K		< 		}
[K		< 		gtk = dummy_gtk;
[K		< 	}
[K		< 	hdr[0] = gsm->GN & 0x03;
[K		< 	hdr[1] = 0;
[K		< 	tmp = wpabuf_put(plain, 0);
[K		< 	tmp2 = wpa_add_kde(tmp, RSN_KEY_DATA_GROUPKEY, hdr, 2,
[K		< 			   gtk, gtk_len);
[K		< 	wpabuf_put(plain, tmp2 - tmp);
[K		<
[K		< 	/* IGTK KDE */
[K		< 	tmp = wpabuf_put(plain, 0);
[K		< 	tmp2 = ieee80211w_kde_add(sm, tmp);
[K		< 	wpabuf_put(plain, tmp2 - tmp);
[K		<
[K		< 	*len = (u8 *) wpabuf_put(plain, 0) - len - 1;
[K		<
[K		< 	if (pos + wpabuf_len(plain) + AES_BLOCK_SIZE > end) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Not enough room for FILS elements");
[K		< 		wpabuf_free(plain);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	wpa_hexdump_buf_key(MSG_DEBUG, "FILS: Association Response plaintext",
[K		< 			    plain);
[K		<
[K		< 	if (aes_siv_encrypt(sm->PTK.kek, sm->PTK.kek_len,
[K		< 			    wpabuf_head(plain), wpabuf_len(plain),
[K		< 			    5, aad, aad_len, pos) < 0) {
[K		< 		wpabuf_free(plain);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG,
[K		< 		    "FILS: Encrypted Association Response elements",
[K		< 		    pos, AES_BLOCK_SIZE + wpabuf_len(plain));
[K		< 	current_len += wpabuf_len(plain) + AES_BLOCK_SIZE;
[K		< 	wpabuf_free(plain);
[K		<
[K		< 	sm->fils_completed = 1;
[K		<
[K		< 	return current_len;
[K		< }
[K		<
[K		<
[K		< int fils_set_tk(struct wpa_state_machine *sm)
[K		< {
[K		< 	enum wpa_alg alg;
[K		< 	int klen;
[K		<
[K		< 	if (!sm || !sm->PTK_valid)
[K		< 		return -1;
[K		<
[K		< 	alg = wpa_cipher_to_alg(sm->pairwise);
[K		< 	klen = wpa_cipher_key_len(sm->pairwise);
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "FILS: Configure TK to the driver");
[K		< 	if (wpa_auth_set_key(sm->wpa_auth, 0, alg, sm->addr, 0,
[K		< 			     sm->PTK.tk, klen)) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Failed to set TK to the driver");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		< #endif /* CONFIG_FILS */
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, PTKCALCNEGOTIATING)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = sm->wpa_auth;
[K		< 	struct wpa_ptk PTK;
[K		< 	int ok = 0, psk_found = 0;
[K		< 	const u8 *pmk = NULL;
[K		< 	unsigned int pmk_len;
[K		< 	int ft;
[K		< 	const u8 *eapol_key_ie, *key_data, *mic;
[K		< 	u16 key_data_length;
[K		< 	size_t mic_len, eapol_key_ie_len;
[K		< 	struct ieee802_1x_hdr *hdr;
[K		< 	struct wpa_eapol_key *key;
[K		< 	struct wpa_eapol_ie_parse kde;
[K		<
[K		< 	SM_ENTRY_MA(WPA_PTK, PTKCALCNEGOTIATING, wpa_ptk);
[K		< 	sm->EAPOLKeyReceived = FALSE;
[K		< 	sm->update_snonce = FALSE;
[K		< 	os_memset(&PTK, 0, sizeof(PTK));
[K		<
[K		< 	mic_len = wpa_mic_len(sm->wpa_key_mgmt);
[K		<
[K		< 	/* WPA with IEEE 802.1X: use the derived PMK from EAP
[K		< 	 * WPA-PSK: iterate through possible PSKs and select the one matching
[K		< 	 * the packet */
[K		< 	for (;;) {
[K		< 		if (wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt)) {
[K		< 			pmk = wpa_auth_get_psk(sm->wpa_auth, sm->addr,
[K		< 					       sm->p2p_dev_addr, pmk);
[K		< 			if (pmk == NULL)
[K		< 				break;
[K		< 			psk_found = 1;
[K		< 			pmk_len = PMK_LEN;
[K		< 		} else {
[K		< 			pmk = sm->PMK;
[K		< 			pmk_len = sm->pmk_len;
[K		< 		}
[K		<
[K		< 		if (wpa_derive_ptk(sm, sm->SNonce, pmk, pmk_len, &PTK) < 0)
[K		< 			break;
[K		<
[K		< 		if (mic_len &&
[K		< 		    wpa_verify_key_mic(sm->wpa_key_mgmt, &PTK,
[K		< 				       sm->last_rx_eapol_key,
[K		< 				       sm->last_rx_eapol_key_len) == 0) {
[K		< 			ok = 1;
[K		< 			break;
[K		< 		}
[K		<
[K		< #ifdef CONFIG_FILS
[K		< 		if (!mic_len &&
[K		< 		    wpa_aead_decrypt(sm, &PTK, sm->last_rx_eapol_key,
[K		< 				     sm->last_rx_eapol_key_len, NULL) == 0) {
[K		< 			ok = 1;
[K		< 			break;
[K		< 		}
[K		< #endif /* CONFIG_FILS */
[K		<
[K		< 		if (!wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt))
[K		< 			break;
[K		< 	}
[K		<
[K		< 	if (!ok) {
[K		< 		wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"invalid MIC in msg 2/4 of 4-Way Handshake");
[K		< 		if (psk_found)
[K		< 			wpa_auth_psk_failure_report(sm->wpa_auth, sm->addr);
[K		< 		return;
[K		< 	}
[K		<
[K		< 	/*
[K		< 	 * Note: last_rx_eapol_key length fields have already been validated in
[K		< 	 * wpa_receive().
[K		< 	 */
[K		< 	hdr = (struct ieee802_1x_hdr *) sm->last_rx_eapol_key;
[K		< 	key = (struct wpa_eapol_key *) (hdr + 1);
[K		< 	mic = (u8 *) (key + 1);
[K		< 	key_data = mic + mic_len + 2;
[K		< 	key_data_length = WPA_GET_BE16(mic + mic_len);
[K		< 	if (key_data_length > sm->last_rx_eapol_key_len - sizeof(*hdr) -
[K		< 	    sizeof(*key) - mic_len - 2)
[K		< 		return;
[K		<
[K		< 	if (wpa_parse_kde_ies(key_data, key_data_length, &kde) < 0) {
[K		< 		wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				 "received EAPOL-Key msg 2/4 with invalid Key Data contents");
[K		< 		return;
[K		< 	}
[K		< 	if (kde.rsn_ie) {
[K		< 		eapol_key_ie = kde.rsn_ie;
[K		< 		eapol_key_ie_len = kde.rsn_ie_len;
[K		< 	} else if (kde.osen) {
[K		< 		eapol_key_ie = kde.osen;
[K		< 		eapol_key_ie_len = kde.osen_len;
[K		< 	} else {
[K		< 		eapol_key_ie = kde.wpa_ie;
[K		< 		eapol_key_ie_len = kde.wpa_ie_len;
[K		< 	}
[K		< 	ft = sm->wpa == WPA_VERSION_WPA2 && wpa_key_mgmt_ft(sm->wpa_key_mgmt);
[K		< 	if (sm->wpa_ie == NULL ||
[K		< 	    wpa_compare_rsn_ie(ft, sm->wpa_ie, sm->wpa_ie_len,
[K		< 			       eapol_key_ie, eapol_key_ie_len)) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"WPA IE from (Re)AssocReq did not match with msg 2/4");
[K		< 		if (sm->wpa_ie) {
[K		< 			wpa_hexdump(MSG_DEBUG, "WPA IE in AssocReq",
[K		< 				    sm->wpa_ie, sm->wpa_ie_len);
[K		< 		}
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA IE in msg 2/4",
[K		< 			    eapol_key_ie, eapol_key_ie_len);
[K		< 		/* MLME-DEAUTHENTICATE.request */
[K		< 		wpa_sta_disconnect(wpa_auth, sm->addr);
[K		< 		return;
[K		< 	}
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (ft && ft_check_msg_2_of_4(wpa_auth, sm, &kde) < 0) {
[K		< 		wpa_sta_disconnect(wpa_auth, sm->addr);
[K		< 		return;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< #ifdef CONFIG_P2P
[K		< 	if (kde.ip_addr_req && kde.ip_addr_req[0] &&
[K		< 	    wpa_auth->ip_pool && WPA_GET_BE32(sm->ip_addr) == 0) {
[K		< 		int idx;
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "P2P: IP address requested in EAPOL-Key exchange");
[K		< 		idx = bitfield_get_first_zero(wpa_auth->ip_pool);
[K		< 		if (idx >= 0) {
[K		< 			u32 start = WPA_GET_BE32(wpa_auth->conf.ip_addr_start);
[K		< 			bitfield_set(wpa_auth->ip_pool, idx);
[K		< 			WPA_PUT_BE32(sm->ip_addr, start + idx);
[K		< 			wpa_printf(MSG_DEBUG,
[K		< 				   "P2P: Assigned IP address %u.%u.%u.%u to "
[K		< 				   MACSTR, sm->ip_addr[0], sm->ip_addr[1],
[K		< 				   sm->ip_addr[2], sm->ip_addr[3],
[K		< 				   MAC2STR(sm->addr));
[K		< 		}
[K		< 	}
[K		< #endif /* CONFIG_P2P */
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (sm->wpa == WPA_VERSION_WPA2 && wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
[K		< 		/*
[K		< 		 * Verify that PMKR1Name from EAPOL-Key message 2/4 matches
[K		< 		 * with the value we derived.
[K		< 		 */
[K		< 		if (os_memcmp_const(sm->sup_pmk_r1_name, sm->pmk_r1_name,
[K		< 				    WPA_PMK_NAME_LEN) != 0) {
[K		< 			wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					"PMKR1Name mismatch in FT 4-way "
[K		< 					"handshake");
[K		< 			wpa_hexdump(MSG_DEBUG, "FT: PMKR1Name from "
[K		< 				    "Supplicant",
[K		< 				    sm->sup_pmk_r1_name, WPA_PMK_NAME_LEN);
[K		< 			wpa_hexdump(MSG_DEBUG, "FT: Derived PMKR1Name",
[K		< 				    sm->pmk_r1_name, WPA_PMK_NAME_LEN);
[K		< 			return;
[K		< 		}
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		< 	sm->pending_1_of_4_timeout = 0;
[K		< 	eloop_cancel_timeout(wpa_send_eapol_timeout, sm->wpa_auth, sm);
[K		<
[K		< 	if (wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt)) {
[K		< 		/* PSK may have changed from the previous choice, so update
[K		< 		 * state machine data based on whatever PSK was selected here.
[K		< 		 */
[K		< 		os_memcpy(sm->PMK, pmk, PMK_LEN);
[K		< 		sm->pmk_len = PMK_LEN;
[K		< 	}
[K		<
[K		< 	sm->MICVerified = TRUE;
[K		<
[K		< 	os_memcpy(&sm->PTK, &PTK, sizeof(PTK));
[K		< 	sm->PTK_valid = TRUE;
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, PTKCALCNEGOTIATING2)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, PTKCALCNEGOTIATING2, wpa_ptk);
[K		< 	sm->TimeoutCtr = 0;
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_IEEE80211W
[K		<
[K		< static int ieee80211w_kde_len(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm->mgmt_frame_prot) {
[K		< 		size_t len;
[K		< 		len = wpa_cipher_key_len(sm->wpa_auth->conf.group_mgmt_cipher);
[K		< 		return 2 + RSN_SELECTOR_LEN + WPA_IGTK_KDE_PREFIX_LEN + len;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static u8 * ieee80211w_kde_add(struct wpa_state_machine *sm, u8 *pos)
[K		< {
[K		< 	struct wpa_igtk_kde igtk;
[K		< 	struct wpa_group *gsm = sm->group;
[K		< 	u8 rsc[WPA_KEY_RSC_LEN];
[K		< 	size_t len = wpa_cipher_key_len(sm->wpa_auth->conf.group_mgmt_cipher);
[K		<
[K		< 	if (!sm->mgmt_frame_prot)
[K		< 		return pos;
[K		<
[K		< 	igtk.keyid[0] = gsm->GN_igtk;
[K		< 	igtk.keyid[1] = 0;
[K		< 	if (gsm->wpa_group_state != WPA_GROUP_SETKEYSDONE ||
[K		< 	    wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN_igtk, rsc) < 0)
[K		< 		os_memset(igtk.pn, 0, sizeof(igtk.pn));
[K		< 	else
[K		< 		os_memcpy(igtk.pn, rsc, sizeof(igtk.pn));
[K		< 	os_memcpy(igtk.igtk, gsm->IGTK[gsm->GN_igtk - 4], len);
[K		< 	if (sm->wpa_auth->conf.disable_gtk) {
[K		< 		/*
[K		< 		 * Provide unique random IGTK to each STA to prevent use of
[K		< 		 * IGTK in the BSS.
[K		< 		 */
[K		< 		if (random_get_bytes(igtk.igtk, len) < 0)
[K		< 			return pos;
[K		< 	}
[K		< 	pos = wpa_add_kde(pos, RSN_KEY_DATA_IGTK,
[K		< 			  (const u8 *) &igtk, WPA_IGTK_KDE_PREFIX_LEN + len,
[K		< 			  NULL, 0);
[K		<
[K		< 	return pos;
[K		< }
[K		<
[K		< #else /* CONFIG_IEEE80211W */
[K		<
[K		< static int ieee80211w_kde_len(struct wpa_state_machine *sm)
[K		< {
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static u8 * ieee80211w_kde_add(struct wpa_state_machine *sm, u8 *pos)
[K		< {
[K		< 	return pos;
[K		< }
[K		<
[K		< #endif /* CONFIG_IEEE80211W */
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, PTKINITNEGOTIATING)
[K		< {
[K		< 	u8 rsc[WPA_KEY_RSC_LEN], *_rsc, *gtk, *kde, *pos, dummy_gtk[32];
[K		< 	size_t gtk_len, kde_len;
[K		< 	struct wpa_group *gsm = sm->group;
[K		< 	u8 *wpa_ie;
[K		< 	int wpa_ie_len, secure, keyidx, encr = 0;
[K		<
[K		< 	SM_ENTRY_MA(WPA_PTK, PTKINITNEGOTIATING, wpa_ptk);
[K		< 	sm->TimeoutEvt = FALSE;
[K		<
[K		< 	sm->TimeoutCtr++;
[K		< 	if (sm->TimeoutCtr > sm->wpa_auth->conf.wpa_pairwise_update_count) {
[K		< 		/* No point in sending the EAPOL-Key - we will disconnect
[K		< 		 * immediately following this. */
[K		< 		return;
[K		< 	}
[K		<
[K		< 	/* Send EAPOL(1, 1, 1, Pair, P, RSC, ANonce, MIC(PTK), RSNIE, [MDIE],
[K		< 	   GTK[GN], IGTK, [FTIE], [TIE * 2])
[K		< 	 */
[K		< 	os_memset(rsc, 0, WPA_KEY_RSC_LEN);
[K		< 	wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN, rsc);
[K		< 	/* If FT is used, wpa_auth->wpa_ie includes both RSNIE and MDIE */
[K		< 	wpa_ie = sm->wpa_auth->wpa_ie;
[K		< 	wpa_ie_len = sm->wpa_auth->wpa_ie_len;
[K		< 	if (sm->wpa == WPA_VERSION_WPA &&
[K		< 	    (sm->wpa_auth->conf.wpa & WPA_PROTO_RSN) &&
[K		< 	    wpa_ie_len > wpa_ie[1] + 2 && wpa_ie[0] == WLAN_EID_RSN) {
[K		< 		/* WPA-only STA, remove RSN IE and possible MDIE */
[K		< 		wpa_ie = wpa_ie + wpa_ie[1] + 2;
[K		< 		if (wpa_ie[0] == WLAN_EID_MOBILITY_DOMAIN)
[K		< 			wpa_ie = wpa_ie + wpa_ie[1] + 2;
[K		< 		wpa_ie_len = wpa_ie[1] + 2;
[K		< 	}
[K		< 	wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 			"sending 3/4 msg of 4-Way Handshake");
[K		< 	if (sm->wpa == WPA_VERSION_WPA2) {
[K		< 		/* WPA2 send GTK in the 4-way handshake */
[K		< 		secure = 1;
[K		< 		gtk = gsm->GTK[gsm->GN - 1];
[K		< 		gtk_len = gsm->GTK_len;
[K		< 		if (sm->wpa_auth->conf.disable_gtk) {
[K		< 			/*
[K		< 			 * Provide unique random GTK to each STA to prevent use
[K		< 			 * of GTK in the BSS.
[K		< 			 */
[K		< 			if (random_get_bytes(dummy_gtk, gtk_len) < 0)
[K		< 				return;
[K		< 			gtk = dummy_gtk;
[K		< 		}
[K		< 		keyidx = gsm->GN;
[K		< 		_rsc = rsc;
[K		< 		encr = 1;
[K		< 	} else {
[K		< 		/* WPA does not include GTK in msg 3/4 */
[K		< 		secure = 0;
[K		< 		gtk = NULL;
[K		< 		gtk_len = 0;
[K		< 		keyidx = 0;
[K		< 		_rsc = NULL;
[K		< 		if (sm->rx_eapol_key_secure) {
[K		< 			/*
[K		< 			 * It looks like Windows 7 supplicant tries to use
[K		< 			 * Secure bit in msg 2/4 after having reported Michael
[K		< 			 * MIC failure and it then rejects the 4-way handshake
[K		< 			 * if msg 3/4 does not set Secure bit. Work around this
[K		< 			 * by setting the Secure bit here even in the case of
[K		< 			 * WPA if the supplicant used it first.
[K		< 			 */
[K		< 			wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					"STA used Secure bit in WPA msg 2/4 - "
[K		< 					"set Secure for 3/4 as workaround");
[K		< 			secure = 1;
[K		< 		}
[K		< 	}
[K		<
[K		< 	kde_len = wpa_ie_len + ieee80211w_kde_len(sm);
[K		< 	if (gtk)
[K		< 		kde_len += 2 + RSN_SELECTOR_LEN + 2 + gtk_len;
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
[K		< 		kde_len += 2 + PMKID_LEN; /* PMKR1Name into RSN IE */
[K		< 		kde_len += 300; /* FTIE + 2 * TIE */
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< #ifdef CONFIG_P2P
[K		< 	if (WPA_GET_BE32(sm->ip_addr) > 0)
[K		< 		kde_len += 2 + RSN_SELECTOR_LEN + 3 * 4;
[K		< #endif /* CONFIG_P2P */
[K		< 	kde = os_malloc(kde_len);
[K		< 	if (kde == NULL)
[K		< 		return;
[K		<
[K		< 	pos = kde;
[K		< 	os_memcpy(pos, wpa_ie, wpa_ie_len);
[K		< 	pos += wpa_ie_len;
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
[K		< 		int res;
[K		< 		size_t elen;
[K		<
[K		< 		elen = pos - kde;
[K		< 		res = wpa_insert_pmkid(kde, &elen, sm->pmk_r1_name);
[K		< 		if (res < 0) {
[K		< 			wpa_printf(MSG_ERROR, "FT: Failed to insert "
[K		< 				   "PMKR1Name into RSN IE in EAPOL-Key data");
[K		< 			os_free(kde);
[K		< 			return;
[K		< 		}
[K		< 		pos -= wpa_ie_len;
[K		< 		pos += elen;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< 	if (gtk) {
[K		< 		u8 hdr[2];
[K		< 		hdr[0] = keyidx & 0x03;
[K		< 		hdr[1] = 0;
[K		< 		pos = wpa_add_kde(pos, RSN_KEY_DATA_GROUPKEY, hdr, 2,
[K		< 				  gtk, gtk_len);
[K		< 	}
[K		< 	pos = ieee80211w_kde_add(sm, pos);
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
[K		< 		int res;
[K		< 		struct wpa_auth_config *conf;
[K		<
[K		< 		conf = &sm->wpa_auth->conf;
[K		< 		if (sm->assoc_resp_ftie &&
[K		< 		    kde + kde_len - pos >= 2 + sm->assoc_resp_ftie[1]) {
[K		< 			os_memcpy(pos, sm->assoc_resp_ftie,
[K		< 				  2 + sm->assoc_resp_ftie[1]);
[K		< 			res = 2 + sm->assoc_resp_ftie[1];
[K		< 		} else {
[K		< 			res = wpa_write_ftie(conf, conf->r0_key_holder,
[K		< 					     conf->r0_key_holder_len,
[K		< 					     NULL, NULL, pos,
[K		< 					     kde + kde_len - pos,
[K		< 					     NULL, 0);
[K		< 		}
[K		< 		if (res < 0) {
[K		< 			wpa_printf(MSG_ERROR, "FT: Failed to insert FTIE "
[K		< 				   "into EAPOL-Key Key Data");
[K		< 			os_free(kde);
[K		< 			return;
[K		< 		}
[K		< 		pos += res;
[K		<
[K		< 		/* TIE[ReassociationDeadline] (TU) */
[K		< 		*pos++ = WLAN_EID_TIMEOUT_INTERVAL;
[K		< 		*pos++ = 5;
[K		< 		*pos++ = WLAN_TIMEOUT_REASSOC_DEADLINE;
[K		< 		WPA_PUT_LE32(pos, conf->reassociation_deadline);
[K		< 		pos += 4;
[K		<
[K		< 		/* TIE[KeyLifetime] (seconds) */
[K		< 		*pos++ = WLAN_EID_TIMEOUT_INTERVAL;
[K		< 		*pos++ = 5;
[K		< 		*pos++ = WLAN_TIMEOUT_KEY_LIFETIME;
[K		< 		WPA_PUT_LE32(pos, conf->r0_key_lifetime * 60);
[K		< 		pos += 4;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< #ifdef CONFIG_P2P
[K		< 	if (WPA_GET_BE32(sm->ip_addr) > 0) {
[K		< 		u8 addr[3 * 4];
[K		< 		os_memcpy(addr, sm->ip_addr, 4);
[K		< 		os_memcpy(addr + 4, sm->wpa_auth->conf.ip_addr_mask, 4);
[K		< 		os_memcpy(addr + 8, sm->wpa_auth->conf.ip_addr_go, 4);
[K		< 		pos = wpa_add_kde(pos, WFA_KEY_DATA_IP_ADDR_ALLOC,
[K		< 				  addr, sizeof(addr), NULL, 0);
[K		< 	}
[K		< #endif /* CONFIG_P2P */
[K		<
[K		< 	wpa_send_eapol(sm->wpa_auth, sm,
[K		< 		       (secure ? WPA_KEY_INFO_SECURE : 0) |
[K		< 		       (wpa_mic_len(sm->wpa_key_mgmt) ? WPA_KEY_INFO_MIC : 0) |
[K		< 		       WPA_KEY_INFO_ACK | WPA_KEY_INFO_INSTALL |
[K		< 		       WPA_KEY_INFO_KEY_TYPE,
[K		< 		       _rsc, sm->ANonce, kde, pos - kde, keyidx, encr);
[K		< 	os_free(kde);
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, PTKINITDONE)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, PTKINITDONE, wpa_ptk);
[K		< 	sm->EAPOLKeyReceived = FALSE;
[K		< 	if (sm->Pair) {
[K		< 		enum wpa_alg alg = wpa_cipher_to_alg(sm->pairwise);
[K		< 		int klen = wpa_cipher_key_len(sm->pairwise);
[K		< 		if (wpa_auth_set_key(sm->wpa_auth, 0, alg, sm->addr, 0,
[K		< 				     sm->PTK.tk, klen)) {
[K		< 			wpa_sta_disconnect(sm->wpa_auth, sm->addr);
[K		< 			return;
[K		< 		}
[K		< 		/* FIX: MLME-SetProtection.Request(TA, Tx_Rx) */
[K		< 		sm->pairwise_set = TRUE;
[K		<
[K		< 		if (sm->wpa_auth->conf.wpa_ptk_rekey) {
[K		< 			eloop_cancel_timeout(wpa_rekey_ptk, sm->wpa_auth, sm);
[K		< 			eloop_register_timeout(sm->wpa_auth->conf.
[K		< 					       wpa_ptk_rekey, 0, wpa_rekey_ptk,
[K		< 					       sm->wpa_auth, sm);
[K		< 		}
[K		<
[K		< 		if (wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt)) {
[K		< 			wpa_auth_set_eapol(sm->wpa_auth, sm->addr,
[K		< 					   WPA_EAPOL_authorized, 1);
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (0 /* IBSS == TRUE */) {
[K		< 		sm->keycount++;
[K		< 		if (sm->keycount == 2) {
[K		< 			wpa_auth_set_eapol(sm->wpa_auth, sm->addr,
[K		< 					   WPA_EAPOL_portValid, 1);
[K		< 		}
[K		< 	} else {
[K		< 		wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_portValid,
[K		< 				   1);
[K		< 	}
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_keyAvailable, 0);
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_keyDone, 1);
[K		< 	if (sm->wpa == WPA_VERSION_WPA)
[K		< 		sm->PInitAKeys = TRUE;
[K		< 	else
[K		< 		sm->has_GTK = TRUE;
[K		< 	wpa_auth_vlogger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 			 "pairwise key handshake completed (%s)",
[K		< 			 sm->wpa == WPA_VERSION_WPA ? "WPA" : "RSN");
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	wpa_ft_push_pmk_r1(sm->wpa_auth, sm->addr);
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< }
[K		<
[K		<
[K		< SM_STEP(WPA_PTK)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = sm->wpa_auth;
[K		<
[K		< 	if (sm->Init)
[K		< 		SM_ENTER(WPA_PTK, INITIALIZE);
[K		< 	else if (sm->Disconnect
[K		< 		 /* || FIX: dot11RSNAConfigSALifetime timeout */) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"WPA_PTK: sm->Disconnect");
[K		< 		SM_ENTER(WPA_PTK, DISCONNECT);
[K		< 	}
[K		< 	else if (sm->DeauthenticationRequest)
[K		< 		SM_ENTER(WPA_PTK, DISCONNECTED);
[K		< 	else if (sm->AuthenticationRequest)
[K		< 		SM_ENTER(WPA_PTK, AUTHENTICATION);
[K		< 	else if (sm->ReAuthenticationRequest)
[K		< 		SM_ENTER(WPA_PTK, AUTHENTICATION2);
[K		< 	else if (sm->PTKRequest)
[K		< 		SM_ENTER(WPA_PTK, PTKSTART);
[K		< 	else switch (sm->wpa_ptk_state) {
[K		< 	case WPA_PTK_INITIALIZE:
[K		< 		break;
[K		< 	case WPA_PTK_DISCONNECT:
[K		< 		SM_ENTER(WPA_PTK, DISCONNECTED);
[K		< 		break;
[K		< 	case WPA_PTK_DISCONNECTED:
[K		< 		SM_ENTER(WPA_PTK, INITIALIZE);
[K		< 		break;
[K		< 	case WPA_PTK_AUTHENTICATION:
[K		< 		SM_ENTER(WPA_PTK, AUTHENTICATION2);
[K		< 		break;
[K		< 	case WPA_PTK_AUTHENTICATION2:
[K		< 		if (wpa_key_mgmt_wpa_ieee8021x(sm->wpa_key_mgmt) &&
[K		< 		    wpa_auth_get_eapol(sm->wpa_auth, sm->addr,
[K		< 				       WPA_EAPOL_keyRun) > 0)
[K		< 			SM_ENTER(WPA_PTK, INITPMK);
[K		< 		else if (wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt)
[K		< 			 /* FIX: && 802.1X::keyRun */)
[K		< 			SM_ENTER(WPA_PTK, INITPSK);
[K		< 		break;
[K		< 	case WPA_PTK_INITPMK:
[K		< 		if (wpa_auth_get_eapol(sm->wpa_auth, sm->addr,
[K		< 				       WPA_EAPOL_keyAvailable) > 0)
[K		< 			SM_ENTER(WPA_PTK, PTKSTART);
[K		< 		else {
[K		< 			wpa_auth->dot11RSNA4WayHandshakeFailures++;
[K		< 			wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"INITPMK - keyAvailable = false");
[K		< 			SM_ENTER(WPA_PTK, DISCONNECT);
[K		< 		}
[K		< 		break;
[K		< 	case WPA_PTK_INITPSK:
[K		< 		if (wpa_auth_get_psk(sm->wpa_auth, sm->addr, sm->p2p_dev_addr,
[K		< 				     NULL))
[K		< 			SM_ENTER(WPA_PTK, PTKSTART);
[K		< 		else {
[K		< 			wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"no PSK configured for the STA");
[K		< 			wpa_auth->dot11RSNA4WayHandshakeFailures++;
[K		< 			SM_ENTER(WPA_PTK, DISCONNECT);
[K		< 		}
[K		< 		break;
[K		< 	case WPA_PTK_PTKSTART:
[K		< 		if (sm->EAPOLKeyReceived && !sm->EAPOLKeyRequest &&
[K		< 		    sm->EAPOLKeyPairwise)
[K		< 			SM_ENTER(WPA_PTK, PTKCALCNEGOTIATING);
[K		< 		else if (sm->TimeoutCtr >
[K		< 			 sm->wpa_auth->conf.wpa_pairwise_update_count) {
[K		< 			wpa_auth->dot11RSNA4WayHandshakeFailures++;
[K		< 			wpa_auth_vlogger(
[K		< 				sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"PTKSTART: Retry limit %u reached",
[K		< 				sm->wpa_auth->conf.wpa_pairwise_update_count);
[K		< 			SM_ENTER(WPA_PTK, DISCONNECT);
[K		< 		} else if (sm->TimeoutEvt)
[K		< 			SM_ENTER(WPA_PTK, PTKSTART);
[K		< 		break;
[K		< 	case WPA_PTK_PTKCALCNEGOTIATING:
[K		< 		if (sm->MICVerified)
[K		< 			SM_ENTER(WPA_PTK, PTKCALCNEGOTIATING2);
[K		< 		else if (sm->EAPOLKeyReceived && !sm->EAPOLKeyRequest &&
[K		< 			 sm->EAPOLKeyPairwise)
[K		< 			SM_ENTER(WPA_PTK, PTKCALCNEGOTIATING);
[K		< 		else if (sm->TimeoutEvt)
[K		< 			SM_ENTER(WPA_PTK, PTKSTART);
[K		< 		break;
[K		< 	case WPA_PTK_PTKCALCNEGOTIATING2:
[K		< 		SM_ENTER(WPA_PTK, PTKINITNEGOTIATING);
[K		< 		break;
[K		< 	case WPA_PTK_PTKINITNEGOTIATING:
[K		< 		if (sm->update_snonce)
[K		< 			SM_ENTER(WPA_PTK, PTKCALCNEGOTIATING);
[K		< 		else if (sm->EAPOLKeyReceived && !sm->EAPOLKeyRequest &&
[K		< 			 sm->EAPOLKeyPairwise && sm->MICVerified)
[K		< 			SM_ENTER(WPA_PTK, PTKINITDONE);
[K		< 		else if (sm->TimeoutCtr >
[K		< 			 sm->wpa_auth->conf.wpa_pairwise_update_count) {
[K		< 			wpa_auth->dot11RSNA4WayHandshakeFailures++;
[K		< 			wpa_auth_vlogger(
[K		< 				sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"PTKINITNEGOTIATING: Retry limit %u reached",
[K		< 				sm->wpa_auth->conf.wpa_pairwise_update_count);
[K		< 			SM_ENTER(WPA_PTK, DISCONNECT);
[K		< 		} else if (sm->TimeoutEvt)
[K		< 			SM_ENTER(WPA_PTK, PTKINITNEGOTIATING);
[K		< 		break;
[K		< 	case WPA_PTK_PTKINITDONE:
[K		< 		break;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK_GROUP, IDLE)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK_GROUP, IDLE, wpa_ptk_group);
[K		< 	if (sm->Init) {
[K		< 		/* Init flag is not cleared here, so avoid busy
[K		< 		 * loop by claiming nothing changed. */
[K		< 		sm->changed = FALSE;
[K		< 	}
[K		< 	sm->GTimeoutCtr = 0;
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK_GROUP, REKEYNEGOTIATING)
[K		< {
[K		< 	u8 rsc[WPA_KEY_RSC_LEN];
[K		< 	struct wpa_group *gsm = sm->group;
[K		< 	const u8 *kde;
[K		< 	u8 *kde_buf = NULL, *pos, hdr[2];
[K		< 	size_t kde_len;
[K		< 	u8 *gtk, dummy_gtk[32];
[K		<
[K		< 	SM_ENTRY_MA(WPA_PTK_GROUP, REKEYNEGOTIATING, wpa_ptk_group);
[K		<
[K		< 	sm->GTimeoutCtr++;
[K		< 	if (sm->GTimeoutCtr > sm->wpa_auth->conf.wpa_group_update_count) {
[K		< 		/* No point in sending the EAPOL-Key - we will disconnect
[K		< 		 * immediately following this. */
[K		< 		return;
[K		< 	}
[K		<
[K		< 	if (sm->wpa == WPA_VERSION_WPA)
[K		< 		sm->PInitAKeys = FALSE;
[K		< 	sm->TimeoutEvt = FALSE;
[K		< 	/* Send EAPOL(1, 1, 1, !Pair, G, RSC, GNonce, MIC(PTK), GTK[GN]) */
[K		< 	os_memset(rsc, 0, WPA_KEY_RSC_LEN);
[K		< 	if (gsm->wpa_group_state == WPA_GROUP_SETKEYSDONE)
[K		< 		wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN, rsc);
[K		< 	wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 			"sending 1/2 msg of Group Key Handshake");
[K		<
[K		< 	gtk = gsm->GTK[gsm->GN - 1];
[K		< 	if (sm->wpa_auth->conf.disable_gtk) {
[K		< 		/*
[K		< 		 * Provide unique random GTK to each STA to prevent use
[K		< 		 * of GTK in the BSS.
[K		< 		 */
[K		< 		if (random_get_bytes(dummy_gtk, gsm->GTK_len) < 0)
[K		< 			return;
[K		< 		gtk = dummy_gtk;
[K		< 	}
[K		< 	if (sm->wpa == WPA_VERSION_WPA2) {
[K		< 		kde_len = 2 + RSN_SELECTOR_LEN + 2 + gsm->GTK_len +
[K		< 			ieee80211w_kde_len(sm);
[K		< 		kde_buf = os_malloc(kde_len);
[K		< 		if (kde_buf == NULL)
[K		< 			return;
[K		<
[K		< 		kde = pos = kde_buf;
[K		< 		hdr[0] = gsm->GN & 0x03;
[K		< 		hdr[1] = 0;
[K		< 		pos = wpa_add_kde(pos, RSN_KEY_DATA_GROUPKEY, hdr, 2,
[K		< 				  gtk, gsm->GTK_len);
[K		< 		pos = ieee80211w_kde_add(sm, pos);
[K		< 		kde_len = pos - kde;
[K		< 	} else {
[K		< 		kde = gtk;
[K		< 		kde_len = gsm->GTK_len;
[K		< 	}
[K		<
[K		< 	wpa_send_eapol(sm->wpa_auth, sm,
[K		< 		       WPA_KEY_INFO_SECURE |
[K		< 		       (wpa_mic_len(sm->wpa_key_mgmt) ? WPA_KEY_INFO_MIC : 0) |
[K		< 		       WPA_KEY_INFO_ACK |
[K		< 		       (!sm->Pair ? WPA_KEY_INFO_INSTALL : 0),
[K		< 		       rsc, NULL, kde, kde_len, gsm->GN, 1);
[K		<
[K		< 	os_free(kde_buf);
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK_GROUP, REKEYESTABLISHED)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK_GROUP, REKEYESTABLISHED, wpa_ptk_group);
[K		< 	sm->EAPOLKeyReceived = FALSE;
[K		< 	if (sm->GUpdateStationKeys)
[K		< 		sm->group->GKeyDoneStations--;
[K		< 	sm->GUpdateStationKeys = FALSE;
[K		< 	sm->GTimeoutCtr = 0;
[K		< 	/* FIX: MLME.SetProtection.Request(TA, Tx_Rx) */
[K		< 	wpa_auth_vlogger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 			 "group key handshake completed (%s)",
[K		< 			 sm->wpa == WPA_VERSION_WPA ? "WPA" : "RSN");
[K		< 	sm->has_GTK = TRUE;
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK_GROUP, KEYERROR)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK_GROUP, KEYERROR, wpa_ptk_group);
[K		< 	if (sm->GUpdateStationKeys)
[K		< 		sm->group->GKeyDoneStations--;
[K		< 	sm->GUpdateStationKeys = FALSE;
[K		< 	sm->Disconnect = TRUE;
[K		< 	wpa_auth_vlogger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 			 "group key handshake failed (%s) after %u tries",
[K		< 			 sm->wpa == WPA_VERSION_WPA ? "WPA" : "RSN",
[K		< 			 sm->wpa_auth->conf.wpa_group_update_count);
[K		< }
[K		<
[K		<
[K		< SM_STEP(WPA_PTK_GROUP)
[K		< {
[K		< 	if (sm->Init || sm->PtkGroupInit) {
[K		< 		SM_ENTER(WPA_PTK_GROUP, IDLE);
[K		< 		sm->PtkGroupInit = FALSE;
[K		< 	} else switch (sm->wpa_ptk_group_state) {
[K		< 	case WPA_PTK_GROUP_IDLE:
[K		< 		if (sm->GUpdateStationKeys ||
[K		< 		    (sm->wpa == WPA_VERSION_WPA && sm->PInitAKeys))
[K		< 			SM_ENTER(WPA_PTK_GROUP, REKEYNEGOTIATING);
[K		< 		break;
[K		< 	case WPA_PTK_GROUP_REKEYNEGOTIATING:
[K		< 		if (sm->EAPOLKeyReceived && !sm->EAPOLKeyRequest &&
[K		< 		    !sm->EAPOLKeyPairwise && sm->MICVerified)
[K		< 			SM_ENTER(WPA_PTK_GROUP, REKEYESTABLISHED);
[K		< 		else if (sm->GTimeoutCtr >
[K		< 			 sm->wpa_auth->conf.wpa_group_update_count)
[K		< 			SM_ENTER(WPA_PTK_GROUP, KEYERROR);
[K		< 		else if (sm->TimeoutEvt)
[K		< 			SM_ENTER(WPA_PTK_GROUP, REKEYNEGOTIATING);
[K		< 		break;
[K		< 	case WPA_PTK_GROUP_KEYERROR:
[K		< 		SM_ENTER(WPA_PTK_GROUP, IDLE);
[K		< 		break;
[K		< 	case WPA_PTK_GROUP_REKEYESTABLISHED:
[K		< 		SM_ENTER(WPA_PTK_GROUP, IDLE);
[K		< 		break;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< static int wpa_gtk_update(struct wpa_authenticator *wpa_auth,
[K		< 			  struct wpa_group *group)
[K		< {
[K		< 	int ret = 0;
[K		<
[K		< 	os_memcpy(group->GNonce, group->Counter, WPA_NONCE_LEN);
[K		< 	inc_byte_array(group->Counter, WPA_NONCE_LEN);
[K		< 	if (wpa_gmk_to_gtk(group->GMK, "Group key expansion",
[K		< 			   wpa_auth->addr, group->GNonce,
[K		< 			   group->GTK[group->GN - 1], group->GTK_len) < 0)
[K		< 		ret = -1;
[K		< 	wpa_hexdump_key(MSG_DEBUG, "GTK",
[K		< 			group->GTK[group->GN - 1], group->GTK_len);
[K		<
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (wpa_auth->conf.ieee80211w != NO_MGMT_FRAME_PROTECTION) {
[K		< 		size_t len;
[K		< 		len = wpa_cipher_key_len(wpa_auth->conf.group_mgmt_cipher);
[K		< 		os_memcpy(group->GNonce, group->Counter, WPA_NONCE_LEN);
[K		< 		inc_byte_array(group->Counter, WPA_NONCE_LEN);
[K		< 		if (wpa_gmk_to_gtk(group->GMK, "IGTK key expansion",
[K		< 				   wpa_auth->addr, group->GNonce,
[K		< 				   group->IGTK[group->GN_igtk - 4], len) < 0)
[K		< 			ret = -1;
[K		< 		wpa_hexdump_key(MSG_DEBUG, "IGTK",
[K		< 				group->IGTK[group->GN_igtk - 4], len);
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211W */
[K		<
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< static void wpa_group_gtk_init(struct wpa_authenticator *wpa_auth,
[K		< 			       struct wpa_group *group)
[K		< {
[K		< 	wpa_printf(MSG_DEBUG, "WPA: group state machine entering state "
[K		< 		   "GTK_INIT (VLAN-ID %d)", group->vlan_id);
[K		< 	group->changed = FALSE; /* GInit is not cleared here; avoid loop */
[K		< 	group->wpa_group_state = WPA_GROUP_GTK_INIT;
[K		<
[K		< 	/* GTK[0..N] = 0 */
[K		< 	os_memset(group->GTK, 0, sizeof(group->GTK));
[K		< 	group->GN = 1;
[K		< 	group->GM = 2;
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	group->GN_igtk = 4;
[K		< 	group->GM_igtk = 5;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	/* GTK[GN] = CalcGTK() */
[K		< 	wpa_gtk_update(wpa_auth, group);
[K		< }
[K		<
[K		<
[K		< static int wpa_group_update_sta(struct wpa_state_machine *sm, void *ctx)
[K		< {
[K		< 	if (ctx != NULL && ctx != sm->group)
[K		< 		return 0;
[K		<
[K		< 	if (sm->wpa_ptk_state != WPA_PTK_PTKINITDONE) {
[K		< 		wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"Not in PTKINITDONE; skip Group Key update");
[K		< 		sm->GUpdateStationKeys = FALSE;
[K		< 		return 0;
[K		< 	}
[K		< 	if (sm->GUpdateStationKeys) {
[K		< 		/*
[K		< 		 * This should not really happen, so add a debug log entry.
[K		< 		 * Since we clear the GKeyDoneStations before the loop, the
[K		< 		 * station needs to be counted here anyway.
[K		< 		 */
[K		< 		wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"GUpdateStationKeys was already set when "
[K		< 				"marking station for GTK rekeying");
[K		< 	}
[K		<
[K		< 	/* Do not rekey GTK/IGTK when STA is in WNM-Sleep Mode */
[K		< 	if (sm->is_wnmsleep)
[K		< 		return 0;
[K		<
[K		< 	sm->group->GKeyDoneStations++;
[K		< 	sm->GUpdateStationKeys = TRUE;
[K		<
[K		< 	wpa_sm_step(sm);
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_WNM
[K		< /* update GTK when exiting WNM-Sleep Mode */
[K		< void wpa_wnmsleep_rekey_gtk(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL || sm->is_wnmsleep)
[K		< 		return;
[K		<
[K		< 	wpa_group_update_sta(sm, NULL);
[K		< }
[K		<
[K		<
[K		< void wpa_set_wnmsleep(struct wpa_state_machine *sm, int flag)
[K		< {
[K		< 	if (sm)
[K		< 		sm->is_wnmsleep = !!flag;
[K		< }
[K		<
[K		<
[K		< int wpa_wnmsleep_gtk_subelem(struct wpa_state_machine *sm, u8 *pos)
[K		< {
[K		< 	struct wpa_group *gsm = sm->group;
[K		< 	u8 *start = pos;
[K		<
[K		< 	/*
[K		< 	 * GTK subelement:
[K		< 	 * Sub-elem ID[1] | Length[1] | Key Info[2] | Key Length[1] | RSC[8] |
[K		< 	 * Key[5..32]
[K		< 	 */
[K		< 	*pos++ = WNM_SLEEP_SUBELEM_GTK;
[K		< 	*pos++ = 11 + gsm->GTK_len;
[K		< 	/* Key ID in B0-B1 of Key Info */
[K		< 	WPA_PUT_LE16(pos, gsm->GN & 0x03);
[K		< 	pos += 2;
[K		< 	*pos++ = gsm->GTK_len;
[K		< 	if (wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN, pos) != 0)
[K		< 		return 0;
[K		< 	pos += 8;
[K		< 	os_memcpy(pos, gsm->GTK[gsm->GN - 1], gsm->GTK_len);
[K		< 	pos += gsm->GTK_len;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WNM: GTK Key ID %u in WNM-Sleep Mode exit",
[K		< 		   gsm->GN);
[K		< 	wpa_hexdump_key(MSG_DEBUG, "WNM: GTK in WNM-Sleep Mode exit",
[K		< 			gsm->GTK[gsm->GN - 1], gsm->GTK_len);
[K		<
[K		< 	return pos - start;
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_IEEE80211W
[K		< int wpa_wnmsleep_igtk_subelem(struct wpa_state_machine *sm, u8 *pos)
[K		< {
[K		< 	struct wpa_group *gsm = sm->group;
[K		< 	u8 *start = pos;
[K		< 	size_t len = wpa_cipher_key_len(sm->wpa_auth->conf.group_mgmt_cipher);
[K		<
[K		< 	/*
[K		< 	 * IGTK subelement:
[K		< 	 * Sub-elem ID[1] | Length[1] | KeyID[2] | PN[6] | Key[16]
[K		< 	 */
[K		< 	*pos++ = WNM_SLEEP_SUBELEM_IGTK;
[K		< 	*pos++ = 2 + 6 + len;
[K		< 	WPA_PUT_LE16(pos, gsm->GN_igtk);
[K		< 	pos += 2;
[K		< 	if (wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN_igtk, pos) != 0)
[K		< 		return 0;
[K		< 	pos += 6;
[K		<
[K		< 	os_memcpy(pos, gsm->IGTK[gsm->GN_igtk - 4], len);
[K		< 	pos += len;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WNM: IGTK Key ID %u in WNM-Sleep Mode exit",
[K		< 		   gsm->GN_igtk);
[K		< 	wpa_hexdump_key(MSG_DEBUG, "WNM: IGTK in WNM-Sleep Mode exit",
[K		< 			gsm->IGTK[gsm->GN_igtk - 4], len);
[K		<
[K		< 	return pos - start;
[K		< }
[K		< #endif /* CONFIG_IEEE80211W */
[K		< #endif /* CONFIG_WNM */
[K		<
[K		<
[K		< static void wpa_group_setkeys(struct wpa_authenticator *wpa_auth,
[K		< 			      struct wpa_group *group)
[K		< {
[K		< 	int tmp;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WPA: group state machine entering state "
[K		< 		   "SETKEYS (VLAN-ID %d)", group->vlan_id);
[K		< 	group->changed = TRUE;
[K		< 	group->wpa_group_state = WPA_GROUP_SETKEYS;
[K		< 	group->GTKReKey = FALSE;
[K		< 	tmp = group->GM;
[K		< 	group->GM = group->GN;
[K		< 	group->GN = tmp;
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	tmp = group->GM_igtk;
[K		< 	group->GM_igtk = group->GN_igtk;
[K		< 	group->GN_igtk = tmp;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	/* "GKeyDoneStations = GNoStations" is done in more robust way by
[K		< 	 * counting the STAs that are marked with GUpdateStationKeys instead of
[K		< 	 * including all STAs that could be in not-yet-completed state. */
[K		< 	wpa_gtk_update(wpa_auth, group);
[K		<
[K		< 	if (group->GKeyDoneStations) {
[K		< 		wpa_printf(MSG_DEBUG, "wpa_group_setkeys: Unexpected "
[K		< 			   "GKeyDoneStations=%d when starting new GTK rekey",
[K		< 			   group->GKeyDoneStations);
[K		< 		group->GKeyDoneStations = 0;
[K		< 	}
[K		< 	wpa_auth_for_each_sta(wpa_auth, wpa_group_update_sta, group);
[K		< 	wpa_printf(MSG_DEBUG, "wpa_group_setkeys: GKeyDoneStations=%d",
[K		< 		   group->GKeyDoneStations);
[K		< }
[K		<
[K		<
[K		< static int wpa_group_config_group_keys(struct wpa_authenticator *wpa_auth,
[K		< 				       struct wpa_group *group)
[K		< {
[K		< 	int ret = 0;
[K		<
[K		< 	if (wpa_auth_set_key(wpa_auth, group->vlan_id,
[K		< 			     wpa_cipher_to_alg(wpa_auth->conf.wpa_group),
[K		< 			     broadcast_ether_addr, group->GN,
[K		< 			     group->GTK[group->GN - 1], group->GTK_len) < 0)
[K		< 		ret = -1;
[K		<
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (wpa_auth->conf.ieee80211w != NO_MGMT_FRAME_PROTECTION) {
[K		< 		enum wpa_alg alg;
[K		< 		size_t len;
[K		<
[K		< 		alg = wpa_cipher_to_alg(wpa_auth->conf.group_mgmt_cipher);
[K		< 		len = wpa_cipher_key_len(wpa_auth->conf.group_mgmt_cipher);
[K		<
[K		< 		if (ret == 0 &&
[K		< 		    wpa_auth_set_key(wpa_auth, group->vlan_id, alg,
[K		< 				     broadcast_ether_addr, group->GN_igtk,
[K		< 				     group->IGTK[group->GN_igtk - 4], len) < 0)
[K		< 			ret = -1;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211W */
[K		<
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< static int wpa_group_disconnect_cb(struct wpa_state_machine *sm, void *ctx)
[K		< {
[K		< 	if (sm->group == ctx) {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Mark STA " MACSTR
[K		< 			   " for discconnection due to fatal failure",
[K		< 			   MAC2STR(sm->addr));
[K		< 		sm->Disconnect = TRUE;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_group_fatal_failure(struct wpa_authenticator *wpa_auth,
[K		< 				    struct wpa_group *group)
[K		< {
[K		< 	wpa_printf(MSG_DEBUG, "WPA: group state machine entering state FATAL_FAILURE");
[K		< 	group->changed = TRUE;
[K		< 	group->wpa_group_state = WPA_GROUP_FATAL_FAILURE;
[K		< 	wpa_auth_for_each_sta(wpa_auth, wpa_group_disconnect_cb, group);
[K		< }
[K		<
[K		<
[K		< static int wpa_group_setkeysdone(struct wpa_authenticator *wpa_auth,
[K		< 				 struct wpa_group *group)
[K		< {
[K		< 	wpa_printf(MSG_DEBUG, "WPA: group state machine entering state "
[K		< 		   "SETKEYSDONE (VLAN-ID %d)", group->vlan_id);
[K		< 	group->changed = TRUE;
[K		< 	group->wpa_group_state = WPA_GROUP_SETKEYSDONE;
[K		<
[K		< 	if (wpa_group_config_group_keys(wpa_auth, group) < 0) {
[K		< 		wpa_group_fatal_failure(wpa_auth, group);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_group_sm_step(struct wpa_authenticator *wpa_auth,
[K		< 			      struct wpa_group *group)
[K		< {
[K		< 	if (group->GInit) {
[K		< 		wpa_group_gtk_init(wpa_auth, group);
[K		< 	} else if (group->wpa_group_state == WPA_GROUP_FATAL_FAILURE) {
[K		< 		/* Do not allow group operations */
[K		< 	} else if (group->wpa_group_state == WPA_GROUP_GTK_INIT &&
[K		< 		   group->GTKAuthenticator) {
[K		< 		wpa_group_setkeysdone(wpa_auth, group);
[K		< 	} else if (group->wpa_group_state == WPA_GROUP_SETKEYSDONE &&
[K		< 		   group->GTKReKey) {
[K		< 		wpa_group_setkeys(wpa_auth, group);
[K		< 	} else if (group->wpa_group_state == WPA_GROUP_SETKEYS) {
[K		< 		if (group->GKeyDoneStations == 0)
[K		< 			wpa_group_setkeysdone(wpa_auth, group);
[K		< 		else if (group->GTKReKey)
[K		< 			wpa_group_setkeys(wpa_auth, group);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< static int wpa_sm_step(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return 0;
[K		<
[K		< 	if (sm->in_step_loop) {
[K		< 		/* This should not happen, but if it does, make sure we do not
[K		< 		 * end up freeing the state machine too early by exiting the
[K		< 		 * recursive call. */
[K		< 		wpa_printf(MSG_ERROR, "WPA: wpa_sm_step() called recursively");
[K		< 		return 0;
[K		< 	}
[K		<
[K		< 	sm->in_step_loop = 1;
[K		< 	do {
[K		< 		if (sm->pending_deinit)
[K		< 			break;
[K		<
[K		< 		sm->changed = FALSE;
[K		< 		sm->wpa_auth->group->changed = FALSE;
[K		<
[K		< 		SM_STEP_RUN(WPA_PTK);
[K		< 		if (sm->pending_deinit)
[K		< 			break;
[K		< 		SM_STEP_RUN(WPA_PTK_GROUP);
[K		< 		if (sm->pending_deinit)
[K		< 			break;
[K		< 		wpa_group_sm_step(sm->wpa_auth, sm->group);
[K		< 	} while (sm->changed || sm->wpa_auth->group->changed);
[K		< 	sm->in_step_loop = 0;
[K		<
[K		< 	if (sm->pending_deinit) {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Completing pending STA state "
[K		< 			   "machine deinit for " MACSTR, MAC2STR(sm->addr));
[K		< 		wpa_free_sta_sm(sm);
[K		< 		return 1;
[K		< 	}
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_sm_call_step(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_state_machine *sm = eloop_ctx;
[K		< 	wpa_sm_step(sm);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_sm_notify(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		< 	eloop_register_timeout(0, 0, wpa_sm_call_step, sm, NULL);
[K		< }
[K		<
[K		<
[K		< void wpa_gtk_rekey(struct wpa_authenticator *wpa_auth)
[K		< {
[K		< 	int tmp, i;
[K		< 	struct wpa_group *group;
[K		<
[K		< 	if (wpa_auth == NULL)
[K		< 		return;
[K		<
[K		< 	group = wpa_auth->group;
[K		<
[K		< 	for (i = 0; i < 2; i++) {
[K		< 		tmp = group->GM;
[K		< 		group->GM = group->GN;
[K		< 		group->GN = tmp;
[K		< #ifdef CONFIG_IEEE80211W
[K		< 		tmp = group->GM_igtk;
[K		< 		group->GM_igtk = group->GN_igtk;
[K		< 		group->GN_igtk = tmp;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 		wpa_gtk_update(wpa_auth, group);
[K		< 		wpa_group_config_group_keys(wpa_auth, group);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< static const char * wpa_bool_txt(int val)
[K		< {
[K		< 	return val ? "TRUE" : "FALSE";
[K		< }
[K		<
[K		<
[K		< #define RSN_SUITE "%02x-%02x-%02x-%d"
[K		< #define RSN_SUITE_ARG(s) \
[K		< ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
[K		<
[K		< int wpa_get_mib(struct wpa_authenticator *wpa_auth, char *buf, size_t buflen)
[K		< {
[K		< 	int len = 0, ret;
[K		< 	char pmkid_txt[PMKID_LEN * 2 + 1];
[K		< #ifdef CONFIG_RSN_PREAUTH
[K		< 	const int preauth = 1;
[K		< #else /* CONFIG_RSN_PREAUTH */
[K		< 	const int preauth = 0;
[K		< #endif /* CONFIG_RSN_PREAUTH */
[K		<
[K		< 	if (wpa_auth == NULL)
[K		< 		return len;
[K		<
[K		< 	ret = os_snprintf(buf + len, buflen - len,
[K		< 			  "dot11RSNAOptionImplemented=TRUE\n"
[K		< 			  "dot11RSNAPreauthenticationImplemented=%s\n"
[K		< 			  "dot11RSNAEnabled=%s\n"
[K		< 			  "dot11RSNAPreauthenticationEnabled=%s\n",
[K		< 			  wpa_bool_txt(preauth),
[K		< 			  wpa_bool_txt(wpa_auth->conf.wpa & WPA_PROTO_RSN),
[K		< 			  wpa_bool_txt(wpa_auth->conf.rsn_preauth));
[K		< 	if (os_snprintf_error(buflen - len, ret))
[K		< 		return len;
[K		< 	len += ret;
[K		<
[K		< 	wpa_snprintf_hex(pmkid_txt, sizeof(pmkid_txt),
[K		< 			 wpa_auth->dot11RSNAPMKIDUsed, PMKID_LEN);
[K		<
[K		< 	ret = os_snprintf(
[K		< 		buf + len, buflen - len,
[K		< 		"dot11RSNAConfigVersion=%u\n"
[K		< 		"dot11RSNAConfigPairwiseKeysSupported=9999\n"
[K		< 		/* FIX: dot11RSNAConfigGroupCipher */
[K		< 		/* FIX: dot11RSNAConfigGroupRekeyMethod */
[K		< 		/* FIX: dot11RSNAConfigGroupRekeyTime */
[K		< 		/* FIX: dot11RSNAConfigGroupRekeyPackets */
[K		< 		"dot11RSNAConfigGroupRekeyStrict=%u\n"
[K		< 		"dot11RSNAConfigGroupUpdateCount=%u\n"
[K		< 		"dot11RSNAConfigPairwiseUpdateCount=%u\n"
[K		< 		"dot11RSNAConfigGroupCipherSize=%u\n"
[K		< 		"dot11RSNAConfigPMKLifetime=%u\n"
[K		< 		"dot11RSNAConfigPMKReauthThreshold=%u\n"
[K		< 		"dot11RSNAConfigNumberOfPTKSAReplayCounters=0\n"
[K		< 		"dot11RSNAConfigSATimeout=%u\n"
[K		< 		"dot11RSNAAuthenticationSuiteSelected=" RSN_SUITE "\n"
[K		< 		"dot11RSNAPairwiseCipherSelected=" RSN_SUITE "\n"
[K		< 		"dot11RSNAGroupCipherSelected=" RSN_SUITE "\n"
[K		< 		"dot11RSNAPMKIDUsed=%s\n"
[K		< 		"dot11RSNAAuthenticationSuiteRequested=" RSN_SUITE "\n"
[K		< 		"dot11RSNAPairwiseCipherRequested=" RSN_SUITE "\n"
[K		< 		"dot11RSNAGroupCipherRequested=" RSN_SUITE "\n"
[K		< 		"dot11RSNATKIPCounterMeasuresInvoked=%u\n"
[K		< 		"dot11RSNA4WayHandshakeFailures=%u\n"
[K		< 		"dot11RSNAConfigNumberOfGTKSAReplayCounters=0\n",
[K		< 		RSN_VERSION,
[K		< 		!!wpa_auth->conf.wpa_strict_rekey,
[K		< 		wpa_auth->conf.wpa_group_update_count,
[K		< 		wpa_auth->conf.wpa_pairwise_update_count,
[K		< 		wpa_cipher_key_len(wpa_auth->conf.wpa_group) * 8,
[K		< 		dot11RSNAConfigPMKLifetime,
[K		< 		dot11RSNAConfigPMKReauthThreshold,
[K		< 		dot11RSNAConfigSATimeout,
[K		< 		RSN_SUITE_ARG(wpa_auth->dot11RSNAAuthenticationSuiteSelected),
[K		< 		RSN_SUITE_ARG(wpa_auth->dot11RSNAPairwiseCipherSelected),
[K		< 		RSN_SUITE_ARG(wpa_auth->dot11RSNAGroupCipherSelected),
[K		< 		pmkid_txt,
[K		< 		RSN_SUITE_ARG(wpa_auth->dot11RSNAAuthenticationSuiteRequested),
[K		< 		RSN_SUITE_ARG(wpa_auth->dot11RSNAPairwiseCipherRequested),
[K		< 		RSN_SUITE_ARG(wpa_auth->dot11RSNAGroupCipherRequested),
[K		< 		wpa_auth->dot11RSNATKIPCounterMeasuresInvoked,
[K		< 		wpa_auth->dot11RSNA4WayHandshakeFailures);
[K		< 	if (os_snprintf_error(buflen - len, ret))
[K		< 		return len;
[K		< 	len += ret;
[K		<
[K		< 	/* TODO: dot11RSNAConfigPairwiseCiphersTable */
[K		< 	/* TODO: dot11RSNAConfigAuthenticationSuitesTable */
[K		<
[K		< 	/* Private MIB */
[K		< 	ret = os_snprintf(buf + len, buflen - len, "hostapdWPAGroupState=%d\n",
[K		< 			  wpa_auth->group->wpa_group_state);
[K		< 	if (os_snprintf_error(buflen - len, ret))
[K		< 		return len;
[K		< 	len += ret;
[K		<
[K		< 	return len;
[K		< }
[K		<
[K		<
[K		< int wpa_get_mib_sta(struct wpa_state_machine *sm, char *buf, size_t buflen)
[K		< {
[K		< 	int len = 0, ret;
[K		< 	u32 pairwise = 0;
[K		<
[K		< 	if (sm == NULL)
[K		< 		return 0;
[K		<
[K		< 	/* TODO: FF-FF-FF-FF-FF-FF entry for broadcast/multicast stats */
[K		<
[K		< 	/* dot11RSNAStatsEntry */
[K		<
[K		< 	pairwise = wpa_cipher_to_suite(sm->wpa == WPA_VERSION_WPA2 ?
[K		< 				       WPA_PROTO_RSN : WPA_PROTO_WPA,
[K		< 				       sm->pairwise);
[K		< 	if (pairwise == 0)
[K		< 		return 0;
[K		<
[K		< 	ret = os_snprintf(
[K		< 		buf + len, buflen - len,
[K		< 		/* TODO: dot11RSNAStatsIndex */
[K		< 		"dot11RSNAStatsSTAAddress=" MACSTR "\n"
[K		< 		"dot11RSNAStatsVersion=1\n"
[K		< 		"dot11RSNAStatsSelectedPairwiseCipher=" RSN_SUITE "\n"
[K		< 		/* TODO: dot11RSNAStatsTKIPICVErrors */
[K		< 		"dot11RSNAStatsTKIPLocalMICFailures=%u\n"
[K		< 		"dot11RSNAStatsTKIPRemoteMICFailures=%u\n"
[K		< 		/* TODO: dot11RSNAStatsCCMPReplays */
[K		< 		/* TODO: dot11RSNAStatsCCMPDecryptErrors */
[K		< 		/* TODO: dot11RSNAStatsTKIPReplays */,
[K		< 		MAC2STR(sm->addr),
[K		< 		RSN_SUITE_ARG(pairwise),
[K		< 		sm->dot11RSNAStatsTKIPLocalMICFailures,
[K		< 		sm->dot11RSNAStatsTKIPRemoteMICFailures);
[K		< 	if (os_snprintf_error(buflen - len, ret))
[K		< 		return len;
[K		< 	len += ret;
[K		<
[K		< 	/* Private MIB */
[K		< 	ret = os_snprintf(buf + len, buflen - len,
[K		< 			  "hostapdWPAPTKState=%d\n"
[K		< 			  "hostapdWPAPTKGroupState=%d\n",
[K		< 			  sm->wpa_ptk_state,
[K		< 			  sm->wpa_ptk_group_state);
[K		< 	if (os_snprintf_error(buflen - len, ret))
[K		< 		return len;
[K		< 	len += ret;
[K		<
[K		< 	return len;
[K		< }
[K		<
[K		<
[K		< void wpa_auth_countermeasures_start(struct wpa_authenticator *wpa_auth)
[K		< {
[K		< 	if (wpa_auth)
[K		< 		wpa_auth->dot11RSNATKIPCounterMeasuresInvoked++;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_pairwise_set(struct wpa_state_machine *sm)
[K		< {
[K		< 	return sm && sm->pairwise_set;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_get_pairwise(struct wpa_state_machine *sm)
[K		< {
[K		< 	return sm->pairwise;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_sta_key_mgmt(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		< 	return sm->wpa_key_mgmt;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_sta_wpa_version(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return 0;
[K		< 	return sm->wpa;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_sta_clear_pmksa(struct wpa_state_machine *sm,
[K		< 			     struct rsn_pmksa_cache_entry *entry)
[K		< {
[K		< 	if (sm == NULL || sm->pmksa != entry)
[K		< 		return -1;
[K		< 	sm->pmksa = NULL;
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< struct rsn_pmksa_cache_entry *
[K		< wpa_auth_sta_get_pmksa(struct wpa_state_machine *sm)
[K		< {
[K		< 	return sm ? sm->pmksa : NULL;
[K		< }
[K		<
[K		<
[K		< void wpa_auth_sta_local_mic_failure_report(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm)
[K		< 		sm->dot11RSNAStatsTKIPLocalMICFailures++;
[K		< }
[K		<
[K		<
[K		< const u8 * wpa_auth_get_wpa_ie(struct wpa_authenticator *wpa_auth, size_t *len)
[K		< {
[K		< 	if (wpa_auth == NULL)
[K		< 		return NULL;
[K		< 	*len = wpa_auth->wpa_ie_len;
[K		< 	return wpa_auth->wpa_ie;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_pmksa_add(struct wpa_state_machine *sm, const u8 *pmk,
[K		< 		       unsigned int pmk_len,
[K		< 		       int session_timeout, struct eapol_state_machine *eapol)
[K		< {
[K		< 	if (sm == NULL || sm->wpa != WPA_VERSION_WPA2 ||
[K		< 	    sm->wpa_auth->conf.disable_pmksa_caching)
[K		< 		return -1;
[K		<
[K		< 	if (wpa_key_mgmt_sha384(sm->wpa_key_mgmt)) {
[K		< 		if (pmk_len > PMK_LEN_SUITE_B_192)
[K		< 			pmk_len = PMK_LEN_SUITE_B_192;
[K		< 	} else if (pmk_len > PMK_LEN) {
[K		< 		pmk_len = PMK_LEN;
[K		< 	}
[K		<
[K		< 	if (pmksa_cache_auth_add(sm->wpa_auth->pmksa, pmk, pmk_len, NULL,
[K		< 				 sm->PTK.kck, sm->PTK.kck_len,
[K		< 				 sm->wpa_auth->addr, sm->addr, session_timeout,
[K		< 				 eapol, sm->wpa_key_mgmt))
[K		< 		return 0;
[K		<
[K		< 	return -1;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_pmksa_add_preauth(struct wpa_authenticator *wpa_auth,
[K		< 			       const u8 *pmk, size_t len, const u8 *sta_addr,
[K		< 			       int session_timeout,
[K		< 			       struct eapol_state_machine *eapol)
[K		< {
[K		< 	if (wpa_auth == NULL)
[K		< 		return -1;
[K		<
[K		< 	if (pmksa_cache_auth_add(wpa_auth->pmksa, pmk, len, NULL,
[K		< 				 NULL, 0,
[K		< 				 wpa_auth->addr,
[K		< 				 sta_addr, session_timeout, eapol,
[K		< 				 WPA_KEY_MGMT_IEEE8021X))
[K		< 		return 0;
[K		<
[K		< 	return -1;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_pmksa_add_sae(struct wpa_authenticator *wpa_auth, const u8 *addr,
[K		< 			   const u8 *pmk, const u8 *pmkid)
[K		< {
[K		< 	if (wpa_auth->conf.disable_pmksa_caching)
[K		< 		return -1;
[K		<
[K		< 	if (pmksa_cache_auth_add(wpa_auth->pmksa, pmk, PMK_LEN, pmkid,
[K		< 				 NULL, 0,
[K		< 				 wpa_auth->addr, addr, 0, NULL,
[K		< 				 WPA_KEY_MGMT_SAE))
[K		< 		return 0;
[K		<
[K		< 	return -1;
[K		< }
[K		<
[K		<
[K		< void wpa_auth_pmksa_remove(struct wpa_authenticator *wpa_auth,
[K		< 			   const u8 *sta_addr)
[K		< {
[K		< 	struct rsn_pmksa_cache_entry *pmksa;
[K		<
[K		< 	if (wpa_auth == NULL || wpa_auth->pmksa == NULL)
[K		< 		return;
[K		< 	pmksa = pmksa_cache_auth_get(wpa_auth->pmksa, sta_addr, NULL);
[K		< 	if (pmksa) {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Remove PMKSA cache entry for "
[K		< 			   MACSTR " based on request", MAC2STR(sta_addr));
[K		< 		pmksa_cache_free_entry(wpa_auth->pmksa, pmksa);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< int wpa_auth_pmksa_list(struct wpa_authenticator *wpa_auth, char *buf,
[K		< 			size_t len)
[K		< {
[K		< 	if (!wpa_auth || !wpa_auth->pmksa)
[K		< 		return 0;
[K		< 	return pmksa_cache_auth_list(wpa_auth->pmksa, buf, len);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_pmksa_flush(struct wpa_authenticator *wpa_auth)
[K		< {
[K		< 	if (wpa_auth && wpa_auth->pmksa)
[K		< 		pmksa_cache_auth_flush(wpa_auth->pmksa);
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_PMKSA_CACHE_EXTERNAL
[K		< #ifdef CONFIG_MESH
[K		<
[K		< int wpa_auth_pmksa_list_mesh(struct wpa_authenticator *wpa_auth, const u8 *addr,
[K		< 			     char *buf, size_t len)
[K		< {
[K		< 	if (!wpa_auth || !wpa_auth->pmksa)
[K		< 		return 0;
[K		<
[K		< 	return pmksa_cache_auth_list_mesh(wpa_auth->pmksa, addr, buf, len);
[K		< }
[K		<
[K		<
[K		< struct rsn_pmksa_cache_entry *
[K		< wpa_auth_pmksa_create_entry(const u8 *aa, const u8 *spa, const u8 *pmk,
[K		< 			    const u8 *pmkid, int expiration)
[K		< {
[K		< 	struct rsn_pmksa_cache_entry *entry;
[K		< 	struct os_reltime now;
[K		<
[K		< 	entry = pmksa_cache_auth_create_entry(pmk, PMK_LEN, pmkid, NULL, 0, aa,
[K		< 					      spa, 0, NULL, WPA_KEY_MGMT_SAE);
[K		< 	if (!entry)
[K		< 		return NULL;
[K		<
[K		< 	os_get_reltime(&now);
[K		< 	entry->expiration = now.sec + expiration;
[K		< 	return entry;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_pmksa_add_entry(struct wpa_authenticator *wpa_auth,
[K		< 			     struct rsn_pmksa_cache_entry *entry)
[K		< {
[K		< 	int ret;
[K		<
[K		< 	if (!wpa_auth || !wpa_auth->pmksa)
[K		< 		return -1;
[K		<
[K		< 	ret = pmksa_cache_auth_add_entry(wpa_auth->pmksa, entry);
[K		< 	if (ret < 0)
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "RSN: Failed to store external PMKSA cache for "
[K		< 			   MACSTR, MAC2STR(entry->spa));
[K		<
[K		< 	return ret;
[K		< }
[K		<
[K		< #endif /* CONFIG_MESH */
[K		< #endif /* CONFIG_PMKSA_CACHE_EXTERNAL */
[K		<
[K		<
[K		< struct rsn_pmksa_cache_entry *
[K		< wpa_auth_pmksa_get(struct wpa_authenticator *wpa_auth, const u8 *sta_addr,
[K		< 		   const u8 *pmkid)
[K		< {
[K		< 	if (!wpa_auth || !wpa_auth->pmksa)
[K		< 		return NULL;
[K		< 	return pmksa_cache_auth_get(wpa_auth->pmksa, sta_addr, pmkid);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_pmksa_set_to_sm(struct rsn_pmksa_cache_entry *pmksa,
[K		< 			      struct wpa_state_machine *sm,
[K		< 			      struct wpa_authenticator *wpa_auth,
[K		< 			      u8 *pmkid, u8 *pmk)
[K		< {
[K		< 	if (!sm)
[K		< 		return;
[K		<
[K		< 	sm->pmksa = pmksa;
[K		< 	os_memcpy(pmk, pmksa->pmk, PMK_LEN);
[K		< 	os_memcpy(pmkid, pmksa->pmkid, PMKID_LEN);
[K		< 	os_memcpy(wpa_auth->dot11RSNAPMKIDUsed, pmksa->pmkid, PMKID_LEN);
[K		< }
[K		<
[K		<
[K		< /*
[K		<  * Remove and free the group from wpa_authenticator. This is triggered by a
[K		<  * callback to make sure nobody is currently iterating the group list while it
[K		<  * gets modified.
[K		<  */
[K		< static void wpa_group_free(struct wpa_authenticator *wpa_auth,
[K		< 			   struct wpa_group *group)
[K		< {
[K		< 	struct wpa_group *prev = wpa_auth->group;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Remove group state machine for VLAN-ID %d",
[K		< 		   group->vlan_id);
[K		<
[K		< 	while (prev) {
[K		< 		if (prev->next == group) {
[K		< 			/* This never frees the special first group as needed */
[K		< 			prev->next = group->next;
[K		< 			os_free(group);
[K		< 			break;
[K		< 		}
[K		< 		prev = prev->next;
[K		< 	}
[K		<
[K		< }
[K		<
[K		<
[K		< /* Increase the reference counter for group */
[K		< static void wpa_group_get(struct wpa_authenticator *wpa_auth,
[K		< 			  struct wpa_group *group)
[K		< {
[K		< 	/* Skip the special first group */
[K		< 	if (wpa_auth->group == group)
[K		< 		return;
[K		<
[K		< 	group->references++;
[K		< }
[K		<
[K		<
[K		< /* Decrease the reference counter and maybe free the group */
[K		< static void wpa_group_put(struct wpa_authenticator *wpa_auth,
[K		< 			  struct wpa_group *group)
[K		< {
[K		< 	/* Skip the special first group */
[K		< 	if (wpa_auth->group == group)
[K		< 		return;
[K		<
[K		< 	group->references--;
[K		< 	if (group->references)
[K		< 		return;
[K		< 	wpa_group_free(wpa_auth, group);
[K		< }
[K		<
[K		<
[K		< /*
[K		<  * Add a group that has its references counter set to zero. Caller needs to
[K		<  * call wpa_group_get() on the return value to mark the entry in use.
[K		<  */
[K		< static struct wpa_group *
[K		< wpa_auth_add_group(struct wpa_authenticator *wpa_auth, int vlan_id)
[K		< {
[K		< 	struct wpa_group *group;
[K		<
[K		< 	if (wpa_auth == NULL || wpa_auth->group == NULL)
[K		< 		return NULL;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Add group state machine for VLAN-ID %d",
[K		< 		   vlan_id);
[K		< 	group = wpa_group_init(wpa_auth, vlan_id, 0);
[K		< 	if (group == NULL)
[K		< 		return NULL;
[K		<
[K		< 	group->next = wpa_auth->group->next;
[K		< 	wpa_auth->group->next = group;
[K		<
[K		< 	return group;
[K		< }
[K		<
[K		<
[K		< /*
[K		<  * Enforce that the group state machine for the VLAN is running, increase
[K		<  * reference counter as interface is up. References might have been increased
[K		<  * even if a negative value is returned.
[K		<  * Returns: -1 on error (group missing, group already failed); otherwise, 0
[K		<  */
[K		< int wpa_auth_ensure_group(struct wpa_authenticator *wpa_auth, int vlan_id)
[K		< {
[K		< 	struct wpa_group *group;
[K		<
[K		< 	if (wpa_auth == NULL)
[K		< 		return 0;
[K		<
[K		< 	group = wpa_auth->group;
[K		< 	while (group) {
[K		< 		if (group->vlan_id == vlan_id)
[K		< 			break;
[K		< 		group = group->next;
[K		< 	}
[K		<
[K		< 	if (group == NULL) {
[K		< 		group = wpa_auth_add_group(wpa_auth, vlan_id);
[K		< 		if (group == NULL)
[K		< 			return -1;
[K		< 	}
[K		<
[K		< 	wpa_printf(MSG_DEBUG,
[K		< 		   "WPA: Ensure group state machine running for VLAN ID %d",
[K		< 		   vlan_id);
[K		<
[K		< 	wpa_group_get(wpa_auth, group);
[K		< 	group->num_setup_iface++;
[K		<
[K		< 	if (group->wpa_group_state == WPA_GROUP_FATAL_FAILURE)
[K		< 		return -1;
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /*
[K		<  * Decrease reference counter, expected to be zero afterwards.
[K		<  * returns: -1 on error (group not found, group in fail state)
[K		<  *          -2 if wpa_group is still referenced
[K		<  *           0 else
[K		<  */
[K		< int wpa_auth_release_group(struct wpa_authenticator *wpa_auth, int vlan_id)
[K		< {
[K		< 	struct wpa_group *group;
[K		< 	int ret = 0;
[K		<
[K		< 	if (wpa_auth == NULL)
[K		< 		return 0;
[K		<
[K		< 	group = wpa_auth->group;
[K		< 	while (group) {
[K		< 		if (group->vlan_id == vlan_id)
[K		< 			break;
[K		< 		group = group->next;
[K		< 	}
[K		<
[K		< 	if (group == NULL)
[K		< 		return -1;
[K		<
[K		< 	wpa_printf(MSG_DEBUG,
[K		< 		   "WPA: Try stopping group state machine for VLAN ID %d",
[K		< 		   vlan_id);
[K		<
[K		< 	if (group->num_setup_iface <= 0) {
[K		< 		wpa_printf(MSG_ERROR,
[K		< 			   "WPA: wpa_auth_release_group called more often than wpa_auth_ensure_group for VLAN ID %d, skipping.",
[K		< 			   vlan_id);
[K		< 		return -1;
[K		< 	}
[K		< 	group->num_setup_iface--;
[K		<
[K		< 	if (group->wpa_group_state == WPA_GROUP_FATAL_FAILURE)
[K		< 		ret = -1;
[K		<
[K		< 	if (group->references > 1) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "WPA: Cannot stop group state machine for VLAN ID %d as references are still hold",
[K		< 			   vlan_id);
[K		< 		ret = -2;
[K		< 	}
[K		<
[K		< 	wpa_group_put(wpa_auth, group);
[K		<
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_sta_set_vlan(struct wpa_state_machine *sm, int vlan_id)
[K		< {
[K		< 	struct wpa_group *group;
[K		<
[K		< 	if (sm == NULL || sm->wpa_auth == NULL)
[K		< 		return 0;
[K		<
[K		< 	group = sm->wpa_auth->group;
[K		< 	while (group) {
[K		< 		if (group->vlan_id == vlan_id)
[K		< 			break;
[K		< 		group = group->next;
[K		< 	}
[K		<
[K		< 	if (group == NULL) {
[K		< 		group = wpa_auth_add_group(sm->wpa_auth, vlan_id);
[K		< 		if (group == NULL)
[K		< 			return -1;
[K		< 	}
[K		<
[K		< 	if (sm->group == group)
[K		< 		return 0;
[K		<
[K		< 	if (group->wpa_group_state == WPA_GROUP_FATAL_FAILURE)
[K		< 		return -1;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Moving STA " MACSTR " to use group state "
[K		< 		   "machine for VLAN ID %d", MAC2STR(sm->addr), vlan_id);
[K		<
[K		< 	wpa_group_get(sm->wpa_auth, group);
[K		< 	wpa_group_put(sm->wpa_auth, sm->group);
[K		< 	sm->group = group;
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< void wpa_auth_eapol_key_tx_status(struct wpa_authenticator *wpa_auth,
[K		< 				  struct wpa_state_machine *sm, int ack)
[K		< {
[K		< 	if (wpa_auth == NULL || sm == NULL)
[K		< 		return;
[K		< 	wpa_printf(MSG_DEBUG, "WPA: EAPOL-Key TX status for STA " MACSTR
[K		< 		   " ack=%d", MAC2STR(sm->addr), ack);
[K		< 	if (sm->pending_1_of_4_timeout && ack) {
[K		< 		/*
[K		< 		 * Some deployed supplicant implementations update their SNonce
[K		< 		 * for each EAPOL-Key 2/4 message even within the same 4-way
[K		< 		 * handshake and then fail to use the first SNonce when
[K		< 		 * deriving the PTK. This results in unsuccessful 4-way
[K		< 		 * handshake whenever the relatively short initial timeout is
[K		< 		 * reached and EAPOL-Key 1/4 is retransmitted. Try to work
[K		< 		 * around this by increasing the timeout now that we know that
[K		< 		 * the station has received the frame.
[K		< 		 */
[K		< 		int timeout_ms = eapol_key_timeout_subseq;
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Increase initial EAPOL-Key 1/4 "
[K		< 			   "timeout by %u ms because of acknowledged frame",
[K		< 			   timeout_ms);
[K		< 		eloop_cancel_timeout(wpa_send_eapol_timeout, wpa_auth, sm);
[K		< 		eloop_register_timeout(timeout_ms / 1000,
[K		< 				       (timeout_ms % 1000) * 1000,
[K		< 				       wpa_send_eapol_timeout, wpa_auth, sm);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< int wpa_auth_uses_sae(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return 0;
[K		< 	return wpa_key_mgmt_sae(sm->wpa_key_mgmt);
[K		< }
[K		<
[K		<
[K		< int wpa_auth_uses_ft_sae(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return 0;
[K		< 	return sm->wpa_key_mgmt == WPA_KEY_MGMT_FT_SAE;
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_P2P
[K		< int wpa_auth_get_ip_addr(struct wpa_state_machine *sm, u8 *addr)
[K		< {
[K		< 	if (sm == NULL || WPA_GET_BE32(sm->ip_addr) == 0)
[K		< 		return -1;
[K		< 	os_memcpy(addr, sm->ip_addr, 4);
[K		< 	return 0;
[K		< }
[K		< #endif /* CONFIG_P2P */
[K		<
[K		<
[K		< int wpa_auth_radius_das_disconnect_pmksa(struct wpa_authenticator *wpa_auth,
[K		< 					 struct radius_das_attrs *attr)
[K		< {
[K		< 	return pmksa_cache_auth_radius_das_disconnect(wpa_auth->pmksa, attr);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_reconfig_group_keys(struct wpa_authenticator *wpa_auth)
[K		< {
[K		< 	struct wpa_group *group;
[K		<
[K		< 	if (!wpa_auth)
[K		< 		return;
[K		< 	for (group = wpa_auth->group; group; group = group->next)
[K		< 		wpa_group_config_group_keys(wpa_auth, group);
[K		< }
[K
	Successful transformation
[K
		/hostap/CVE-2017-13077_Android/Android/src/rsn_supp/wpa.c
		------------------------------------------------------------------------------------------

[K	Original AST script
[K			AST Script:
[K				 Insert EnumConstantDecl(12976) EnumDecl(12966) 9
[K				 Insert FunctionDecl(13067) TranslationUnitDecl(0) 811
[K				 Insert TypeLoc(13068) FunctionDecl(13067) 0
[K				 Insert TypeLoc(13069) TypeLoc(13068) 0
[K				 Insert ParmVarDecl(13070) TypeLoc(13068) 1
[K				 Insert TypeLoc(13071) ParmVarDecl(13070) 0
[K				 Insert TypeLoc(13072) TypeLoc(13071) 0
[K				 Insert TypeLoc(13073) TypeLoc(13072) 0
[K				 Insert FieldDecl(14894) RecordDecl(14793) 31
[K				 Insert TypeLoc(14895) FieldDecl(14894) 0
[K				 Insert CaseStmt(20081) CompoundStmt(19989) 12
[K				 Insert DeclRefExpr(20082) CaseStmt(20081) 0
[K				 Insert BinaryOperator(20083) CaseStmt(20081) 1
[K				 Insert MemberExpr(20084) BinaryOperator(20083) 0
[K				 Insert DeclRefExpr(20085) MemberExpr(20084) 0
[K				 Insert DeclRefExpr(20086) BinaryOperator(20083) 1
[K				 Insert ReturnStmt(20087) CompoundStmt(19989) 13
[K				 Insert IntegerLiteral(20088) ReturnStmt(20087) 0
[K				 Insert FunctionDecl(24047) TranslationUnitDecl(0) 1059
[K				 Insert TypeLoc(24048) FunctionDecl(24047) 0
[K				 Insert TypeLoc(24049) TypeLoc(24048) 0
[K				 Insert ParmVarDecl(24050) TypeLoc(24048) 1
[K				 Insert TypeLoc(24051) ParmVarDecl(24050) 0
[K				 Insert TypeLoc(24052) TypeLoc(24051) 0
[K				 Insert TypeLoc(24053) TypeLoc(24052) 0
[K				 Insert CompoundStmt(24054) FunctionDecl(24047) 1
[K				 Insert IfStmt(24055) CompoundStmt(24054) 0
[K				 Insert BinaryOperator(24056) IfStmt(24055) 0
[K				 Insert UnaryOperator(24057) BinaryOperator(24056) 0
[K				 Insert DeclRefExpr(24058) UnaryOperator(24057) 0
[K				 Insert UnaryOperator(24059) BinaryOperator(24056) 1
[K				 Insert CallExpr(24060) UnaryOperator(24059) 0
[K				 Insert DeclRefExpr(24061) CallExpr(24060) 0
[K				 Insert MemberExpr(24062) CallExpr(24060) 1
[K				 Insert DeclRefExpr(24063) MemberExpr(24062) 0
[K				 Insert ReturnStmt(24064) IfStmt(24055) 1
[K				 Insert IntegerLiteral(24065) ReturnStmt(24064) 0
[K				 Insert ReturnStmt(24066) CompoundStmt(24054) 1
[K				 Insert MemberExpr(24067) ReturnStmt(24066) 0
[K				 Insert DeclRefExpr(24068) MemberExpr(24067) 0
[K	Generated AST script
[K			AST Script:
[K				 Insert FunctionDecl(13067) into TranslationUnitDecl(0) at 811
[K				 Insert FunctionDecl(24047) into TranslationUnitDecl(0) at 1058
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/rsn_supp/wpa.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/rsn_supp/wpa.c
[K	Original Patch
[K		1786a1787,1789
[K		> 	case WPA_DRV_STA_REMOVED:
[K		> 		sm->tk_already_set = FALSE;
[K		> 		return 0;
[K		3940a3944,3951
[K		> }
[K		>
[K		>
[K		> int wpa_auth_sta_ft_tk_already_set(struct wpa_state_machine *sm)
[K		> {
[K		> 	if (!sm || !wpa_key_mgmt_ft(sm->wpa_key_mgmt))
[K		> 		return 0;
[K		> 	return sm->tk_already_set;
[K	Generated Patch
[K		1,3799d0
[K		< /*
[K		<  * WPA Supplicant - WPA state machine and EAPOL-Key processing
[K		<  * Copyright (c) 2003-2015, Jouni Malinen <j@w1.fi>
[K		<  * Copyright(c) 2015 Intel Deutschland GmbH
[K		<  *
[K		<  * This software may be distributed under the terms of the BSD license.
[K		<  * See README for more details.
[K		<  */
[K		<
[K		< #include "includes.h"
[K		<
[K		< #include "common.h"
[K		< #include "crypto/aes.h"
[K		< #include "crypto/aes_wrap.h"
[K		< #include "crypto/crypto.h"
[K		< #include "crypto/random.h"
[K		< #include "crypto/aes_siv.h"
[K		< #include "common/ieee802_11_defs.h"
[K		< #include "common/ieee802_11_common.h"
[K		< #include "eap_common/eap_defs.h"
[K		< #include "eapol_supp/eapol_supp_sm.h"
[K		< #include "wpa.h"
[K		< #include "eloop.h"
[K		< #include "preauth.h"
[K		< #include "pmksa_cache.h"
[K		< #include "wpa_i.h"
[K		< #include "wpa_ie.h"
[K		< #include "peerkey.h"
[K		<
[K		<
[K		< static const u8 null_rsc[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
[K		<
[K		<
[K		< /**
[K		<  * wpa_eapol_key_send - Send WPA/RSN EAPOL-Key message
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @ptk: PTK for Key Confirmation/Encryption Key
[K		<  * @ver: Version field from Key Info
[K		<  * @dest: Destination address for the frame
[K		<  * @proto: Ethertype (usually ETH_P_EAPOL)
[K		<  * @msg: EAPOL-Key message
[K		<  * @msg_len: Length of message
[K		<  * @key_mic: Pointer to the buffer to which the EAPOL-Key MIC is written
[K		<  * Returns: >= 0 on success, < 0 on failure
[K		<  */
[K		< int wpa_eapol_key_send(struct wpa_sm *sm, struct wpa_ptk *ptk,
[K		< 		       int ver, const u8 *dest, u16 proto,
[K		< 		       u8 *msg, size_t msg_len, u8 *key_mic)
[K		< {
[K		< 	int ret = -1;
[K		< 	size_t mic_len = wpa_mic_len(sm->key_mgmt);
[K		<
[K		< 	if (is_zero_ether_addr(dest) && is_zero_ether_addr(sm->bssid)) {
[K		< 		/*
[K		< 		 * Association event was not yet received; try to fetch
[K		< 		 * BSSID from the driver.
[K		< 		 */
[K		< 		if (wpa_sm_get_bssid(sm, sm->bssid) < 0) {
[K		< 			wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 				"WPA: Failed to read BSSID for "
[K		< 				"EAPOL-Key destination address");
[K		< 		} else {
[K		< 			dest = sm->bssid;
[K		< 			wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 				"WPA: Use BSSID (" MACSTR
[K		< 				") as the destination for EAPOL-Key",
[K		< 				MAC2STR(dest));
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (mic_len) {
[K		< 		if (key_mic && (!ptk || !ptk->kck_len))
[K		< 			goto out;
[K		<
[K		< 		if (key_mic &&
[K		< 		    wpa_eapol_key_mic(ptk->kck, ptk->kck_len, sm->key_mgmt, ver,
[K		< 				      msg, msg_len, key_mic)) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_ERROR,
[K		< 				"WPA: Failed to generate EAPOL-Key version %d key_mgmt 0x%x MIC",
[K		< 				ver, sm->key_mgmt);
[K		< 			goto out;
[K		< 		}
[K		< 		if (ptk)
[K		< 			wpa_hexdump_key(MSG_DEBUG, "WPA: KCK",
[K		< 					ptk->kck, ptk->kck_len);
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: Derived Key MIC",
[K		< 			    key_mic, mic_len);
[K		< 	} else {
[K		< #ifdef CONFIG_FILS
[K		< 		/* AEAD cipher - Key MIC field not used */
[K		< 		struct ieee802_1x_hdr *s_hdr, *hdr;
[K		< 		struct wpa_eapol_key *s_key, *key;
[K		< 		u8 *buf, *s_key_data, *key_data;
[K		< 		size_t buf_len = msg_len + AES_BLOCK_SIZE;
[K		< 		size_t key_data_len;
[K		< 		u16 eapol_len;
[K		< 		const u8 *aad[1];
[K		< 		size_t aad_len[1];
[K		<
[K		< 		if (!ptk || !ptk->kek_len)
[K		< 			goto out;
[K		<
[K		< 		key_data_len = msg_len - sizeof(struct ieee802_1x_hdr) -
[K		< 			sizeof(struct wpa_eapol_key) - 2;
[K		<
[K		< 		buf = os_malloc(buf_len);
[K		< 		if (!buf)
[K		< 			goto out;
[K		<
[K		< 		os_memcpy(buf, msg, msg_len);
[K		< 		hdr = (struct ieee802_1x_hdr *) buf;
[K		< 		key = (struct wpa_eapol_key *) (hdr + 1);
[K		< 		key_data = ((u8 *) (key + 1)) + 2;
[K		<
[K		< 		/* Update EAPOL header to include AES-SIV overhead */
[K		< 		eapol_len = be_to_host16(hdr->length);
[K		< 		eapol_len += AES_BLOCK_SIZE;
[K		< 		hdr->length = host_to_be16(eapol_len);
[K		<
[K		< 		/* Update Key Data Length field to include AES-SIV overhead */
[K		< 		WPA_PUT_BE16((u8 *) (key + 1), AES_BLOCK_SIZE + key_data_len);
[K		<
[K		< 		s_hdr = (struct ieee802_1x_hdr *) msg;
[K		< 		s_key = (struct wpa_eapol_key *) (s_hdr + 1);
[K		< 		s_key_data = ((u8 *) (s_key + 1)) + 2;
[K		<
[K		< 		wpa_hexdump_key(MSG_DEBUG, "WPA: Plaintext Key Data",
[K		< 				s_key_data, key_data_len);
[K		<
[K		< 		wpa_hexdump_key(MSG_DEBUG, "WPA: KEK", ptk->kek, ptk->kek_len);
[K		< 		 /* AES-SIV AAD from EAPOL protocol version field (inclusive) to
[K		< 		  * to Key Data (exclusive). */
[K		< 		aad[0] = buf;
[K		< 		aad_len[0] = key_data - buf;
[K		< 		if (aes_siv_encrypt(ptk->kek, ptk->kek_len,
[K		< 				    s_key_data, key_data_len,
[K		< 				    1, aad, aad_len, key_data) < 0) {
[K		< 			os_free(buf);
[K		< 			goto out;
[K		< 		}
[K		<
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: Encrypted Key Data from SIV",
[K		< 			    key_data, AES_BLOCK_SIZE + key_data_len);
[K		<
[K		< 		os_free(msg);
[K		< 		msg = buf;
[K		< 		msg_len = buf_len;
[K		< #else /* CONFIG_FILS */
[K		< 		goto out;
[K		< #endif /* CONFIG_FILS */
[K		< 	}
[K		<
[K		< 	wpa_hexdump(MSG_MSGDUMP, "WPA: TX EAPOL-Key", msg, msg_len);
[K		< 	ret = wpa_sm_ether_send(sm, dest, proto, msg, msg_len);
[K		< 	eapol_sm_notify_tx_eapol_key(sm->eapol);
[K		< out:
[K		< 	os_free(msg);
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_key_request - Send EAPOL-Key Request
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @error: Indicate whether this is an Michael MIC error report
[K		<  * @pairwise: 1 = error report for pairwise packet, 0 = for group packet
[K		<  *
[K		<  * Send an EAPOL-Key Request to the current authenticator. This function is
[K		<  * used to request rekeying and it is usually called when a local Michael MIC
[K		<  * failure is detected.
[K		<  */
[K		< void wpa_sm_key_request(struct wpa_sm *sm, int error, int pairwise)
[K		< {
[K		< 	size_t mic_len, hdrlen, rlen;
[K		< 	struct wpa_eapol_key *reply;
[K		< 	int key_info, ver;
[K		< 	u8 bssid[ETH_ALEN], *rbuf, *key_mic, *mic;
[K		<
[K		< 	if (sm->key_mgmt == WPA_KEY_MGMT_OSEN ||
[K		< 	    wpa_key_mgmt_suite_b(sm->key_mgmt))
[K		< 		ver = WPA_KEY_INFO_TYPE_AKM_DEFINED;
[K		< 	else if (wpa_key_mgmt_ft(sm->key_mgmt) ||
[K		< 		 wpa_key_mgmt_sha256(sm->key_mgmt))
[K		< 		ver = WPA_KEY_INFO_TYPE_AES_128_CMAC;
[K		< 	else if (sm->pairwise_cipher != WPA_CIPHER_TKIP)
[K		< 		ver = WPA_KEY_INFO_TYPE_HMAC_SHA1_AES;
[K		< 	else
[K		< 		ver = WPA_KEY_INFO_TYPE_HMAC_MD5_RC4;
[K		<
[K		< 	if (wpa_sm_get_bssid(sm, bssid) < 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"Failed to read BSSID for EAPOL-Key request");
[K		< 		return;
[K		< 	}
[K		<
[K		< 	mic_len = wpa_mic_len(sm->key_mgmt);
[K		< 	hdrlen = sizeof(*reply) + mic_len + 2;
[K		< 	rbuf = wpa_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAPOL_KEY, NULL,
[K		< 				  hdrlen, &rlen, (void *) &reply);
[K		< 	if (rbuf == NULL)
[K		< 		return;
[K		<
[K		< 	reply->type = (sm->proto == WPA_PROTO_RSN ||
[K		< 		       sm->proto == WPA_PROTO_OSEN) ?
[K		< 		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
[K		< 	key_info = WPA_KEY_INFO_REQUEST | ver;
[K		< 	if (sm->ptk_set)
[K		< 		key_info |= WPA_KEY_INFO_SECURE;
[K		< 	if (sm->ptk_set && mic_len)
[K		< 		key_info |= WPA_KEY_INFO_MIC;
[K		< 	if (error)
[K		< 		key_info |= WPA_KEY_INFO_ERROR;
[K		< 	if (pairwise)
[K		< 		key_info |= WPA_KEY_INFO_KEY_TYPE;
[K		< 	WPA_PUT_BE16(reply->key_info, key_info);
[K		< 	WPA_PUT_BE16(reply->key_length, 0);
[K		< 	os_memcpy(reply->replay_counter, sm->request_counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		< 	inc_byte_array(sm->request_counter, WPA_REPLAY_COUNTER_LEN);
[K		<
[K		< 	mic = (u8 *) (reply + 1);
[K		< 	WPA_PUT_BE16(mic + mic_len, 0);
[K		< 	if (!(key_info & WPA_KEY_INFO_MIC))
[K		< 		key_mic = NULL;
[K		< 	else
[K		< 		key_mic = mic;
[K		<
[K		< 	wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 		"WPA: Sending EAPOL-Key Request (error=%d "
[K		< 		"pairwise=%d ptk_set=%d len=%lu)",
[K		< 		error, pairwise, sm->ptk_set, (unsigned long) rlen);
[K		< 	wpa_eapol_key_send(sm, &sm->ptk, ver, bssid, ETH_P_EAPOL, rbuf, rlen,
[K		< 			   key_mic);
[K		< }
[K		<
[K		<
[K		< static void wpa_supplicant_key_mgmt_set_pmk(struct wpa_sm *sm)
[K		< {
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	if (sm->key_mgmt == WPA_KEY_MGMT_FT_IEEE8021X) {
[K		< 		if (wpa_sm_key_mgmt_set_pmk(sm, sm->xxkey, sm->xxkey_len))
[K		< 			wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 				"RSN: Cannot set low order 256 bits of MSK for key management offload");
[K		< 	} else {
[K		< #endif /* CONFIG_IEEE80211R */
[K		< 		if (wpa_sm_key_mgmt_set_pmk(sm, sm->pmk, sm->pmk_len))
[K		< 			wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 				"RSN: Cannot set PMK for key management offload");
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R */
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_get_pmk(struct wpa_sm *sm,
[K		< 				  const unsigned char *src_addr,
[K		< 				  const u8 *pmkid)
[K		< {
[K		< 	int abort_cached = 0;
[K		<
[K		< 	if (pmkid && !sm->cur_pmksa) {
[K		< 		/* When using drivers that generate RSN IE, wpa_supplicant may
[K		< 		 * not have enough time to get the association information
[K		< 		 * event before receiving this 1/4 message, so try to find a
[K		< 		 * matching PMKSA cache entry here. */
[K		< 		sm->cur_pmksa = pmksa_cache_get(sm->pmksa, src_addr, pmkid,
[K		< 						NULL);
[K		< 		if (sm->cur_pmksa) {
[K		< 			wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 				"RSN: found matching PMKID from PMKSA cache");
[K		< 		} else {
[K		< 			wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 				"RSN: no matching PMKID found");
[K		< 			abort_cached = 1;
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (pmkid && sm->cur_pmksa &&
[K		< 	    os_memcmp_const(pmkid, sm->cur_pmksa->pmkid, PMKID_LEN) == 0) {
[K		< 		wpa_hexdump(MSG_DEBUG, "RSN: matched PMKID", pmkid, PMKID_LEN);
[K		< 		wpa_sm_set_pmk_from_pmksa(sm);
[K		< 		wpa_hexdump_key(MSG_DEBUG, "RSN: PMK from PMKSA cache",
[K		< 				sm->pmk, sm->pmk_len);
[K		< 		eapol_sm_notify_cached(sm->eapol);
[K		< #ifdef CONFIG_IEEE80211R
[K		< 		sm->xxkey_len = 0;
[K		< #endif /* CONFIG_IEEE80211R */
[K		< 	} else if (wpa_key_mgmt_wpa_ieee8021x(sm->key_mgmt) && sm->eapol) {
[K		< 		int res, pmk_len;
[K		<
[K		< 		if (wpa_key_mgmt_sha384(sm->key_mgmt))
[K		< 			pmk_len = PMK_LEN_SUITE_B_192;
[K		< 		else
[K		< 			pmk_len = PMK_LEN;
[K		< 		res = eapol_sm_get_key(sm->eapol, sm->pmk, pmk_len);
[K		< 		if (res) {
[K		< 			if (pmk_len == PMK_LEN) {
[K		< 				/*
[K		< 				 * EAP-LEAP is an exception from other EAP
[K		< 				 * methods: it uses only 16-byte PMK.
[K		< 				 */
[K		< 				res = eapol_sm_get_key(sm->eapol, sm->pmk, 16);
[K		< 				pmk_len = 16;
[K		< 			}
[K		< 		} else {
[K		< #ifdef CONFIG_IEEE80211R
[K		< 			u8 buf[2 * PMK_LEN];
[K		< 			if (eapol_sm_get_key(sm->eapol, buf, 2 * PMK_LEN) == 0)
[K		< 			{
[K		< 				os_memcpy(sm->xxkey, buf + PMK_LEN, PMK_LEN);
[K		< 				sm->xxkey_len = PMK_LEN;
[K		< 				os_memset(buf, 0, sizeof(buf));
[K		< 			}
[K		< #endif /* CONFIG_IEEE80211R */
[K		< 		}
[K		< 		if (res == 0) {
[K		< 			struct rsn_pmksa_cache_entry *sa = NULL;
[K		< 			wpa_hexdump_key(MSG_DEBUG, "WPA: PMK from EAPOL state "
[K		< 					"machines", sm->pmk, pmk_len);
[K		< 			sm->pmk_len = pmk_len;
[K		< 			wpa_supplicant_key_mgmt_set_pmk(sm);
[K		< 			if (sm->proto == WPA_PROTO_RSN &&
[K		< 			    !wpa_key_mgmt_suite_b(sm->key_mgmt) &&
[K		< 			    !wpa_key_mgmt_ft(sm->key_mgmt)) {
[K		< 				sa = pmksa_cache_add(sm->pmksa,
[K		< 						     sm->pmk, pmk_len, NULL,
[K		< 						     NULL, 0,
[K		< 						     src_addr, sm->own_addr,
[K		< 						     sm->network_ctx,
[K		< 						     sm->key_mgmt);
[K		< 			}
[K		< 			if (!sm->cur_pmksa && pmkid &&
[K		< 			    pmksa_cache_get(sm->pmksa, src_addr, pmkid, NULL))
[K		< 			{
[K		< 				wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 					"RSN: the new PMK matches with the "
[K		< 					"PMKID");
[K		< 				abort_cached = 0;
[K		< 			} else if (sa && !sm->cur_pmksa && pmkid) {
[K		< 				/*
[K		< 				 * It looks like the authentication server
[K		< 				 * derived mismatching MSK. This should not
[K		< 				 * really happen, but bugs happen.. There is not
[K		< 				 * much we can do here without knowing what
[K		< 				 * exactly caused the server to misbehave.
[K		< 				 */
[K		< 				wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 					"RSN: PMKID mismatch - authentication server may have derived different MSK?!");
[K		< 				return -1;
[K		< 			}
[K		<
[K		< 			if (!sm->cur_pmksa)
[K		< 				sm->cur_pmksa = sa;
[K		< 		} else {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Failed to get master session key from "
[K		< 				"EAPOL state machines - key handshake "
[K		< 				"aborted");
[K		< 			if (sm->cur_pmksa) {
[K		< 				wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 					"RSN: Cancelled PMKSA caching "
[K		< 					"attempt");
[K		< 				sm->cur_pmksa = NULL;
[K		< 				abort_cached = 1;
[K		< 			} else if (!abort_cached) {
[K		< 				return -1;
[K		< 			}
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (abort_cached && wpa_key_mgmt_wpa_ieee8021x(sm->key_mgmt) &&
[K		< 	    !wpa_key_mgmt_suite_b(sm->key_mgmt) &&
[K		< 	    !wpa_key_mgmt_ft(sm->key_mgmt) && sm->key_mgmt != WPA_KEY_MGMT_OSEN)
[K		< 	{
[K		< 		/* Send EAPOL-Start to trigger full EAP authentication. */
[K		< 		u8 *buf;
[K		< 		size_t buflen;
[K		<
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"RSN: no PMKSA entry found - trigger "
[K		< 			"full EAP authentication");
[K		< 		buf = wpa_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAPOL_START,
[K		< 					 NULL, 0, &buflen, NULL);
[K		< 		if (buf) {
[K		< 			wpa_sm_ether_send(sm, sm->bssid, ETH_P_EAPOL,
[K		< 					  buf, buflen);
[K		< 			os_free(buf);
[K		< 			return -2;
[K		< 		}
[K		<
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_supplicant_send_2_of_4 - Send message 2 of WPA/RSN 4-Way Handshake
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @dst: Destination address for the frame
[K		<  * @key: Pointer to the EAPOL-Key frame header
[K		<  * @ver: Version bits from EAPOL-Key Key Info
[K		<  * @nonce: Nonce value for the EAPOL-Key frame
[K		<  * @wpa_ie: WPA/RSN IE
[K		<  * @wpa_ie_len: Length of the WPA/RSN IE
[K		<  * @ptk: PTK to use for keyed hash and encryption
[K		<  * Returns: >= 0 on success, < 0 on failure
[K		<  */
[K		< int wpa_supplicant_send_2_of_4(struct wpa_sm *sm, const unsigned char *dst,
[K		< 			       const struct wpa_eapol_key *key,
[K		< 			       int ver, const u8 *nonce,
[K		< 			       const u8 *wpa_ie, size_t wpa_ie_len,
[K		< 			       struct wpa_ptk *ptk)
[K		< {
[K		< 	size_t mic_len, hdrlen, rlen;
[K		< 	struct wpa_eapol_key *reply;
[K		< 	u8 *rbuf, *key_mic;
[K		< 	u8 *rsn_ie_buf = NULL;
[K		< 	u16 key_info;
[K		<
[K		< 	if (wpa_ie == NULL) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING, "WPA: No wpa_ie set - "
[K		< 			"cannot generate msg 2/4");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	if (wpa_key_mgmt_ft(sm->key_mgmt)) {
[K		< 		int res;
[K		<
[K		< 		/*
[K		< 		 * Add PMKR1Name into RSN IE (PMKID-List) and add MDIE and
[K		< 		 * FTIE from (Re)Association Response.
[K		< 		 */
[K		< 		rsn_ie_buf = os_malloc(wpa_ie_len + 2 + 2 + PMKID_LEN +
[K		< 				       sm->assoc_resp_ies_len);
[K		< 		if (rsn_ie_buf == NULL)
[K		< 			return -1;
[K		< 		os_memcpy(rsn_ie_buf, wpa_ie, wpa_ie_len);
[K		< 		res = wpa_insert_pmkid(rsn_ie_buf, &wpa_ie_len,
[K		< 				       sm->pmk_r1_name);
[K		< 		if (res < 0) {
[K		< 			os_free(rsn_ie_buf);
[K		< 			return -1;
[K		< 		}
[K		<
[K		< 		if (sm->assoc_resp_ies) {
[K		< 			os_memcpy(rsn_ie_buf + wpa_ie_len, sm->assoc_resp_ies,
[K		< 				  sm->assoc_resp_ies_len);
[K		< 			wpa_ie_len += sm->assoc_resp_ies_len;
[K		< 		}
[K		<
[K		< 		wpa_ie = rsn_ie_buf;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R */
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: WPA IE for msg 2/4", wpa_ie, wpa_ie_len);
[K		<
[K		< 	mic_len = wpa_mic_len(sm->key_mgmt);
[K		< 	hdrlen = sizeof(*reply) + mic_len + 2;
[K		< 	rbuf = wpa_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAPOL_KEY,
[K		< 				  NULL, hdrlen + wpa_ie_len,
[K		< 				  &rlen, (void *) &reply);
[K		< 	if (rbuf == NULL) {
[K		< 		os_free(rsn_ie_buf);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	reply->type = (sm->proto == WPA_PROTO_RSN ||
[K		< 		       sm->proto == WPA_PROTO_OSEN) ?
[K		< 		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
[K		< 	key_info = ver | WPA_KEY_INFO_KEY_TYPE;
[K		< 	if (mic_len)
[K		< 		key_info |= WPA_KEY_INFO_MIC;
[K		< 	else
[K		< 		key_info |= WPA_KEY_INFO_ENCR_KEY_DATA;
[K		< 	WPA_PUT_BE16(reply->key_info, key_info);
[K		< 	if (sm->proto == WPA_PROTO_RSN || sm->proto == WPA_PROTO_OSEN)
[K		< 		WPA_PUT_BE16(reply->key_length, 0);
[K		< 	else
[K		< 		os_memcpy(reply->key_length, key->key_length, 2);
[K		< 	os_memcpy(reply->replay_counter, key->replay_counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: Replay Counter", reply->replay_counter,
[K		< 		    WPA_REPLAY_COUNTER_LEN);
[K		<
[K		< 	key_mic = (u8 *) (reply + 1);
[K		< 	WPA_PUT_BE16(key_mic + mic_len, wpa_ie_len); /* Key Data Length */
[K		< 	os_memcpy(key_mic + mic_len + 2, wpa_ie, wpa_ie_len); /* Key Data */
[K		< 	os_free(rsn_ie_buf);
[K		<
[K		< 	os_memcpy(reply->key_nonce, nonce, WPA_NONCE_LEN);
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Sending EAPOL-Key 2/4");
[K		< 	return wpa_eapol_key_send(sm, ptk, ver, dst, ETH_P_EAPOL, rbuf, rlen,
[K		< 				  key_mic);
[K		< }
[K		<
[K		<
[K		< static int wpa_derive_ptk(struct wpa_sm *sm, const unsigned char *src_addr,
[K		< 			  const struct wpa_eapol_key *key, struct wpa_ptk *ptk)
[K		< {
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	if (wpa_key_mgmt_ft(sm->key_mgmt))
[K		< 		return wpa_derive_ptk_ft(sm, src_addr, key, ptk);
[K		< #endif /* CONFIG_IEEE80211R */
[K		<
[K		< 	return wpa_pmk_to_ptk(sm->pmk, sm->pmk_len, "Pairwise key expansion",
[K		< 			      sm->own_addr, sm->bssid, sm->snonce,
[K		< 			      key->key_nonce, ptk, sm->key_mgmt,
[K		< 			      sm->pairwise_cipher);
[K		< }
[K		<
[K		<
[K		< static void wpa_supplicant_process_1_of_4(struct wpa_sm *sm,
[K		< 					  const unsigned char *src_addr,
[K		< 					  const struct wpa_eapol_key *key,
[K		< 					  u16 ver, const u8 *key_data,
[K		< 					  size_t key_data_len)
[K		< {
[K		< 	struct wpa_eapol_ie_parse ie;
[K		< 	struct wpa_ptk *ptk;
[K		< 	int res;
[K		< 	u8 *kde, *kde_buf = NULL;
[K		< 	size_t kde_len;
[K		<
[K		< 	if (wpa_sm_get_network_ctx(sm) == NULL) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING, "WPA: No SSID info "
[K		< 			"found (msg 1 of 4)");
[K		< 		return;
[K		< 	}
[K		<
[K		< 	wpa_sm_set_state(sm, WPA_4WAY_HANDSHAKE);
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: RX message 1 of 4-Way "
[K		< 		"Handshake from " MACSTR " (ver=%d)", MAC2STR(src_addr), ver);
[K		<
[K		< 	os_memset(&ie, 0, sizeof(ie));
[K		<
[K		< 	if (sm->proto == WPA_PROTO_RSN || sm->proto == WPA_PROTO_OSEN) {
[K		< 		/* RSN: msg 1/4 should contain PMKID for the selected PMK */
[K		< 		wpa_hexdump(MSG_DEBUG, "RSN: msg 1/4 key data",
[K		< 			    key_data, key_data_len);
[K		< 		if (wpa_supplicant_parse_ies(key_data, key_data_len, &ie) < 0)
[K		< 			goto failed;
[K		< 		if (ie.pmkid) {
[K		< 			wpa_hexdump(MSG_DEBUG, "RSN: PMKID from "
[K		< 				    "Authenticator", ie.pmkid, PMKID_LEN);
[K		< 		}
[K		< 	}
[K		<
[K		< 	res = wpa_supplicant_get_pmk(sm, src_addr, ie.pmkid);
[K		< 	if (res == -2) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "RSN: Do not reply to "
[K		< 			"msg 1/4 - requesting full EAP authentication");
[K		< 		return;
[K		< 	}
[K		< 	if (res)
[K		< 		goto failed;
[K		<
[K		< 	if (sm->renew_snonce) {
[K		< 		if (random_get_bytes(sm->snonce, WPA_NONCE_LEN)) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Failed to get random data for SNonce");
[K		< 			goto failed;
[K		< 		}
[K		< 		sm->renew_snonce = 0;
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: Renewed SNonce",
[K		< 			    sm->snonce, WPA_NONCE_LEN);
[K		< 	}
[K		<
[K		< 	/* Calculate PTK which will be stored as a temporary PTK until it has
[K		< 	 * been verified when processing message 3/4. */
[K		< 	ptk = &sm->tptk;
[K		< 	wpa_derive_ptk(sm, src_addr, key, ptk);
[K		< 	if (sm->pairwise_cipher == WPA_CIPHER_TKIP) {
[K		< 		u8 buf[8];
[K		< 		/* Supplicant: swap tx/rx Mic keys */
[K		< 		os_memcpy(buf, &ptk->tk[16], 8);
[K		< 		os_memcpy(&ptk->tk[16], &ptk->tk[24], 8);
[K		< 		os_memcpy(&ptk->tk[24], buf, 8);
[K		< 		os_memset(buf, 0, sizeof(buf));
[K		< 	}
[K		< 	sm->tptk_set = 1;
[K		< 	sm->tk_to_set = 1;
[K		<
[K		< 	kde = sm->assoc_wpa_ie;
[K		< 	kde_len = sm->assoc_wpa_ie_len;
[K		<
[K		< #ifdef CONFIG_P2P
[K		< 	if (sm->p2p) {
[K		< 		kde_buf = os_malloc(kde_len + 2 + RSN_SELECTOR_LEN + 1);
[K		< 		if (kde_buf) {
[K		< 			u8 *pos;
[K		< 			wpa_printf(MSG_DEBUG, "P2P: Add IP Address Request KDE "
[K		< 				   "into EAPOL-Key 2/4");
[K		< 			os_memcpy(kde_buf, kde, kde_len);
[K		< 			kde = kde_buf;
[K		< 			pos = kde + kde_len;
[K		< 			*pos++ = WLAN_EID_VENDOR_SPECIFIC;
[K		< 			*pos++ = RSN_SELECTOR_LEN + 1;
[K		< 			RSN_SELECTOR_PUT(pos, WFA_KEY_DATA_IP_ADDR_REQ);
[K		< 			pos += RSN_SELECTOR_LEN;
[K		< 			*pos++ = 0x01;
[K		< 			kde_len = pos - kde;
[K		< 		}
[K		< 	}
[K		< #endif /* CONFIG_P2P */
[K		<
[K		< 	if (wpa_supplicant_send_2_of_4(sm, sm->bssid, key, ver, sm->snonce,
[K		< 				       kde, kde_len, ptk) < 0)
[K		< 		goto failed;
[K		<
[K		< 	os_free(kde_buf);
[K		< 	os_memcpy(sm->anonce, key->key_nonce, WPA_NONCE_LEN);
[K		< 	return;
[K		<
[K		< failed:
[K		< 	os_free(kde_buf);
[K		< 	wpa_sm_deauthenticate(sm, WLAN_REASON_UNSPECIFIED);
[K		< }
[K		<
[K		<
[K		< static void wpa_sm_start_preauth(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_sm *sm = eloop_ctx;
[K		< 	rsn_preauth_candidate_process(sm);
[K		< }
[K		<
[K		<
[K		< static void wpa_supplicant_key_neg_complete(struct wpa_sm *sm,
[K		< 					    const u8 *addr, int secure)
[K		< {
[K		< 	wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 		"WPA: Key negotiation completed with "
[K		< 		MACSTR " [PTK=%s GTK=%s]", MAC2STR(addr),
[K		< 		wpa_cipher_txt(sm->pairwise_cipher),
[K		< 		wpa_cipher_txt(sm->group_cipher));
[K		< 	wpa_sm_cancel_auth_timeout(sm);
[K		< 	wpa_sm_set_state(sm, WPA_COMPLETED);
[K		<
[K		< 	if (secure) {
[K		< 		wpa_sm_mlme_setprotection(
[K		< 			sm, addr, MLME_SETPROTECTION_PROTECT_TYPE_RX_TX,
[K		< 			MLME_SETPROTECTION_KEY_TYPE_PAIRWISE);
[K		< 		eapol_sm_notify_portValid(sm->eapol, TRUE);
[K		< 		if (wpa_key_mgmt_wpa_psk(sm->key_mgmt))
[K		< 			eapol_sm_notify_eap_success(sm->eapol, TRUE);
[K		< 		/*
[K		< 		 * Start preauthentication after a short wait to avoid a
[K		< 		 * possible race condition between the data receive and key
[K		< 		 * configuration after the 4-Way Handshake. This increases the
[K		< 		 * likelihood of the first preauth EAPOL-Start frame getting to
[K		< 		 * the target AP.
[K		< 		 */
[K		< 		eloop_register_timeout(1, 0, wpa_sm_start_preauth, sm, NULL);
[K		< 	}
[K		<
[K		< 	if (sm->cur_pmksa && sm->cur_pmksa->opportunistic) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"RSN: Authenticator accepted "
[K		< 			"opportunistic PMKSA entry - marking it valid");
[K		< 		sm->cur_pmksa->opportunistic = 0;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	if (wpa_key_mgmt_ft(sm->key_mgmt)) {
[K		< 		/* Prepare for the next transition */
[K		< 		wpa_ft_prepare_auth_request(sm, NULL);
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R */
[K		< }
[K		<
[K		<
[K		< static void wpa_sm_rekey_ptk(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_sm *sm = eloop_ctx;
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Request PTK rekeying");
[K		< 	wpa_sm_key_request(sm, 0, 1);
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_install_ptk(struct wpa_sm *sm,
[K		< 				      const struct wpa_eapol_key *key)
[K		< {
[K		< 	int keylen, rsclen;
[K		< 	enum wpa_alg alg;
[K		< 	const u8 *key_rsc;
[K		<
[K		< 	if (!sm->tk_to_set) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: Do not re-install same PTK to the driver");
[K		< 		return 0;
[K		< 	}
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 		"WPA: Installing PTK to the driver");
[K		<
[K		< 	if (sm->pairwise_cipher == WPA_CIPHER_NONE) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Pairwise Cipher "
[K		< 			"Suite: NONE - do not use pairwise keys");
[K		< 		return 0;
[K		< 	}
[K		<
[K		< 	if (!wpa_cipher_valid_pairwise(sm->pairwise_cipher)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Unsupported pairwise cipher %d",
[K		< 			sm->pairwise_cipher);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	alg = wpa_cipher_to_alg(sm->pairwise_cipher);
[K		< 	keylen = wpa_cipher_key_len(sm->pairwise_cipher);
[K		< 	rsclen = wpa_cipher_rsc_len(sm->pairwise_cipher);
[K		<
[K		< 	if (sm->proto == WPA_PROTO_RSN || sm->proto == WPA_PROTO_OSEN) {
[K		< 		key_rsc = null_rsc;
[K		< 	} else {
[K		< 		key_rsc = key->key_rsc;
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: RSC", key_rsc, rsclen);
[K		< 	}
[K		<
[K		< 	if (wpa_sm_set_key(sm, alg, sm->bssid, 0, 1, key_rsc, rsclen,
[K		< 			   sm->ptk.tk, keylen) < 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Failed to set PTK to the "
[K		< 			"driver (alg=%d keylen=%d bssid=" MACSTR ")",
[K		< 			alg, keylen, MAC2STR(sm->bssid));
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	/* TK is not needed anymore in supplicant */
[K		< 	os_memset(sm->ptk.tk, 0, WPA_TK_MAX_LEN);
[K		< 	sm->tk_to_set = 0;
[K		<
[K		< 	if (sm->wpa_ptk_rekey) {
[K		< 		eloop_cancel_timeout(wpa_sm_rekey_ptk, sm, NULL);
[K		< 		eloop_register_timeout(sm->wpa_ptk_rekey, 0, wpa_sm_rekey_ptk,
[K		< 				       sm, NULL);
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_check_group_cipher(struct wpa_sm *sm,
[K		< 					     int group_cipher,
[K		< 					     int keylen, int maxkeylen,
[K		< 					     int *key_rsc_len,
[K		< 					     enum wpa_alg *alg)
[K		< {
[K		< 	int klen;
[K		<
[K		< 	*alg = wpa_cipher_to_alg(group_cipher);
[K		< 	if (*alg == WPA_ALG_NONE) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Unsupported Group Cipher %d",
[K		< 			group_cipher);
[K		< 		return -1;
[K		< 	}
[K		< 	*key_rsc_len = wpa_cipher_rsc_len(group_cipher);
[K		<
[K		< 	klen = wpa_cipher_key_len(group_cipher);
[K		< 	if (keylen != klen || maxkeylen < klen) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Unsupported %s Group Cipher key length %d (%d)",
[K		< 			wpa_cipher_txt(group_cipher), keylen, maxkeylen);
[K		< 		return -1;
[K		< 	}
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< struct wpa_gtk_data {
[K		< 	enum wpa_alg alg;
[K		< 	int tx, key_rsc_len, keyidx;
[K		< 	u8 gtk[32];
[K		< 	int gtk_len;
[K		< };
[K		<
[K		<
[K		< static int wpa_supplicant_install_gtk(struct wpa_sm *sm,
[K		< 				      const struct wpa_gtk_data *gd,
[K		< 				      const u8 *key_rsc)
[K		< {
[K		< 	const u8 *_gtk = gd->gtk;
[K		< 	u8 gtk_buf[32];
[K		<
[K		< 	wpa_hexdump_key(MSG_DEBUG, "WPA: Group Key", gd->gtk, gd->gtk_len);
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 		"WPA: Installing GTK to the driver (keyidx=%d tx=%d len=%d)",
[K		< 		gd->keyidx, gd->tx, gd->gtk_len);
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: RSC", key_rsc, gd->key_rsc_len);
[K		< 	if (sm->group_cipher == WPA_CIPHER_TKIP) {
[K		< 		/* Swap Tx/Rx keys for Michael MIC */
[K		< 		os_memcpy(gtk_buf, gd->gtk, 16);
[K		< 		os_memcpy(gtk_buf + 16, gd->gtk + 24, 8);
[K		< 		os_memcpy(gtk_buf + 24, gd->gtk + 16, 8);
[K		< 		_gtk = gtk_buf;
[K		< 	}
[K		< 	if (sm->pairwise_cipher == WPA_CIPHER_NONE) {
[K		< 		if (wpa_sm_set_key(sm, gd->alg, NULL,
[K		< 				   gd->keyidx, 1, key_rsc, gd->key_rsc_len,
[K		< 				   _gtk, gd->gtk_len) < 0) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Failed to set GTK to the driver "
[K		< 				"(Group only)");
[K		< 			os_memset(gtk_buf, 0, sizeof(gtk_buf));
[K		< 			return -1;
[K		< 		}
[K		< 	} else if (wpa_sm_set_key(sm, gd->alg, broadcast_ether_addr,
[K		< 				  gd->keyidx, gd->tx, key_rsc, gd->key_rsc_len,
[K		< 				  _gtk, gd->gtk_len) < 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Failed to set GTK to "
[K		< 			"the driver (alg=%d keylen=%d keyidx=%d)",
[K		< 			gd->alg, gd->gtk_len, gd->keyidx);
[K		< 		os_memset(gtk_buf, 0, sizeof(gtk_buf));
[K		< 		return -1;
[K		< 	}
[K		< 	os_memset(gtk_buf, 0, sizeof(gtk_buf));
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_gtk_tx_bit_workaround(const struct wpa_sm *sm,
[K		< 						int tx)
[K		< {
[K		< 	if (tx && sm->pairwise_cipher != WPA_CIPHER_NONE) {
[K		< 		/* Ignore Tx bit for GTK if a pairwise key is used. One AP
[K		< 		 * seemed to set this bit (incorrectly, since Tx is only when
[K		< 		 * doing Group Key only APs) and without this workaround, the
[K		< 		 * data connection does not work because wpa_supplicant
[K		< 		 * configured non-zero keyidx to be used for unicast. */
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: Tx bit set for GTK, but pairwise "
[K		< 			"keys are used - ignore Tx bit");
[K		< 		return 0;
[K		< 	}
[K		< 	return tx;
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_rsc_relaxation(const struct wpa_sm *sm,
[K		< 					 const u8 *rsc)
[K		< {
[K		< 	int rsclen;
[K		<
[K		< 	if (!sm->wpa_rsc_relaxation)
[K		< 		return 0;
[K		<
[K		< 	rsclen = wpa_cipher_rsc_len(sm->group_cipher);
[K		<
[K		< 	/*
[K		< 	 * Try to detect RSC (endian) corruption issue where the AP sends
[K		< 	 * the RSC bytes in EAPOL-Key message in the wrong order, both if
[K		< 	 * it's actually a 6-byte field (as it should be) and if it treats
[K		< 	 * it as an 8-byte field.
[K		< 	 * An AP model known to have this bug is the Sapido RB-1632.
[K		< 	 */
[K		< 	if (rsclen == 6 && ((rsc[5] && !rsc[0]) || rsc[6] || rsc[7])) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"RSC %02x%02x%02x%02x%02x%02x%02x%02x is likely bogus, using 0",
[K		< 			rsc[0], rsc[1], rsc[2], rsc[3],
[K		< 			rsc[4], rsc[5], rsc[6], rsc[7]);
[K		<
[K		< 		return 1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_pairwise_gtk(struct wpa_sm *sm,
[K		< 				       const struct wpa_eapol_key *key,
[K		< 				       const u8 *gtk, size_t gtk_len,
[K		< 				       int key_info)
[K		< {
[K		< 	struct wpa_gtk_data gd;
[K		< 	const u8 *key_rsc;
[K		<
[K		< 	/*
[K		< 	 * IEEE Std 802.11i-2004 - 8.5.2 EAPOL-Key frames - Figure 43x
[K		< 	 * GTK KDE format:
[K		< 	 * KeyID[bits 0-1], Tx [bit 2], Reserved [bits 3-7]
[K		< 	 * Reserved [bits 0-7]
[K		< 	 * GTK
[K		< 	 */
[K		<
[K		< 	os_memset(&gd, 0, sizeof(gd));
[K		< 	wpa_hexdump_key(MSG_DEBUG, "RSN: received GTK in pairwise handshake",
[K		< 			gtk, gtk_len);
[K		<
[K		< 	if (gtk_len < 2 || gtk_len - 2 > sizeof(gd.gtk))
[K		< 		return -1;
[K		<
[K		< 	gd.keyidx = gtk[0] & 0x3;
[K		< 	gd.tx = wpa_supplicant_gtk_tx_bit_workaround(sm,
[K		< 						     !!(gtk[0] & BIT(2)));
[K		< 	gtk += 2;
[K		< 	gtk_len -= 2;
[K		<
[K		< 	os_memcpy(gd.gtk, gtk, gtk_len);
[K		< 	gd.gtk_len = gtk_len;
[K		<
[K		< 	key_rsc = key->key_rsc;
[K		< 	if (wpa_supplicant_rsc_relaxation(sm, key->key_rsc))
[K		< 		key_rsc = null_rsc;
[K		<
[K		< 	if (sm->group_cipher != WPA_CIPHER_GTK_NOT_USED &&
[K		< 	    (wpa_supplicant_check_group_cipher(sm, sm->group_cipher,
[K		< 					       gtk_len, gtk_len,
[K		< 					       &gd.key_rsc_len, &gd.alg) ||
[K		< 	     wpa_supplicant_install_gtk(sm, &gd, key_rsc))) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"RSN: Failed to install GTK");
[K		< 		os_memset(&gd, 0, sizeof(gd));
[K		< 		return -1;
[K		< 	}
[K		< 	os_memset(&gd, 0, sizeof(gd));
[K		<
[K		< 	wpa_supplicant_key_neg_complete(sm, sm->bssid,
[K		< 					key_info & WPA_KEY_INFO_SECURE);
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int ieee80211w_set_keys(struct wpa_sm *sm,
[K		< 			       struct wpa_eapol_ie_parse *ie)
[K		< {
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (!wpa_cipher_valid_mgmt_group(sm->mgmt_group_cipher))
[K		< 		return 0;
[K		<
[K		< 	if (ie->igtk) {
[K		< 		size_t len;
[K		< 		const struct wpa_igtk_kde *igtk;
[K		< 		u16 keyidx;
[K		< 		len = wpa_cipher_key_len(sm->mgmt_group_cipher);
[K		< 		if (ie->igtk_len != WPA_IGTK_KDE_PREFIX_LEN + len)
[K		< 			return -1;
[K		< 		igtk = (const struct wpa_igtk_kde *) ie->igtk;
[K		< 		keyidx = WPA_GET_LE16(igtk->keyid);
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: IGTK keyid %d "
[K		< 			"pn %02x%02x%02x%02x%02x%02x",
[K		< 			keyidx, MAC2STR(igtk->pn));
[K		< 		wpa_hexdump_key(MSG_DEBUG, "WPA: IGTK",
[K		< 				igtk->igtk, len);
[K		< 		if (keyidx > 4095) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Invalid IGTK KeyID %d", keyidx);
[K		< 			return -1;
[K		< 		}
[K		< 		if (wpa_sm_set_key(sm, wpa_cipher_to_alg(sm->mgmt_group_cipher),
[K		< 				   broadcast_ether_addr,
[K		< 				   keyidx, 0, igtk->pn, sizeof(igtk->pn),
[K		< 				   igtk->igtk, len) < 0) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Failed to configure IGTK to the driver");
[K		< 			return -1;
[K		< 		}
[K		< 	}
[K		<
[K		< 	return 0;
[K		< #else /* CONFIG_IEEE80211W */
[K		< 	return 0;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< }
[K		<
[K		<
[K		< static void wpa_report_ie_mismatch(struct wpa_sm *sm,
[K		< 				   const char *reason, const u8 *src_addr,
[K		< 				   const u8 *wpa_ie, size_t wpa_ie_len,
[K		< 				   const u8 *rsn_ie, size_t rsn_ie_len)
[K		< {
[K		< 	wpa_msg(sm->ctx->msg_ctx, MSG_WARNING, "WPA: %s (src=" MACSTR ")",
[K		< 		reason, MAC2STR(src_addr));
[K		<
[K		< 	if (sm->ap_wpa_ie) {
[K		< 		wpa_hexdump(MSG_INFO, "WPA: WPA IE in Beacon/ProbeResp",
[K		< 			    sm->ap_wpa_ie, sm->ap_wpa_ie_len);
[K		< 	}
[K		< 	if (wpa_ie) {
[K		< 		if (!sm->ap_wpa_ie) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 				"WPA: No WPA IE in Beacon/ProbeResp");
[K		< 		}
[K		< 		wpa_hexdump(MSG_INFO, "WPA: WPA IE in 3/4 msg",
[K		< 			    wpa_ie, wpa_ie_len);
[K		< 	}
[K		<
[K		< 	if (sm->ap_rsn_ie) {
[K		< 		wpa_hexdump(MSG_INFO, "WPA: RSN IE in Beacon/ProbeResp",
[K		< 			    sm->ap_rsn_ie, sm->ap_rsn_ie_len);
[K		< 	}
[K		< 	if (rsn_ie) {
[K		< 		if (!sm->ap_rsn_ie) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 				"WPA: No RSN IE in Beacon/ProbeResp");
[K		< 		}
[K		< 		wpa_hexdump(MSG_INFO, "WPA: RSN IE in 3/4 msg",
[K		< 			    rsn_ie, rsn_ie_len);
[K		< 	}
[K		<
[K		< 	wpa_sm_deauthenticate(sm, WLAN_REASON_IE_IN_4WAY_DIFFERS);
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		<
[K		< static int ft_validate_mdie(struct wpa_sm *sm,
[K		< 			    const unsigned char *src_addr,
[K		< 			    struct wpa_eapol_ie_parse *ie,
[K		< 			    const u8 *assoc_resp_mdie)
[K		< {
[K		< 	struct rsn_mdie *mdie;
[K		<
[K		< 	mdie = (struct rsn_mdie *) (ie->mdie + 2);
[K		< 	if (ie->mdie == NULL || ie->mdie_len < 2 + sizeof(*mdie) ||
[K		< 	    os_memcmp(mdie->mobility_domain, sm->mobility_domain,
[K		< 		      MOBILITY_DOMAIN_ID_LEN) != 0) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "FT: MDIE in msg 3/4 did "
[K		< 			"not match with the current mobility domain");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (assoc_resp_mdie &&
[K		< 	    (assoc_resp_mdie[1] != ie->mdie[1] ||
[K		< 	     os_memcmp(assoc_resp_mdie, ie->mdie, 2 + ie->mdie[1]) != 0)) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "FT: MDIE mismatch");
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: MDIE in EAPOL-Key msg 3/4",
[K		< 			    ie->mdie, 2 + ie->mdie[1]);
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: MDIE in (Re)Association Response",
[K		< 			    assoc_resp_mdie, 2 + assoc_resp_mdie[1]);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int ft_validate_ftie(struct wpa_sm *sm,
[K		< 			    const unsigned char *src_addr,
[K		< 			    struct wpa_eapol_ie_parse *ie,
[K		< 			    const u8 *assoc_resp_ftie)
[K		< {
[K		< 	if (ie->ftie == NULL) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"FT: No FTIE in EAPOL-Key msg 3/4");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (assoc_resp_ftie == NULL)
[K		< 		return 0;
[K		<
[K		< 	if (assoc_resp_ftie[1] != ie->ftie[1] ||
[K		< 	    os_memcmp(assoc_resp_ftie, ie->ftie, 2 + ie->ftie[1]) != 0) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "FT: FTIE mismatch");
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: FTIE in EAPOL-Key msg 3/4",
[K		< 			    ie->ftie, 2 + ie->ftie[1]);
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: FTIE in (Re)Association Response",
[K		< 			    assoc_resp_ftie, 2 + assoc_resp_ftie[1]);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int ft_validate_rsnie(struct wpa_sm *sm,
[K		< 			     const unsigned char *src_addr,
[K		< 			     struct wpa_eapol_ie_parse *ie)
[K		< {
[K		< 	struct wpa_ie_data rsn;
[K		<
[K		< 	if (!ie->rsn_ie)
[K		< 		return 0;
[K		<
[K		< 	/*
[K		< 	 * Verify that PMKR1Name from EAPOL-Key message 3/4
[K		< 	 * matches with the value we derived.
[K		< 	 */
[K		< 	if (wpa_parse_wpa_ie_rsn(ie->rsn_ie, ie->rsn_ie_len, &rsn) < 0 ||
[K		< 	    rsn.num_pmkid != 1 || rsn.pmkid == NULL) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "FT: No PMKR1Name in "
[K		< 			"FT 4-way handshake message 3/4");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (os_memcmp_const(rsn.pmkid, sm->pmk_r1_name, WPA_PMK_NAME_LEN) != 0)
[K		< 	{
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"FT: PMKR1Name mismatch in "
[K		< 			"FT 4-way handshake message 3/4");
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: PMKR1Name from Authenticator",
[K		< 			    rsn.pmkid, WPA_PMK_NAME_LEN);
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: Derived PMKR1Name",
[K		< 			    sm->pmk_r1_name, WPA_PMK_NAME_LEN);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_validate_ie_ft(struct wpa_sm *sm,
[K		< 					 const unsigned char *src_addr,
[K		< 					 struct wpa_eapol_ie_parse *ie)
[K		< {
[K		< 	const u8 *pos, *end, *mdie = NULL, *ftie = NULL;
[K		<
[K		< 	if (sm->assoc_resp_ies) {
[K		< 		pos = sm->assoc_resp_ies;
[K		< 		end = pos + sm->assoc_resp_ies_len;
[K		< 		while (end - pos > 2) {
[K		< 			if (2 + pos[1] > end - pos)
[K		< 				break;
[K		< 			switch (*pos) {
[K		< 			case WLAN_EID_MOBILITY_DOMAIN:
[K		< 				mdie = pos;
[K		< 				break;
[K		< 			case WLAN_EID_FAST_BSS_TRANSITION:
[K		< 				ftie = pos;
[K		< 				break;
[K		< 			}
[K		< 			pos += 2 + pos[1];
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (ft_validate_mdie(sm, src_addr, ie, mdie) < 0 ||
[K		< 	    ft_validate_ftie(sm, src_addr, ie, ftie) < 0 ||
[K		< 	    ft_validate_rsnie(sm, src_addr, ie) < 0)
[K		< 		return -1;
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		< #endif /* CONFIG_IEEE80211R */
[K		<
[K		<
[K		< static int wpa_supplicant_validate_ie(struct wpa_sm *sm,
[K		< 				      const unsigned char *src_addr,
[K		< 				      struct wpa_eapol_ie_parse *ie)
[K		< {
[K		< 	if (sm->ap_wpa_ie == NULL && sm->ap_rsn_ie == NULL) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: No WPA/RSN IE for this AP known. "
[K		< 			"Trying to get from scan results");
[K		< 		if (wpa_sm_get_beacon_ie(sm) < 0) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Could not find AP from "
[K		< 				"the scan results");
[K		< 		} else {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 				"WPA: Found the current AP from "
[K		< 				"updated scan results");
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (ie->wpa_ie == NULL && ie->rsn_ie == NULL &&
[K		< 	    (sm->ap_wpa_ie || sm->ap_rsn_ie)) {
[K		< 		wpa_report_ie_mismatch(sm, "IE in 3/4 msg does not match "
[K		< 				       "with IE in Beacon/ProbeResp (no IE?)",
[K		< 				       src_addr, ie->wpa_ie, ie->wpa_ie_len,
[K		< 				       ie->rsn_ie, ie->rsn_ie_len);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if ((ie->wpa_ie && sm->ap_wpa_ie &&
[K		< 	     (ie->wpa_ie_len != sm->ap_wpa_ie_len ||
[K		< 	      os_memcmp(ie->wpa_ie, sm->ap_wpa_ie, ie->wpa_ie_len) != 0)) ||
[K		< 	    (ie->rsn_ie && sm->ap_rsn_ie &&
[K		< 	     wpa_compare_rsn_ie(wpa_key_mgmt_ft(sm->key_mgmt),
[K		< 				sm->ap_rsn_ie, sm->ap_rsn_ie_len,
[K		< 				ie->rsn_ie, ie->rsn_ie_len))) {
[K		< 		wpa_report_ie_mismatch(sm, "IE in 3/4 msg does not match "
[K		< 				       "with IE in Beacon/ProbeResp",
[K		< 				       src_addr, ie->wpa_ie, ie->wpa_ie_len,
[K		< 				       ie->rsn_ie, ie->rsn_ie_len);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (sm->proto == WPA_PROTO_WPA &&
[K		< 	    ie->rsn_ie && sm->ap_rsn_ie == NULL && sm->rsn_enabled) {
[K		< 		wpa_report_ie_mismatch(sm, "Possible downgrade attack "
[K		< 				       "detected - RSN was enabled and RSN IE "
[K		< 				       "was in msg 3/4, but not in "
[K		< 				       "Beacon/ProbeResp",
[K		< 				       src_addr, ie->wpa_ie, ie->wpa_ie_len,
[K		< 				       ie->rsn_ie, ie->rsn_ie_len);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	if (wpa_key_mgmt_ft(sm->key_mgmt) &&
[K		< 	    wpa_supplicant_validate_ie_ft(sm, src_addr, ie) < 0)
[K		< 		return -1;
[K		< #endif /* CONFIG_IEEE80211R */
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_supplicant_send_4_of_4 - Send message 4 of WPA/RSN 4-Way Handshake
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @dst: Destination address for the frame
[K		<  * @key: Pointer to the EAPOL-Key frame header
[K		<  * @ver: Version bits from EAPOL-Key Key Info
[K		<  * @key_info: Key Info
[K		<  * @ptk: PTK to use for keyed hash and encryption
[K		<  * Returns: >= 0 on success, < 0 on failure
[K		<  */
[K		< int wpa_supplicant_send_4_of_4(struct wpa_sm *sm, const unsigned char *dst,
[K		< 			       const struct wpa_eapol_key *key,
[K		< 			       u16 ver, u16 key_info,
[K		< 			       struct wpa_ptk *ptk)
[K		< {
[K		< 	size_t mic_len, hdrlen, rlen;
[K		< 	struct wpa_eapol_key *reply;
[K		< 	u8 *rbuf, *key_mic;
[K		<
[K		< 	mic_len = wpa_mic_len(sm->key_mgmt);
[K		< 	hdrlen = sizeof(*reply) + mic_len + 2;
[K		< 	rbuf = wpa_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAPOL_KEY, NULL,
[K		< 				  hdrlen, &rlen, (void *) &reply);
[K		< 	if (rbuf == NULL)
[K		< 		return -1;
[K		<
[K		< 	reply->type = (sm->proto == WPA_PROTO_RSN ||
[K		< 		       sm->proto == WPA_PROTO_OSEN) ?
[K		< 		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
[K		< 	key_info &= WPA_KEY_INFO_SECURE;
[K		< 	key_info |= ver | WPA_KEY_INFO_KEY_TYPE;
[K		< 	if (mic_len)
[K		< 		key_info |= WPA_KEY_INFO_MIC;
[K		< 	else
[K		< 		key_info |= WPA_KEY_INFO_ENCR_KEY_DATA;
[K		< 	WPA_PUT_BE16(reply->key_info, key_info);
[K		< 	if (sm->proto == WPA_PROTO_RSN || sm->proto == WPA_PROTO_OSEN)
[K		< 		WPA_PUT_BE16(reply->key_length, 0);
[K		< 	else
[K		< 		os_memcpy(reply->key_length, key->key_length, 2);
[K		< 	os_memcpy(reply->replay_counter, key->replay_counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		<
[K		< 	key_mic = (u8 *) (reply + 1);
[K		< 	WPA_PUT_BE16(key_mic + mic_len, 0);
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Sending EAPOL-Key 4/4");
[K		< 	return wpa_eapol_key_send(sm, ptk, ver, dst, ETH_P_EAPOL, rbuf, rlen,
[K		< 				  key_mic);
[K		< }
[K		<
[K		<
[K		< static void wpa_supplicant_process_3_of_4(struct wpa_sm *sm,
[K		< 					  const struct wpa_eapol_key *key,
[K		< 					  u16 ver, const u8 *key_data,
[K		< 					  size_t key_data_len)
[K		< {
[K		< 	u16 key_info, keylen;
[K		< 	struct wpa_eapol_ie_parse ie;
[K		<
[K		< 	wpa_sm_set_state(sm, WPA_4WAY_HANDSHAKE);
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: RX message 3 of 4-Way "
[K		< 		"Handshake from " MACSTR " (ver=%d)", MAC2STR(sm->bssid), ver);
[K		<
[K		< 	key_info = WPA_GET_BE16(key->key_info);
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: IE KeyData", key_data, key_data_len);
[K		< 	if (wpa_supplicant_parse_ies(key_data, key_data_len, &ie) < 0)
[K		< 		goto failed;
[K		< 	if (ie.gtk && !(key_info & WPA_KEY_INFO_ENCR_KEY_DATA)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: GTK IE in unencrypted key data");
[K		< 		goto failed;
[K		< 	}
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (ie.igtk && !(key_info & WPA_KEY_INFO_ENCR_KEY_DATA)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: IGTK KDE in unencrypted key data");
[K		< 		goto failed;
[K		< 	}
[K		<
[K		< 	if (ie.igtk &&
[K		< 	    wpa_cipher_valid_mgmt_group(sm->mgmt_group_cipher) &&
[K		< 	    ie.igtk_len != WPA_IGTK_KDE_PREFIX_LEN +
[K		< 	    (unsigned int) wpa_cipher_key_len(sm->mgmt_group_cipher)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Invalid IGTK KDE length %lu",
[K		< 			(unsigned long) ie.igtk_len);
[K		< 		goto failed;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211W */
[K		<
[K		< 	if (wpa_supplicant_validate_ie(sm, sm->bssid, &ie) < 0)
[K		< 		goto failed;
[K		<
[K		< 	if (os_memcmp(sm->anonce, key->key_nonce, WPA_NONCE_LEN) != 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: ANonce from message 1 of 4-Way Handshake "
[K		< 			"differs from 3 of 4-Way Handshake - drop packet (src="
[K		< 			MACSTR ")", MAC2STR(sm->bssid));
[K		< 		goto failed;
[K		< 	}
[K		<
[K		< 	keylen = WPA_GET_BE16(key->key_length);
[K		< 	if (keylen != wpa_cipher_key_len(sm->pairwise_cipher)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Invalid %s key length %d (src=" MACSTR
[K		< 			")", wpa_cipher_txt(sm->pairwise_cipher), keylen,
[K		< 			MAC2STR(sm->bssid));
[K		< 		goto failed;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_P2P
[K		< 	if (ie.ip_addr_alloc) {
[K		< 		os_memcpy(sm->p2p_ip_addr, ie.ip_addr_alloc, 3 * 4);
[K		< 		wpa_hexdump(MSG_DEBUG, "P2P: IP address info",
[K		< 			    sm->p2p_ip_addr, sizeof(sm->p2p_ip_addr));
[K		< 	}
[K		< #endif /* CONFIG_P2P */
[K		<
[K		< 	if (wpa_supplicant_send_4_of_4(sm, sm->bssid, key, ver, key_info,
[K		< 				       &sm->ptk) < 0) {
[K		< 		goto failed;
[K		< 	}
[K		<
[K		< 	/* SNonce was successfully used in msg 3/4, so mark it to be renewed
[K		< 	 * for the next 4-Way Handshake. If msg 3 is received again, the old
[K		< 	 * SNonce will still be used to avoid changing PTK. */
[K		< 	sm->renew_snonce = 1;
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_INSTALL) {
[K		< 		if (wpa_supplicant_install_ptk(sm, key))
[K		< 			goto failed;
[K		< 	}
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_SECURE) {
[K		< 		wpa_sm_mlme_setprotection(
[K		< 			sm, sm->bssid, MLME_SETPROTECTION_PROTECT_TYPE_RX,
[K		< 			MLME_SETPROTECTION_KEY_TYPE_PAIRWISE);
[K		< 		eapol_sm_notify_portValid(sm->eapol, TRUE);
[K		< 	}
[K		< 	wpa_sm_set_state(sm, WPA_GROUP_HANDSHAKE);
[K		<
[K		< 	if (sm->group_cipher == WPA_CIPHER_GTK_NOT_USED) {
[K		< 		wpa_supplicant_key_neg_complete(sm, sm->bssid,
[K		< 						key_info & WPA_KEY_INFO_SECURE);
[K		< 	} else if (ie.gtk &&
[K		< 	    wpa_supplicant_pairwise_gtk(sm, key,
[K		< 					ie.gtk, ie.gtk_len, key_info) < 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"RSN: Failed to configure GTK");
[K		< 		goto failed;
[K		< 	}
[K		<
[K		< 	if (ieee80211w_set_keys(sm, &ie) < 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"RSN: Failed to configure IGTK");
[K		< 		goto failed;
[K		< 	}
[K		<
[K		< 	if (ie.gtk)
[K		< 		wpa_sm_set_rekey_offload(sm);
[K		<
[K		< 	if (sm->proto == WPA_PROTO_RSN && wpa_key_mgmt_suite_b(sm->key_mgmt)) {
[K		< 		struct rsn_pmksa_cache_entry *sa;
[K		<
[K		< 		sa = pmksa_cache_add(sm->pmksa, sm->pmk, sm->pmk_len, NULL,
[K		< 				     sm->ptk.kck, sm->ptk.kck_len,
[K		< 				     sm->bssid, sm->own_addr,
[K		< 				     sm->network_ctx, sm->key_mgmt);
[K		< 		if (!sm->cur_pmksa)
[K		< 			sm->cur_pmksa = sa;
[K		< 	}
[K		<
[K		< 	sm->msg_3_of_4_ok = 1;
[K		< 	return;
[K		<
[K		< failed:
[K		< 	wpa_sm_deauthenticate(sm, WLAN_REASON_UNSPECIFIED);
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_process_1_of_2_rsn(struct wpa_sm *sm,
[K		< 					     const u8 *keydata,
[K		< 					     size_t keydatalen,
[K		< 					     u16 key_info,
[K		< 					     struct wpa_gtk_data *gd)
[K		< {
[K		< 	int maxkeylen;
[K		< 	struct wpa_eapol_ie_parse ie;
[K		<
[K		< 	wpa_hexdump_key(MSG_DEBUG, "RSN: msg 1/2 key data",
[K		< 			keydata, keydatalen);
[K		< 	if (wpa_supplicant_parse_ies(keydata, keydatalen, &ie) < 0)
[K		< 		return -1;
[K		< 	if (ie.gtk && !(key_info & WPA_KEY_INFO_ENCR_KEY_DATA)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: GTK IE in unencrypted key data");
[K		< 		return -1;
[K		< 	}
[K		< 	if (ie.gtk == NULL) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: No GTK IE in Group Key msg 1/2");
[K		< 		return -1;
[K		< 	}
[K		< 	maxkeylen = gd->gtk_len = ie.gtk_len - 2;
[K		<
[K		< 	if (wpa_supplicant_check_group_cipher(sm, sm->group_cipher,
[K		< 					      gd->gtk_len, maxkeylen,
[K		< 					      &gd->key_rsc_len, &gd->alg))
[K		< 		return -1;
[K		<
[K		< 	wpa_hexdump_key(MSG_DEBUG, "RSN: received GTK in group key handshake",
[K		< 			ie.gtk, ie.gtk_len);
[K		< 	gd->keyidx = ie.gtk[0] & 0x3;
[K		< 	gd->tx = wpa_supplicant_gtk_tx_bit_workaround(sm,
[K		< 						      !!(ie.gtk[0] & BIT(2)));
[K		< 	if (ie.gtk_len - 2 > sizeof(gd->gtk)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"RSN: Too long GTK in GTK IE (len=%lu)",
[K		< 			(unsigned long) ie.gtk_len - 2);
[K		< 		return -1;
[K		< 	}
[K		< 	os_memcpy(gd->gtk, ie.gtk + 2, ie.gtk_len - 2);
[K		<
[K		< 	if (ieee80211w_set_keys(sm, &ie) < 0)
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"RSN: Failed to configure IGTK");
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_process_1_of_2_wpa(struct wpa_sm *sm,
[K		< 					     const struct wpa_eapol_key *key,
[K		< 					     const u8 *key_data,
[K		< 					     size_t key_data_len, u16 key_info,
[K		< 					     u16 ver, struct wpa_gtk_data *gd)
[K		< {
[K		< 	size_t maxkeylen;
[K		< 	u16 gtk_len;
[K		<
[K		< 	gtk_len = WPA_GET_BE16(key->key_length);
[K		< 	maxkeylen = key_data_len;
[K		< 	if (ver == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
[K		< 		if (maxkeylen < 8) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 				"WPA: Too short maxkeylen (%lu)",
[K		< 				(unsigned long) maxkeylen);
[K		< 			return -1;
[K		< 		}
[K		< 		maxkeylen -= 8;
[K		< 	}
[K		<
[K		< 	if (gtk_len > maxkeylen ||
[K		< 	    wpa_supplicant_check_group_cipher(sm, sm->group_cipher,
[K		< 					      gtk_len, maxkeylen,
[K		< 					      &gd->key_rsc_len, &gd->alg))
[K		< 		return -1;
[K		<
[K		< 	gd->gtk_len = gtk_len;
[K		< 	gd->keyidx = (key_info & WPA_KEY_INFO_KEY_INDEX_MASK) >>
[K		< 		WPA_KEY_INFO_KEY_INDEX_SHIFT;
[K		< 	if (ver == WPA_KEY_INFO_TYPE_HMAC_MD5_RC4 && sm->ptk.kek_len == 16) {
[K		< #ifdef CONFIG_NO_RC4
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: RC4 not supported in the build");
[K		< 		return -1;
[K		< #else /* CONFIG_NO_RC4 */
[K		< 		u8 ek[32];
[K		< 		if (key_data_len > sizeof(gd->gtk)) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: RC4 key data too long (%lu)",
[K		< 				(unsigned long) key_data_len);
[K		< 			return -1;
[K		< 		}
[K		< 		os_memcpy(ek, key->key_iv, 16);
[K		< 		os_memcpy(ek + 16, sm->ptk.kek, sm->ptk.kek_len);
[K		< 		os_memcpy(gd->gtk, key_data, key_data_len);
[K		< 		if (rc4_skip(ek, 32, 256, gd->gtk, key_data_len)) {
[K		< 			os_memset(ek, 0, sizeof(ek));
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_ERROR,
[K		< 				"WPA: RC4 failed");
[K		< 			return -1;
[K		< 		}
[K		< 		os_memset(ek, 0, sizeof(ek));
[K		< #endif /* CONFIG_NO_RC4 */
[K		< 	} else if (ver == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
[K		< 		if (maxkeylen % 8) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Unsupported AES-WRAP len %lu",
[K		< 				(unsigned long) maxkeylen);
[K		< 			return -1;
[K		< 		}
[K		< 		if (maxkeylen > sizeof(gd->gtk)) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: AES-WRAP key data "
[K		< 				"too long (keydatalen=%lu maxkeylen=%lu)",
[K		< 				(unsigned long) key_data_len,
[K		< 				(unsigned long) maxkeylen);
[K		< 			return -1;
[K		< 		}
[K		< 		if (aes_unwrap(sm->ptk.kek, sm->ptk.kek_len, maxkeylen / 8,
[K		< 			       key_data, gd->gtk)) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: AES unwrap failed - could not decrypt "
[K		< 				"GTK");
[K		< 			return -1;
[K		< 		}
[K		< 	} else {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Unsupported key_info type %d", ver);
[K		< 		return -1;
[K		< 	}
[K		< 	gd->tx = wpa_supplicant_gtk_tx_bit_workaround(
[K		< 		sm, !!(key_info & WPA_KEY_INFO_TXRX));
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_send_2_of_2(struct wpa_sm *sm,
[K		< 				      const struct wpa_eapol_key *key,
[K		< 				      int ver, u16 key_info)
[K		< {
[K		< 	size_t mic_len, hdrlen, rlen;
[K		< 	struct wpa_eapol_key *reply;
[K		< 	u8 *rbuf, *key_mic;
[K		<
[K		< 	mic_len = wpa_mic_len(sm->key_mgmt);
[K		< 	hdrlen = sizeof(*reply) + mic_len + 2;
[K		< 	rbuf = wpa_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAPOL_KEY, NULL,
[K		< 				  hdrlen, &rlen, (void *) &reply);
[K		< 	if (rbuf == NULL)
[K		< 		return -1;
[K		<
[K		< 	reply->type = (sm->proto == WPA_PROTO_RSN ||
[K		< 		       sm->proto == WPA_PROTO_OSEN) ?
[K		< 		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
[K		< 	key_info &= WPA_KEY_INFO_KEY_INDEX_MASK;
[K		< 	key_info |= ver | WPA_KEY_INFO_SECURE;
[K		< 	if (mic_len)
[K		< 		key_info |= WPA_KEY_INFO_MIC;
[K		< 	WPA_PUT_BE16(reply->key_info, key_info);
[K		< 	if (sm->proto == WPA_PROTO_RSN || sm->proto == WPA_PROTO_OSEN)
[K		< 		WPA_PUT_BE16(reply->key_length, 0);
[K		< 	else
[K		< 		os_memcpy(reply->key_length, key->key_length, 2);
[K		< 	os_memcpy(reply->replay_counter, key->replay_counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		<
[K		< 	key_mic = (u8 *) (reply + 1);
[K		< 	WPA_PUT_BE16(key_mic + mic_len, 0);
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Sending EAPOL-Key 2/2");
[K		< 	return wpa_eapol_key_send(sm, &sm->ptk, ver, sm->bssid, ETH_P_EAPOL,
[K		< 				  rbuf, rlen, key_mic);
[K		< }
[K		<
[K		<
[K		< static void wpa_supplicant_process_1_of_2(struct wpa_sm *sm,
[K		< 					  const unsigned char *src_addr,
[K		< 					  const struct wpa_eapol_key *key,
[K		< 					  const u8 *key_data,
[K		< 					  size_t key_data_len, u16 ver)
[K		< {
[K		< 	u16 key_info;
[K		< 	int rekey, ret;
[K		< 	struct wpa_gtk_data gd;
[K		< 	const u8 *key_rsc;
[K		<
[K		< 	if (!sm->msg_3_of_4_ok) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: Group Key Handshake started prior to completion of 4-way handshake");
[K		< 		goto failed;
[K		< 	}
[K		<
[K		< 	os_memset(&gd, 0, sizeof(gd));
[K		<
[K		< 	rekey = wpa_sm_get_state(sm) == WPA_COMPLETED;
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: RX message 1 of Group Key "
[K		< 		"Handshake from " MACSTR " (ver=%d)", MAC2STR(src_addr), ver);
[K		<
[K		< 	key_info = WPA_GET_BE16(key->key_info);
[K		<
[K		< 	if (sm->proto == WPA_PROTO_RSN || sm->proto == WPA_PROTO_OSEN) {
[K		< 		ret = wpa_supplicant_process_1_of_2_rsn(sm, key_data,
[K		< 							key_data_len, key_info,
[K		< 							&gd);
[K		< 	} else {
[K		< 		ret = wpa_supplicant_process_1_of_2_wpa(sm, key, key_data,
[K		< 							key_data_len,
[K		< 							key_info, ver, &gd);
[K		< 	}
[K		<
[K		< 	wpa_sm_set_state(sm, WPA_GROUP_HANDSHAKE);
[K		<
[K		< 	if (ret)
[K		< 		goto failed;
[K		<
[K		< 	key_rsc = key->key_rsc;
[K		< 	if (wpa_supplicant_rsc_relaxation(sm, key->key_rsc))
[K		< 		key_rsc = null_rsc;
[K		<
[K		< 	if (wpa_supplicant_install_gtk(sm, &gd, key_rsc) ||
[K		< 	    wpa_supplicant_send_2_of_2(sm, key, ver, key_info) < 0)
[K		< 		goto failed;
[K		< 	os_memset(&gd, 0, sizeof(gd));
[K		<
[K		< 	if (rekey) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO, "WPA: Group rekeying "
[K		< 			"completed with " MACSTR " [GTK=%s]",
[K		< 			MAC2STR(sm->bssid), wpa_cipher_txt(sm->group_cipher));
[K		< 		wpa_sm_cancel_auth_timeout(sm);
[K		< 		wpa_sm_set_state(sm, WPA_COMPLETED);
[K		< 	} else {
[K		< 		wpa_supplicant_key_neg_complete(sm, sm->bssid,
[K		< 						key_info &
[K		< 						WPA_KEY_INFO_SECURE);
[K		< 	}
[K		<
[K		< 	wpa_sm_set_rekey_offload(sm);
[K		<
[K		< 	return;
[K		<
[K		< failed:
[K		< 	os_memset(&gd, 0, sizeof(gd));
[K		< 	wpa_sm_deauthenticate(sm, WLAN_REASON_UNSPECIFIED);
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_verify_eapol_key_mic(struct wpa_sm *sm,
[K		< 					       struct wpa_eapol_key *key,
[K		< 					       u16 ver,
[K		< 					       const u8 *buf, size_t len)
[K		< {
[K		< 	u8 mic[WPA_EAPOL_KEY_MIC_MAX_LEN];
[K		< 	int ok = 0;
[K		< 	size_t mic_len = wpa_mic_len(sm->key_mgmt);
[K		<
[K		< 	os_memcpy(mic, key + 1, mic_len);
[K		< 	if (sm->tptk_set) {
[K		< 		os_memset(key + 1, 0, mic_len);
[K		< 		wpa_eapol_key_mic(sm->tptk.kck, sm->tptk.kck_len, sm->key_mgmt,
[K		< 				  ver, buf, len, (u8 *) (key + 1));
[K		< 		if (os_memcmp_const(mic, key + 1, mic_len) != 0) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Invalid EAPOL-Key MIC "
[K		< 				"when using TPTK - ignoring TPTK");
[K		< 		} else {
[K		< 			ok = 1;
[K		< 			sm->tptk_set = 0;
[K		< 			sm->ptk_set = 1;
[K		< 			os_memcpy(&sm->ptk, &sm->tptk, sizeof(sm->ptk));
[K		< 			os_memset(&sm->tptk, 0, sizeof(sm->tptk));
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (!ok && sm->ptk_set) {
[K		< 		os_memset(key + 1, 0, mic_len);
[K		< 		wpa_eapol_key_mic(sm->ptk.kck, sm->ptk.kck_len, sm->key_mgmt,
[K		< 				  ver, buf, len, (u8 *) (key + 1));
[K		< 		if (os_memcmp_const(mic, key + 1, mic_len) != 0) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Invalid EAPOL-Key MIC - "
[K		< 				"dropping packet");
[K		< 			return -1;
[K		< 		}
[K		< 		ok = 1;
[K		< 	}
[K		<
[K		< 	if (!ok) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Could not verify EAPOL-Key MIC - "
[K		< 			"dropping packet");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	os_memcpy(sm->rx_replay_counter, key->replay_counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		< 	sm->rx_replay_counter_set = 1;
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /* Decrypt RSN EAPOL-Key key data (RC4 or AES-WRAP) */
[K		< static int wpa_supplicant_decrypt_key_data(struct wpa_sm *sm,
[K		< 					   struct wpa_eapol_key *key,
[K		< 					   size_t mic_len, u16 ver,
[K		< 					   u8 *key_data, size_t *key_data_len)
[K		< {
[K		< 	wpa_hexdump(MSG_DEBUG, "RSN: encrypted key data",
[K		< 		    key_data, *key_data_len);
[K		< 	if (!sm->ptk_set) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: PTK not available, cannot decrypt EAPOL-Key Key "
[K		< 			"Data");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	/* Decrypt key data here so that this operation does not need
[K		< 	 * to be implemented separately for each message type. */
[K		< 	if (ver == WPA_KEY_INFO_TYPE_HMAC_MD5_RC4 && sm->ptk.kek_len == 16) {
[K		< #ifdef CONFIG_NO_RC4
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: RC4 not supported in the build");
[K		< 		return -1;
[K		< #else /* CONFIG_NO_RC4 */
[K		< 		u8 ek[32];
[K		< 		os_memcpy(ek, key->key_iv, 16);
[K		< 		os_memcpy(ek + 16, sm->ptk.kek, sm->ptk.kek_len);
[K		< 		if (rc4_skip(ek, 32, 256, key_data, *key_data_len)) {
[K		< 			os_memset(ek, 0, sizeof(ek));
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_ERROR,
[K		< 				"WPA: RC4 failed");
[K		< 			return -1;
[K		< 		}
[K		< 		os_memset(ek, 0, sizeof(ek));
[K		< #endif /* CONFIG_NO_RC4 */
[K		< 	} else if (ver == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES ||
[K		< 		   ver == WPA_KEY_INFO_TYPE_AES_128_CMAC ||
[K		< 		   sm->key_mgmt == WPA_KEY_MGMT_OSEN ||
[K		< 		   wpa_key_mgmt_suite_b(sm->key_mgmt)) {
[K		< 		u8 *buf;
[K		< 		if (*key_data_len < 8 || *key_data_len % 8) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Unsupported AES-WRAP len %u",
[K		< 				(unsigned int) *key_data_len);
[K		< 			return -1;
[K		< 		}
[K		< 		*key_data_len -= 8; /* AES-WRAP adds 8 bytes */
[K		< 		buf = os_malloc(*key_data_len);
[K		< 		if (buf == NULL) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: No memory for AES-UNWRAP buffer");
[K		< 			return -1;
[K		< 		}
[K		< 		if (aes_unwrap(sm->ptk.kek, sm->ptk.kek_len, *key_data_len / 8,
[K		< 			       key_data, buf)) {
[K		< 			bin_clear_free(buf, *key_data_len);
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: AES unwrap failed - "
[K		< 				"could not decrypt EAPOL-Key key data");
[K		< 			return -1;
[K		< 		}
[K		< 		os_memcpy(key_data, buf, *key_data_len);
[K		< 		bin_clear_free(buf, *key_data_len);
[K		< 		WPA_PUT_BE16(((u8 *) (key + 1)) + mic_len, *key_data_len);
[K		< 	} else {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Unsupported key_info type %d", ver);
[K		< 		return -1;
[K		< 	}
[K		< 	wpa_hexdump_key(MSG_DEBUG, "WPA: decrypted EAPOL-Key key data",
[K		< 			key_data, *key_data_len);
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_aborted_cached - Notify WPA that PMKSA caching was aborted
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  */
[K		< void wpa_sm_aborted_cached(struct wpa_sm *sm)
[K		< {
[K		< 	if (sm && sm->cur_pmksa) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"RSN: Cancelling PMKSA caching attempt");
[K		< 		sm->cur_pmksa = NULL;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< static void wpa_eapol_key_dump(struct wpa_sm *sm,
[K		< 			       const struct wpa_eapol_key *key,
[K		< 			       unsigned int key_data_len,
[K		< 			       const u8 *mic, unsigned int mic_len)
[K		< {
[K		< #ifndef CONFIG_NO_STDOUT_DEBUG
[K		< 	u16 key_info = WPA_GET_BE16(key->key_info);
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "  EAPOL-Key type=%d", key->type);
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 		"  key_info 0x%x (ver=%d keyidx=%d rsvd=%d %s%s%s%s%s%s%s%s)",
[K		< 		key_info, key_info & WPA_KEY_INFO_TYPE_MASK,
[K		< 		(key_info & WPA_KEY_INFO_KEY_INDEX_MASK) >>
[K		< 		WPA_KEY_INFO_KEY_INDEX_SHIFT,
[K		< 		(key_info & (BIT(13) | BIT(14) | BIT(15))) >> 13,
[K		< 		key_info & WPA_KEY_INFO_KEY_TYPE ? "Pairwise" : "Group",
[K		< 		key_info & WPA_KEY_INFO_INSTALL ? " Install" : "",
[K		< 		key_info & WPA_KEY_INFO_ACK ? " Ack" : "",
[K		< 		key_info & WPA_KEY_INFO_MIC ? " MIC" : "",
[K		< 		key_info & WPA_KEY_INFO_SECURE ? " Secure" : "",
[K		< 		key_info & WPA_KEY_INFO_ERROR ? " Error" : "",
[K		< 		key_info & WPA_KEY_INFO_REQUEST ? " Request" : "",
[K		< 		key_info & WPA_KEY_INFO_ENCR_KEY_DATA ? " Encr" : "");
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 		"  key_length=%u key_data_length=%u",
[K		< 		WPA_GET_BE16(key->key_length), key_data_len);
[K		< 	wpa_hexdump(MSG_DEBUG, "  replay_counter",
[K		< 		    key->replay_counter, WPA_REPLAY_COUNTER_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "  key_nonce", key->key_nonce, WPA_NONCE_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "  key_iv", key->key_iv, 16);
[K		< 	wpa_hexdump(MSG_DEBUG, "  key_rsc", key->key_rsc, 8);
[K		< 	wpa_hexdump(MSG_DEBUG, "  key_id (reserved)", key->key_id, 8);
[K		< 	wpa_hexdump(MSG_DEBUG, "  key_mic", mic, mic_len);
[K		< #endif /* CONFIG_NO_STDOUT_DEBUG */
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_FILS
[K		< static int wpa_supp_aead_decrypt(struct wpa_sm *sm, u8 *buf, size_t buf_len,
[K		< 				 size_t *key_data_len)
[K		< {
[K		< 	struct wpa_ptk *ptk;
[K		< 	struct ieee802_1x_hdr *hdr;
[K		< 	struct wpa_eapol_key *key;
[K		< 	u8 *pos, *tmp;
[K		< 	const u8 *aad[1];
[K		< 	size_t aad_len[1];
[K		<
[K		< 	if (*key_data_len < AES_BLOCK_SIZE) {
[K		< 		wpa_printf(MSG_INFO, "No room for AES-SIV data in the frame");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (sm->tptk_set)
[K		< 		ptk = &sm->tptk;
[K		< 	else if (sm->ptk_set)
[K		< 		ptk = &sm->ptk;
[K		< 	else
[K		< 		return -1;
[K		<
[K		< 	hdr = (struct ieee802_1x_hdr *) buf;
[K		< 	key = (struct wpa_eapol_key *) (hdr + 1);
[K		< 	pos = (u8 *) (key + 1);
[K		< 	pos += 2; /* Pointing at the Encrypted Key Data field */
[K		<
[K		< 	tmp = os_malloc(*key_data_len);
[K		< 	if (!tmp)
[K		< 		return -1;
[K		<
[K		< 	/* AES-SIV AAD from EAPOL protocol version field (inclusive) to
[K		< 	 * to Key Data (exclusive). */
[K		< 	aad[0] = buf;
[K		< 	aad_len[0] = pos - buf;
[K		< 	if (aes_siv_decrypt(ptk->kek, ptk->kek_len, pos, *key_data_len,
[K		< 			    1, aad, aad_len, tmp) < 0) {
[K		< 		wpa_printf(MSG_INFO, "Invalid AES-SIV data in the frame");
[K		< 		bin_clear_free(tmp, *key_data_len);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	/* AEAD decryption and validation completed successfully */
[K		< 	(*key_data_len) -= AES_BLOCK_SIZE;
[K		< 	wpa_hexdump_key(MSG_DEBUG, "WPA: Decrypted Key Data",
[K		< 			tmp, *key_data_len);
[K		<
[K		< 	/* Replace Key Data field with the decrypted version */
[K		< 	os_memcpy(pos, tmp, *key_data_len);
[K		< 	pos -= 2; /* Key Data Length field */
[K		< 	WPA_PUT_BE16(pos, *key_data_len);
[K		< 	bin_clear_free(tmp, *key_data_len);
[K		<
[K		< 	if (sm->tptk_set) {
[K		< 		sm->tptk_set = 0;
[K		< 		sm->ptk_set = 1;
[K		< 		os_memcpy(&sm->ptk, &sm->tptk, sizeof(sm->ptk));
[K		< 		os_memset(&sm->tptk, 0, sizeof(sm->tptk));
[K		< 	}
[K		<
[K		< 	os_memcpy(sm->rx_replay_counter, key->replay_counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		< 	sm->rx_replay_counter_set = 1;
[K		<
[K		< 	return 0;
[K		< }
[K		< #endif /* CONFIG_FILS */
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_rx_eapol - Process received WPA EAPOL frames
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @src_addr: Source MAC address of the EAPOL packet
[K		<  * @buf: Pointer to the beginning of the EAPOL data (EAPOL header)
[K		<  * @len: Length of the EAPOL frame
[K		<  * Returns: 1 = WPA EAPOL-Key processed, 0 = not a WPA EAPOL-Key, -1 failure
[K		<  *
[K		<  * This function is called for each received EAPOL frame. Other than EAPOL-Key
[K		<  * frames can be skipped if filtering is done elsewhere. wpa_sm_rx_eapol() is
[K		<  * only processing WPA and WPA2 EAPOL-Key frames.
[K		<  *
[K		<  * The received EAPOL-Key packets are validated and valid packets are replied
[K		<  * to. In addition, key material (PTK, GTK) is configured at the end of a
[K		<  * successful key handshake.
[K		<  */
[K		< int wpa_sm_rx_eapol(struct wpa_sm *sm, const u8 *src_addr,
[K		< 		    const u8 *buf, size_t len)
[K		< {
[K		< 	size_t plen, data_len, key_data_len;
[K		< 	const struct ieee802_1x_hdr *hdr;
[K		< 	struct wpa_eapol_key *key;
[K		< 	u16 key_info, ver;
[K		< 	u8 *tmp = NULL;
[K		< 	int ret = -1;
[K		< 	struct wpa_peerkey *peerkey = NULL;
[K		< 	u8 *mic, *key_data;
[K		< 	size_t mic_len, keyhdrlen;
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	sm->ft_completed = 0;
[K		< #endif /* CONFIG_IEEE80211R */
[K		<
[K		< 	mic_len = wpa_mic_len(sm->key_mgmt);
[K		< 	keyhdrlen = sizeof(*key) + mic_len + 2;
[K		<
[K		< 	if (len < sizeof(*hdr) + keyhdrlen) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: EAPOL frame too short to be a WPA "
[K		< 			"EAPOL-Key (len %lu, expecting at least %lu)",
[K		< 			(unsigned long) len,
[K		< 			(unsigned long) sizeof(*hdr) + keyhdrlen);
[K		< 		return 0;
[K		< 	}
[K		<
[K		< 	hdr = (const struct ieee802_1x_hdr *) buf;
[K		< 	plen = be_to_host16(hdr->length);
[K		< 	data_len = plen + sizeof(*hdr);
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 		"IEEE 802.1X RX: version=%d type=%d length=%lu",
[K		< 		hdr->version, hdr->type, (unsigned long) plen);
[K		<
[K		< 	if (hdr->version < EAPOL_VERSION) {
[K		< 		/* TODO: backwards compatibility */
[K		< 	}
[K		< 	if (hdr->type != IEEE802_1X_TYPE_EAPOL_KEY) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: EAPOL frame (type %u) discarded, "
[K		< 			"not a Key frame", hdr->type);
[K		< 		ret = 0;
[K		< 		goto out;
[K		< 	}
[K		< 	wpa_hexdump(MSG_MSGDUMP, "WPA: RX EAPOL-Key", buf, len);
[K		< 	if (plen > len - sizeof(*hdr) || plen < keyhdrlen) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: EAPOL frame payload size %lu "
[K		< 			"invalid (frame size %lu)",
[K		< 			(unsigned long) plen, (unsigned long) len);
[K		< 		ret = 0;
[K		< 		goto out;
[K		< 	}
[K		< 	if (data_len < len) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: ignoring %lu bytes after the IEEE 802.1X data",
[K		< 			(unsigned long) len - data_len);
[K		< 	}
[K		<
[K		< 	/*
[K		< 	 * Make a copy of the frame since we need to modify the buffer during
[K		< 	 * MAC validation and Key Data decryption.
[K		< 	 */
[K		< 	tmp = os_malloc(data_len);
[K		< 	if (tmp == NULL)
[K		< 		goto out;
[K		< 	os_memcpy(tmp, buf, data_len);
[K		< 	key = (struct wpa_eapol_key *) (tmp + sizeof(struct ieee802_1x_hdr));
[K		< 	mic = (u8 *) (key + 1);
[K		< 	key_data = mic + mic_len + 2;
[K		<
[K		< 	if (key->type != EAPOL_KEY_TYPE_WPA && key->type != EAPOL_KEY_TYPE_RSN)
[K		< 	{
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: EAPOL-Key type (%d) unknown, discarded",
[K		< 			key->type);
[K		< 		ret = 0;
[K		< 		goto out;
[K		< 	}
[K		<
[K		< 	key_data_len = WPA_GET_BE16(mic + mic_len);
[K		< 	wpa_eapol_key_dump(sm, key, key_data_len, mic, mic_len);
[K		<
[K		< 	if (key_data_len > plen - keyhdrlen) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO, "WPA: Invalid EAPOL-Key "
[K		< 			"frame - key_data overflow (%u > %u)",
[K		< 			(unsigned int) key_data_len,
[K		< 			(unsigned int) (plen - keyhdrlen));
[K		< 		goto out;
[K		< 	}
[K		<
[K		< 	eapol_sm_notify_lower_layer_success(sm->eapol, 0);
[K		< 	key_info = WPA_GET_BE16(key->key_info);
[K		< 	ver = key_info & WPA_KEY_INFO_TYPE_MASK;
[K		< 	if (ver != WPA_KEY_INFO_TYPE_HMAC_MD5_RC4 &&
[K		< #if defined(CONFIG_IEEE80211R) || defined(CONFIG_IEEE80211W)
[K		< 	    ver != WPA_KEY_INFO_TYPE_AES_128_CMAC &&
[K		< #endif /* CONFIG_IEEE80211R || CONFIG_IEEE80211W */
[K		< 	    ver != WPA_KEY_INFO_TYPE_HMAC_SHA1_AES &&
[K		< 	    !wpa_key_mgmt_suite_b(sm->key_mgmt) &&
[K		< 	    !wpa_key_mgmt_fils(sm->key_mgmt) &&
[K		< 	    sm->key_mgmt != WPA_KEY_MGMT_OSEN) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: Unsupported EAPOL-Key descriptor version %d",
[K		< 			ver);
[K		< 		goto out;
[K		< 	}
[K		<
[K		< 	if (sm->key_mgmt == WPA_KEY_MGMT_OSEN &&
[K		< 	    ver != WPA_KEY_INFO_TYPE_AKM_DEFINED) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"OSEN: Unsupported EAPOL-Key descriptor version %d",
[K		< 			ver);
[K		< 		goto out;
[K		< 	}
[K		<
[K		< 	if ((wpa_key_mgmt_suite_b(sm->key_mgmt) ||
[K		< 	     wpa_key_mgmt_fils(sm->key_mgmt)) &&
[K		< 	    ver != WPA_KEY_INFO_TYPE_AKM_DEFINED) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"RSN: Unsupported EAPOL-Key descriptor version %d (expected AKM defined = 0)",
[K		< 			ver);
[K		< 		goto out;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	if (wpa_key_mgmt_ft(sm->key_mgmt)) {
[K		< 		/* IEEE 802.11r uses a new key_info type (AES-128-CMAC). */
[K		< 		if (ver != WPA_KEY_INFO_TYPE_AES_128_CMAC) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 				"FT: AP did not use AES-128-CMAC");
[K		< 			goto out;
[K		< 		}
[K		< 	} else
[K		< #endif /* CONFIG_IEEE80211R */
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (wpa_key_mgmt_sha256(sm->key_mgmt)) {
[K		< 		if (ver != WPA_KEY_INFO_TYPE_AES_128_CMAC &&
[K		< 		    sm->key_mgmt != WPA_KEY_MGMT_OSEN &&
[K		< 		    !wpa_key_mgmt_fils(sm->key_mgmt) &&
[K		< 		    !wpa_key_mgmt_suite_b(sm->key_mgmt)) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 				"WPA: AP did not use the "
[K		< 				"negotiated AES-128-CMAC");
[K		< 			goto out;
[K		< 		}
[K		< 	} else
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	if (sm->pairwise_cipher == WPA_CIPHER_CCMP &&
[K		< 	    !wpa_key_mgmt_suite_b(sm->key_mgmt) &&
[K		< 	    !wpa_key_mgmt_fils(sm->key_mgmt) &&
[K		< 	    ver != WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: CCMP is used, but EAPOL-Key "
[K		< 			"descriptor version (%d) is not 2", ver);
[K		< 		if (sm->group_cipher != WPA_CIPHER_CCMP &&
[K		< 		    !(key_info & WPA_KEY_INFO_KEY_TYPE)) {
[K		< 			/* Earlier versions of IEEE 802.11i did not explicitly
[K		< 			 * require version 2 descriptor for all EAPOL-Key
[K		< 			 * packets, so allow group keys to use version 1 if
[K		< 			 * CCMP is not used for them. */
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 				"WPA: Backwards compatibility: allow invalid "
[K		< 				"version for non-CCMP group keys");
[K		< 		} else if (ver == WPA_KEY_INFO_TYPE_AES_128_CMAC) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 				"WPA: Interoperability workaround: allow incorrect (should have been HMAC-SHA1), but stronger (is AES-128-CMAC), descriptor version to be used");
[K		< 		} else
[K		< 			goto out;
[K		< 	} else if (sm->pairwise_cipher == WPA_CIPHER_GCMP &&
[K		< 		   !wpa_key_mgmt_suite_b(sm->key_mgmt) &&
[K		< 		   ver != WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: GCMP is used, but EAPOL-Key "
[K		< 			"descriptor version (%d) is not 2", ver);
[K		< 		goto out;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_PEERKEY
[K		< 	for (peerkey = sm->peerkey; peerkey; peerkey = peerkey->next) {
[K		< 		if (os_memcmp(peerkey->addr, src_addr, ETH_ALEN) == 0)
[K		< 			break;
[K		< 	}
[K		<
[K		< 	if (!(key_info & WPA_KEY_INFO_SMK_MESSAGE) && peerkey) {
[K		< 		if (!peerkey->initiator && peerkey->replay_counter_set &&
[K		< 		    os_memcmp(key->replay_counter, peerkey->replay_counter,
[K		< 			      WPA_REPLAY_COUNTER_LEN) <= 0) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"RSN: EAPOL-Key Replay Counter did not "
[K		< 				"increase (STK) - dropping packet");
[K		< 			goto out;
[K		< 		} else if (peerkey->initiator) {
[K		< 			u8 _tmp[WPA_REPLAY_COUNTER_LEN];
[K		< 			os_memcpy(_tmp, key->replay_counter,
[K		< 				  WPA_REPLAY_COUNTER_LEN);
[K		< 			inc_byte_array(_tmp, WPA_REPLAY_COUNTER_LEN);
[K		< 			if (os_memcmp(_tmp, peerkey->replay_counter,
[K		< 				      WPA_REPLAY_COUNTER_LEN) != 0) {
[K		< 				wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 					"RSN: EAPOL-Key Replay "
[K		< 					"Counter did not match (STK) - "
[K		< 					"dropping packet");
[K		< 				goto out;
[K		< 			}
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (peerkey && peerkey->initiator && (key_info & WPA_KEY_INFO_ACK)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"RSN: Ack bit in key_info from STK peer");
[K		< 		goto out;
[K		< 	}
[K		< #endif /* CONFIG_PEERKEY */
[K		<
[K		< 	if (!peerkey && sm->rx_replay_counter_set &&
[K		< 	    os_memcmp(key->replay_counter, sm->rx_replay_counter,
[K		< 		      WPA_REPLAY_COUNTER_LEN) <= 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: EAPOL-Key Replay Counter did not increase - "
[K		< 			"dropping packet");
[K		< 		goto out;
[K		< 	}
[K		<
[K		< 	if (!(key_info & (WPA_KEY_INFO_ACK | WPA_KEY_INFO_SMK_MESSAGE))
[K		< #ifdef CONFIG_PEERKEY
[K		< 	    && (peerkey == NULL || !peerkey->initiator)
[K		< #endif /* CONFIG_PEERKEY */
[K		< 		) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: No Ack bit in key_info");
[K		< 		goto out;
[K		< 	}
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_REQUEST) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: EAPOL-Key with Request bit - dropped");
[K		< 		goto out;
[K		< 	}
[K		<
[K		< 	if ((key_info & WPA_KEY_INFO_MIC) && !peerkey &&
[K		< 	    wpa_supplicant_verify_eapol_key_mic(sm, key, ver, tmp, data_len))
[K		< 		goto out;
[K		<
[K		< #ifdef CONFIG_PEERKEY
[K		< 	if ((key_info & WPA_KEY_INFO_MIC) && peerkey &&
[K		< 	    peerkey_verify_eapol_key_mic(sm, peerkey, key, ver, tmp,
[K		< 					 data_len))
[K		< 		goto out;
[K		< #endif /* CONFIG_PEERKEY */
[K		<
[K		< #ifdef CONFIG_FILS
[K		< 	if (!mic_len && (key_info & WPA_KEY_INFO_ENCR_KEY_DATA)) {
[K		< 		if (wpa_supp_aead_decrypt(sm, tmp, data_len, &key_data_len))
[K		< 			goto out;
[K		< 	}
[K		< #endif /* CONFIG_FILS */
[K		<
[K		< 	if ((sm->proto == WPA_PROTO_RSN || sm->proto == WPA_PROTO_OSEN) &&
[K		< 	    (key_info & WPA_KEY_INFO_ENCR_KEY_DATA) && mic_len) {
[K		< 		if (wpa_supplicant_decrypt_key_data(sm, key, mic_len,
[K		< 						    ver, key_data,
[K		< 						    &key_data_len))
[K		< 			goto out;
[K		< 	}
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_KEY_TYPE) {
[K		< 		if (key_info & WPA_KEY_INFO_KEY_INDEX_MASK) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Ignored EAPOL-Key (Pairwise) with "
[K		< 				"non-zero key index");
[K		< 			goto out;
[K		< 		}
[K		< 		if (peerkey) {
[K		< 			/* PeerKey 4-Way Handshake */
[K		< 			peerkey_rx_eapol_4way(sm, peerkey, key, key_info, ver,
[K		< 					      key_data, key_data_len);
[K		< 		} else if (key_info & (WPA_KEY_INFO_MIC |
[K		< 				       WPA_KEY_INFO_ENCR_KEY_DATA)) {
[K		< 			/* 3/4 4-Way Handshake */
[K		< 			wpa_supplicant_process_3_of_4(sm, key, ver, key_data,
[K		< 						      key_data_len);
[K		< 		} else {
[K		< 			/* 1/4 4-Way Handshake */
[K		< 			wpa_supplicant_process_1_of_4(sm, src_addr, key,
[K		< 						      ver, key_data,
[K		< 						      key_data_len);
[K		< 		}
[K		< 	} else if (key_info & WPA_KEY_INFO_SMK_MESSAGE) {
[K		< 		/* PeerKey SMK Handshake */
[K		< 		peerkey_rx_eapol_smk(sm, src_addr, key, key_data, key_data_len,
[K		< 				     key_info, ver);
[K		< 	} else {
[K		< 		if ((mic_len && (key_info & WPA_KEY_INFO_MIC)) ||
[K		< 		    (!mic_len && (key_info & WPA_KEY_INFO_ENCR_KEY_DATA))) {
[K		< 			/* 1/2 Group Key Handshake */
[K		< 			wpa_supplicant_process_1_of_2(sm, src_addr, key,
[K		< 						      key_data, key_data_len,
[K		< 						      ver);
[K		< 		} else {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: EAPOL-Key (Group) without Mic/Encr bit - "
[K		< 				"dropped");
[K		< 		}
[K		< 	}
[K		<
[K		< 	ret = 1;
[K		<
[K		< out:
[K		< 	bin_clear_free(tmp, data_len);
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_CTRL_IFACE
[K		< static u32 wpa_key_mgmt_suite(struct wpa_sm *sm)
[K		< {
[K		< 	switch (sm->key_mgmt) {
[K		< 	case WPA_KEY_MGMT_IEEE8021X:
[K		< 		return ((sm->proto == WPA_PROTO_RSN ||
[K		< 			 sm->proto == WPA_PROTO_OSEN) ?
[K		< 			RSN_AUTH_KEY_MGMT_UNSPEC_802_1X :
[K		< 			WPA_AUTH_KEY_MGMT_UNSPEC_802_1X);
[K		< 	case WPA_KEY_MGMT_PSK:
[K		< 		return (sm->proto == WPA_PROTO_RSN ?
[K		< 			RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X :
[K		< 			WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X);
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	case WPA_KEY_MGMT_FT_IEEE8021X:
[K		< 		return RSN_AUTH_KEY_MGMT_FT_802_1X;
[K		< 	case WPA_KEY_MGMT_FT_PSK:
[K		< 		return RSN_AUTH_KEY_MGMT_FT_PSK;
[K		< #endif /* CONFIG_IEEE80211R */
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	case WPA_KEY_MGMT_IEEE8021X_SHA256:
[K		< 		return RSN_AUTH_KEY_MGMT_802_1X_SHA256;
[K		< 	case WPA_KEY_MGMT_PSK_SHA256:
[K		< 		return RSN_AUTH_KEY_MGMT_PSK_SHA256;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	case WPA_KEY_MGMT_CCKM:
[K		< 		return (sm->proto == WPA_PROTO_RSN ?
[K		< 			RSN_AUTH_KEY_MGMT_CCKM:
[K		< 			WPA_AUTH_KEY_MGMT_CCKM);
[K		< 	case WPA_KEY_MGMT_WPA_NONE:
[K		< 		return WPA_AUTH_KEY_MGMT_NONE;
[K		< 	case WPA_KEY_MGMT_IEEE8021X_SUITE_B:
[K		< 		return RSN_AUTH_KEY_MGMT_802_1X_SUITE_B;
[K		< 	case WPA_KEY_MGMT_IEEE8021X_SUITE_B_192:
[K		< 		return RSN_AUTH_KEY_MGMT_802_1X_SUITE_B_192;
[K		< 	default:
[K		< 		return 0;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< #define RSN_SUITE "%02x-%02x-%02x-%d"
[K		< #define RSN_SUITE_ARG(s) \
[K		< ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
[K		<
[K		< /**
[K		<  * wpa_sm_get_mib - Dump text list of MIB entries
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @buf: Buffer for the list
[K		<  * @buflen: Length of the buffer
[K		<  * Returns: Number of bytes written to buffer
[K		<  *
[K		<  * This function is used fetch dot11 MIB variables.
[K		<  */
[K		< int wpa_sm_get_mib(struct wpa_sm *sm, char *buf, size_t buflen)
[K		< {
[K		< 	char pmkid_txt[PMKID_LEN * 2 + 1];
[K		< 	int rsna, ret;
[K		< 	size_t len;
[K		<
[K		< 	if (sm->cur_pmksa) {
[K		< 		wpa_snprintf_hex(pmkid_txt, sizeof(pmkid_txt),
[K		< 				 sm->cur_pmksa->pmkid, PMKID_LEN);
[K		< 	} else
[K		< 		pmkid_txt[0] = '\0';
[K		<
[K		< 	if ((wpa_key_mgmt_wpa_psk(sm->key_mgmt) ||
[K		< 	     wpa_key_mgmt_wpa_ieee8021x(sm->key_mgmt)) &&
[K		< 	    sm->proto == WPA_PROTO_RSN)
[K		< 		rsna = 1;
[K		< 	else
[K		< 		rsna = 0;
[K		<
[K		< 	ret = os_snprintf(buf, buflen,
[K		< 			  "dot11RSNAOptionImplemented=TRUE\n"
[K		< 			  "dot11RSNAPreauthenticationImplemented=TRUE\n"
[K		< 			  "dot11RSNAEnabled=%s\n"
[K		< 			  "dot11RSNAPreauthenticationEnabled=%s\n"
[K		< 			  "dot11RSNAConfigVersion=%d\n"
[K		< 			  "dot11RSNAConfigPairwiseKeysSupported=5\n"
[K		< 			  "dot11RSNAConfigGroupCipherSize=%d\n"
[K		< 			  "dot11RSNAConfigPMKLifetime=%d\n"
[K		< 			  "dot11RSNAConfigPMKReauthThreshold=%d\n"
[K		< 			  "dot11RSNAConfigNumberOfPTKSAReplayCounters=1\n"
[K		< 			  "dot11RSNAConfigSATimeout=%d\n",
[K		< 			  rsna ? "TRUE" : "FALSE",
[K		< 			  rsna ? "TRUE" : "FALSE",
[K		< 			  RSN_VERSION,
[K		< 			  wpa_cipher_key_len(sm->group_cipher) * 8,
[K		< 			  sm->dot11RSNAConfigPMKLifetime,
[K		< 			  sm->dot11RSNAConfigPMKReauthThreshold,
[K		< 			  sm->dot11RSNAConfigSATimeout);
[K		< 	if (os_snprintf_error(buflen, ret))
[K		< 		return 0;
[K		< 	len = ret;
[K		<
[K		< 	ret = os_snprintf(
[K		< 		buf + len, buflen - len,
[K		< 		"dot11RSNAAuthenticationSuiteSelected=" RSN_SUITE "\n"
[K		< 		"dot11RSNAPairwiseCipherSelected=" RSN_SUITE "\n"
[K		< 		"dot11RSNAGroupCipherSelected=" RSN_SUITE "\n"
[K		< 		"dot11RSNAPMKIDUsed=%s\n"
[K		< 		"dot11RSNAAuthenticationSuiteRequested=" RSN_SUITE "\n"
[K		< 		"dot11RSNAPairwiseCipherRequested=" RSN_SUITE "\n"
[K		< 		"dot11RSNAGroupCipherRequested=" RSN_SUITE "\n"
[K		< 		"dot11RSNAConfigNumberOfGTKSAReplayCounters=0\n"
[K		< 		"dot11RSNA4WayHandshakeFailures=%u\n",
[K		< 		RSN_SUITE_ARG(wpa_key_mgmt_suite(sm)),
[K		< 		RSN_SUITE_ARG(wpa_cipher_to_suite(sm->proto,
[K		< 						  sm->pairwise_cipher)),
[K		< 		RSN_SUITE_ARG(wpa_cipher_to_suite(sm->proto,
[K		< 						  sm->group_cipher)),
[K		< 		pmkid_txt,
[K		< 		RSN_SUITE_ARG(wpa_key_mgmt_suite(sm)),
[K		< 		RSN_SUITE_ARG(wpa_cipher_to_suite(sm->proto,
[K		< 						  sm->pairwise_cipher)),
[K		< 		RSN_SUITE_ARG(wpa_cipher_to_suite(sm->proto,
[K		< 						  sm->group_cipher)),
[K		< 		sm->dot11RSNA4WayHandshakeFailures);
[K		< 	if (!os_snprintf_error(buflen - len, ret))
[K		< 		len += ret;
[K		<
[K		< 	return (int) len;
[K		< }
[K		< #endif /* CONFIG_CTRL_IFACE */
[K		<
[K		<
[K		< static void wpa_sm_pmksa_free_cb(struct rsn_pmksa_cache_entry *entry,
[K		< 				 void *ctx, enum pmksa_free_reason reason)
[K		< {
[K		< 	struct wpa_sm *sm = ctx;
[K		< 	int deauth = 0;
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "RSN: PMKSA cache entry free_cb: "
[K		< 		MACSTR " reason=%d", MAC2STR(entry->aa), reason);
[K		<
[K		< 	if (sm->cur_pmksa == entry) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"RSN: %s current PMKSA entry",
[K		< 			reason == PMKSA_REPLACE ? "replaced" : "removed");
[K		< 		pmksa_cache_clear_current(sm);
[K		<
[K		< 		/*
[K		< 		 * If an entry is simply being replaced, there's no need to
[K		< 		 * deauthenticate because it will be immediately re-added.
[K		< 		 * This happens when EAP authentication is completed again
[K		< 		 * (reauth or failed PMKSA caching attempt).
[K		< 		 */
[K		< 		if (reason != PMKSA_REPLACE)
[K		< 			deauth = 1;
[K		< 	}
[K		<
[K		< 	if (reason == PMKSA_EXPIRE &&
[K		< 	    (sm->pmk_len == entry->pmk_len &&
[K		< 	     os_memcmp(sm->pmk, entry->pmk, sm->pmk_len) == 0)) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"RSN: deauthenticating due to expired PMK");
[K		< 		pmksa_cache_clear_current(sm);
[K		< 		deauth = 1;
[K		< 	}
[K		<
[K		< 	if (deauth) {
[K		< 		os_memset(sm->pmk, 0, sizeof(sm->pmk));
[K		< 		wpa_sm_deauthenticate(sm, WLAN_REASON_UNSPECIFIED);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_init - Initialize WPA state machine
[K		<  * @ctx: Context pointer for callbacks; this needs to be an allocated buffer
[K		<  * Returns: Pointer to the allocated WPA state machine data
[K		<  *
[K		<  * This function is used to allocate a new WPA state machine and the returned
[K		<  * value is passed to all WPA state machine calls.
[K		<  */
[K		< struct wpa_sm * wpa_sm_init(struct wpa_sm_ctx *ctx)
[K		< {
[K		< 	struct wpa_sm *sm;
[K		<
[K		< 	sm = os_zalloc(sizeof(*sm));
[K		< 	if (sm == NULL)
[K		< 		return NULL;
[K		< 	dl_list_init(&sm->pmksa_candidates);
[K		< 	sm->renew_snonce = 1;
[K		< 	sm->ctx = ctx;
[K		<
[K		< 	sm->dot11RSNAConfigPMKLifetime = 43200;
[K		< 	sm->dot11RSNAConfigPMKReauthThreshold = 70;
[K		< 	sm->dot11RSNAConfigSATimeout = 60;
[K		<
[K		< 	sm->pmksa = pmksa_cache_init(wpa_sm_pmksa_free_cb, sm, sm);
[K		< 	if (sm->pmksa == NULL) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_ERROR,
[K		< 			"RSN: PMKSA cache initialization failed");
[K		< 		os_free(sm);
[K		< 		return NULL;
[K		< 	}
[K		<
[K		< 	return sm;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_deinit - Deinitialize WPA state machine
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  */
[K		< void wpa_sm_deinit(struct wpa_sm *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		< 	pmksa_cache_deinit(sm->pmksa);
[K		< 	eloop_cancel_timeout(wpa_sm_start_preauth, sm, NULL);
[K		< 	eloop_cancel_timeout(wpa_sm_rekey_ptk, sm, NULL);
[K		< 	os_free(sm->assoc_wpa_ie);
[K		< 	os_free(sm->ap_wpa_ie);
[K		< 	os_free(sm->ap_rsn_ie);
[K		< 	wpa_sm_drop_sa(sm);
[K		< 	os_free(sm->ctx);
[K		< 	peerkey_deinit(sm);
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	os_free(sm->assoc_resp_ies);
[K		< #endif /* CONFIG_IEEE80211R */
[K		< #ifdef CONFIG_TESTING_OPTIONS
[K		< 	wpabuf_free(sm->test_assoc_ie);
[K		< #endif /* CONFIG_TESTING_OPTIONS */
[K		< 	os_free(sm);
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_notify_assoc - Notify WPA state machine about association
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @bssid: The BSSID of the new association
[K		<  *
[K		<  * This function is called to let WPA state machine know that the connection
[K		<  * was established.
[K		<  */
[K		< void wpa_sm_notify_assoc(struct wpa_sm *sm, const u8 *bssid)
[K		< {
[K		< 	int clear_ptk = 1;
[K		<
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 		"WPA: Association event - clear replay counter");
[K		< 	os_memcpy(sm->bssid, bssid, ETH_ALEN);
[K		< 	os_memset(sm->rx_replay_counter, 0, WPA_REPLAY_COUNTER_LEN);
[K		< 	sm->rx_replay_counter_set = 0;
[K		< 	sm->renew_snonce = 1;
[K		< 	if (os_memcmp(sm->preauth_bssid, bssid, ETH_ALEN) == 0)
[K		< 		rsn_preauth_deinit(sm);
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	if (wpa_ft_is_completed(sm)) {
[K		< 		/*
[K		< 		 * Clear portValid to kick EAPOL state machine to re-enter
[K		< 		 * AUTHENTICATED state to get the EAPOL port Authorized.
[K		< 		 */
[K		< 		eapol_sm_notify_portValid(sm->eapol, FALSE);
[K		< 		wpa_supplicant_key_neg_complete(sm, sm->bssid, 1);
[K		<
[K		< 		/* Prepare for the next transition */
[K		< 		wpa_ft_prepare_auth_request(sm, NULL);
[K		<
[K		< 		clear_ptk = 0;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R */
[K		< #ifdef CONFIG_FILS
[K		< 	if (sm->fils_completed) {
[K		< 		/*
[K		< 		 * Clear portValid to kick EAPOL state machine to re-enter
[K		< 		 * AUTHENTICATED state to get the EAPOL port Authorized.
[K		< 		 */
[K		< 		wpa_supplicant_key_neg_complete(sm, sm->bssid, 1);
[K		< 		clear_ptk = 0;
[K		< 	}
[K		< #endif /* CONFIG_FILS */
[K		<
[K		< 	if (clear_ptk) {
[K		< 		/*
[K		< 		 * IEEE 802.11, 8.4.10: Delete PTK SA on (re)association if
[K		< 		 * this is not part of a Fast BSS Transition.
[K		< 		 */
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Clear old PTK");
[K		< 		sm->ptk_set = 0;
[K		< 		os_memset(&sm->ptk, 0, sizeof(sm->ptk));
[K		< 		sm->tptk_set = 0;
[K		< 		os_memset(&sm->tptk, 0, sizeof(sm->tptk));
[K		< 	}
[K		<
[K		< #ifdef CONFIG_TDLS
[K		< 	wpa_tdls_assoc(sm);
[K		< #endif /* CONFIG_TDLS */
[K		<
[K		< #ifdef CONFIG_P2P
[K		< 	os_memset(sm->p2p_ip_addr, 0, sizeof(sm->p2p_ip_addr));
[K		< #endif /* CONFIG_P2P */
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_notify_disassoc - Notify WPA state machine about disassociation
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  *
[K		<  * This function is called to let WPA state machine know that the connection
[K		<  * was lost. This will abort any existing pre-authentication session.
[K		<  */
[K		< void wpa_sm_notify_disassoc(struct wpa_sm *sm)
[K		< {
[K		< 	eloop_cancel_timeout(wpa_sm_start_preauth, sm, NULL);
[K		< 	eloop_cancel_timeout(wpa_sm_rekey_ptk, sm, NULL);
[K		< 	peerkey_deinit(sm);
[K		< 	rsn_preauth_deinit(sm);
[K		< 	pmksa_cache_clear_current(sm);
[K		< 	if (wpa_sm_get_state(sm) == WPA_4WAY_HANDSHAKE)
[K		< 		sm->dot11RSNA4WayHandshakeFailures++;
[K		< #ifdef CONFIG_TDLS
[K		< 	wpa_tdls_disassoc(sm);
[K		< #endif /* CONFIG_TDLS */
[K		< #ifdef CONFIG_FILS
[K		< 	sm->fils_completed = 0;
[K		< #endif /* CONFIG_FILS */
[K		<
[K		< 	/* Keys are not needed in the WPA state machine anymore */
[K		< 	wpa_sm_drop_sa(sm);
[K		<
[K		< 	sm->msg_3_of_4_ok = 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_pmk - Set PMK
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @pmk: The new PMK
[K		<  * @pmk_len: The length of the new PMK in bytes
[K		<  * @pmkid: Calculated PMKID
[K		<  * @bssid: AA to add into PMKSA cache or %NULL to not cache the PMK
[K		<  *
[K		<  * Configure the PMK for WPA state machine.
[K		<  */
[K		< void wpa_sm_set_pmk(struct wpa_sm *sm, const u8 *pmk, size_t pmk_len,
[K		< 		    const u8 *pmkid, const u8 *bssid)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	sm->pmk_len = pmk_len;
[K		< 	os_memcpy(sm->pmk, pmk, pmk_len);
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	/* Set XXKey to be PSK for FT key derivation */
[K		< 	sm->xxkey_len = pmk_len;
[K		< 	os_memcpy(sm->xxkey, pmk, pmk_len);
[K		< #endif /* CONFIG_IEEE80211R */
[K		<
[K		< 	if (bssid) {
[K		< 		pmksa_cache_add(sm->pmksa, pmk, pmk_len, pmkid, NULL, 0,
[K		< 				bssid, sm->own_addr,
[K		< 				sm->network_ctx, sm->key_mgmt);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_pmk_from_pmksa - Set PMK based on the current PMKSA
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  *
[K		<  * Take the PMK from the current PMKSA into use. If no PMKSA is active, the PMK
[K		<  * will be cleared.
[K		<  */
[K		< void wpa_sm_set_pmk_from_pmksa(struct wpa_sm *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	if (sm->cur_pmksa) {
[K		< 		sm->pmk_len = sm->cur_pmksa->pmk_len;
[K		< 		os_memcpy(sm->pmk, sm->cur_pmksa->pmk, sm->pmk_len);
[K		< 	} else {
[K		< 		sm->pmk_len = PMK_LEN;
[K		< 		os_memset(sm->pmk, 0, PMK_LEN);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_fast_reauth - Set fast reauthentication (EAP) enabled/disabled
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @fast_reauth: Whether fast reauthentication (EAP) is allowed
[K		<  */
[K		< void wpa_sm_set_fast_reauth(struct wpa_sm *sm, int fast_reauth)
[K		< {
[K		< 	if (sm)
[K		< 		sm->fast_reauth = fast_reauth;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_scard_ctx - Set context pointer for smartcard callbacks
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @scard_ctx: Context pointer for smartcard related callback functions
[K		<  */
[K		< void wpa_sm_set_scard_ctx(struct wpa_sm *sm, void *scard_ctx)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		< 	sm->scard_ctx = scard_ctx;
[K		< 	if (sm->preauth_eapol)
[K		< 		eapol_sm_register_scard_ctx(sm->preauth_eapol, scard_ctx);
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_config - Notification of current configration change
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @config: Pointer to current network configuration
[K		<  *
[K		<  * Notify WPA state machine that configuration has changed. config will be
[K		<  * stored as a backpointer to network configuration. This can be %NULL to clear
[K		<  * the stored pointed.
[K		<  */
[K		< void wpa_sm_set_config(struct wpa_sm *sm, struct rsn_supp_config *config)
[K		< {
[K		< 	if (!sm)
[K		< 		return;
[K		<
[K		< 	if (config) {
[K		< 		sm->network_ctx = config->network_ctx;
[K		< 		sm->peerkey_enabled = config->peerkey_enabled;
[K		< 		sm->allowed_pairwise_cipher = config->allowed_pairwise_cipher;
[K		< 		sm->proactive_key_caching = config->proactive_key_caching;
[K		< 		sm->eap_workaround = config->eap_workaround;
[K		< 		sm->eap_conf_ctx = config->eap_conf_ctx;
[K		< 		if (config->ssid) {
[K		< 			os_memcpy(sm->ssid, config->ssid, config->ssid_len);
[K		< 			sm->ssid_len = config->ssid_len;
[K		< 		} else
[K		< 			sm->ssid_len = 0;
[K		< 		sm->wpa_ptk_rekey = config->wpa_ptk_rekey;
[K		< 		sm->p2p = config->p2p;
[K		< 		sm->wpa_rsc_relaxation = config->wpa_rsc_relaxation;
[K		< 	} else {
[K		< 		sm->network_ctx = NULL;
[K		< 		sm->peerkey_enabled = 0;
[K		< 		sm->allowed_pairwise_cipher = 0;
[K		< 		sm->proactive_key_caching = 0;
[K		< 		sm->eap_workaround = 0;
[K		< 		sm->eap_conf_ctx = NULL;
[K		< 		sm->ssid_len = 0;
[K		< 		sm->wpa_ptk_rekey = 0;
[K		< 		sm->p2p = 0;
[K		< 		sm->wpa_rsc_relaxation = 0;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_own_addr - Set own MAC address
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @addr: Own MAC address
[K		<  */
[K		< void wpa_sm_set_own_addr(struct wpa_sm *sm, const u8 *addr)
[K		< {
[K		< 	if (sm)
[K		< 		os_memcpy(sm->own_addr, addr, ETH_ALEN);
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_ifname - Set network interface name
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @ifname: Interface name
[K		<  * @bridge_ifname: Optional bridge interface name (for pre-auth)
[K		<  */
[K		< void wpa_sm_set_ifname(struct wpa_sm *sm, const char *ifname,
[K		< 		       const char *bridge_ifname)
[K		< {
[K		< 	if (sm) {
[K		< 		sm->ifname = ifname;
[K		< 		sm->bridge_ifname = bridge_ifname;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_eapol - Set EAPOL state machine pointer
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @eapol: Pointer to EAPOL state machine allocated with eapol_sm_init()
[K		<  */
[K		< void wpa_sm_set_eapol(struct wpa_sm *sm, struct eapol_sm *eapol)
[K		< {
[K		< 	if (sm)
[K		< 		sm->eapol = eapol;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_param - Set WPA state machine parameters
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @param: Parameter field
[K		<  * @value: Parameter value
[K		<  * Returns: 0 on success, -1 on failure
[K		<  */
[K		< int wpa_sm_set_param(struct wpa_sm *sm, enum wpa_sm_conf_params param,
[K		< 		     unsigned int value)
[K		< {
[K		< 	int ret = 0;
[K		<
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< 	switch (param) {
[K		< 	case RSNA_PMK_LIFETIME:
[K		< 		if (value > 0)
[K		< 			sm->dot11RSNAConfigPMKLifetime = value;
[K		< 		else
[K		< 			ret = -1;
[K		< 		break;
[K		< 	case RSNA_PMK_REAUTH_THRESHOLD:
[K		< 		if (value > 0 && value <= 100)
[K		< 			sm->dot11RSNAConfigPMKReauthThreshold = value;
[K		< 		else
[K		< 			ret = -1;
[K		< 		break;
[K		< 	case RSNA_SA_TIMEOUT:
[K		< 		if (value > 0)
[K		< 			sm->dot11RSNAConfigSATimeout = value;
[K		< 		else
[K		< 			ret = -1;
[K		< 		break;
[K		< 	case WPA_PARAM_PROTO:
[K		< 		sm->proto = value;
[K		< 		break;
[K		< 	case WPA_PARAM_PAIRWISE:
[K		< 		sm->pairwise_cipher = value;
[K		< 		break;
[K		< 	case WPA_PARAM_GROUP:
[K		< 		sm->group_cipher = value;
[K		< 		break;
[K		< 	case WPA_PARAM_KEY_MGMT:
[K		< 		sm->key_mgmt = value;
[K		< 		break;
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	case WPA_PARAM_MGMT_GROUP:
[K		< 		sm->mgmt_group_cipher = value;
[K		< 		break;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	case WPA_PARAM_RSN_ENABLED:
[K		< 		sm->rsn_enabled = value;
[K		< 		break;
[K		< 	case WPA_PARAM_MFP:
[K		< 		sm->mfp = value;
[K		< 		break;
[K		< 	default:
[K		< 		break;
[K		< 	}
[K		<
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_get_status - Get WPA state machine
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @buf: Buffer for status information
[K		<  * @buflen: Maximum buffer length
[K		<  * @verbose: Whether to include verbose status information
[K		<  * Returns: Number of bytes written to buf.
[K		<  *
[K		<  * Query WPA state machine for status information. This function fills in
[K		<  * a text area with current status information. If the buffer (buf) is not
[K		<  * large enough, status information will be truncated to fit the buffer.
[K		<  */
[K		< int wpa_sm_get_status(struct wpa_sm *sm, char *buf, size_t buflen,
[K		< 		      int verbose)
[K		< {
[K		< 	char *pos = buf, *end = buf + buflen;
[K		< 	int ret;
[K		<
[K		< 	ret = os_snprintf(pos, end - pos,
[K		< 			  "pairwise_cipher=%s\n"
[K		< 			  "group_cipher=%s\n"
[K		< 			  "key_mgmt=%s\n",
[K		< 			  wpa_cipher_txt(sm->pairwise_cipher),
[K		< 			  wpa_cipher_txt(sm->group_cipher),
[K		< 			  wpa_key_mgmt_txt(sm->key_mgmt, sm->proto));
[K		< 	if (os_snprintf_error(end - pos, ret))
[K		< 		return pos - buf;
[K		< 	pos += ret;
[K		<
[K		< 	if (sm->mfp != NO_MGMT_FRAME_PROTECTION && sm->ap_rsn_ie) {
[K		< 		struct wpa_ie_data rsn;
[K		< 		if (wpa_parse_wpa_ie_rsn(sm->ap_rsn_ie, sm->ap_rsn_ie_len, &rsn)
[K		< 		    >= 0 &&
[K		< 		    rsn.capabilities & (WPA_CAPABILITY_MFPR |
[K		< 					WPA_CAPABILITY_MFPC)) {
[K		< 			ret = os_snprintf(pos, end - pos, "pmf=%d\n",
[K		< 					  (rsn.capabilities &
[K		< 					   WPA_CAPABILITY_MFPR) ? 2 : 1);
[K		< 			if (os_snprintf_error(end - pos, ret))
[K		< 				return pos - buf;
[K		< 			pos += ret;
[K		< 		}
[K		< 	}
[K		<
[K		< 	return pos - buf;
[K		< }
[K		<
[K		<
[K		< int wpa_sm_pmf_enabled(struct wpa_sm *sm)
[K		< {
[K		< 	struct wpa_ie_data rsn;
[K		<
[K		< 	if (sm->mfp == NO_MGMT_FRAME_PROTECTION || !sm->ap_rsn_ie)
[K		< 		return 0;
[K		<
[K		< 	if (wpa_parse_wpa_ie_rsn(sm->ap_rsn_ie, sm->ap_rsn_ie_len, &rsn) >= 0 &&
[K		< 	    rsn.capabilities & (WPA_CAPABILITY_MFPR | WPA_CAPABILITY_MFPC))
[K		< 		return 1;
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_assoc_wpa_ie_default - Generate own WPA/RSN IE from configuration
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @wpa_ie: Pointer to buffer for WPA/RSN IE
[K		<  * @wpa_ie_len: Pointer to the length of the wpa_ie buffer
[K		<  * Returns: 0 on success, -1 on failure
[K		<  */
[K		< int wpa_sm_set_assoc_wpa_ie_default(struct wpa_sm *sm, u8 *wpa_ie,
[K		< 				    size_t *wpa_ie_len)
[K		< {
[K		< 	int res;
[K		<
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< #ifdef CONFIG_TESTING_OPTIONS
[K		< 	if (sm->test_assoc_ie) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "TESTING: Replace association WPA/RSN IE");
[K		< 		if (*wpa_ie_len < wpabuf_len(sm->test_assoc_ie))
[K		< 			return -1;
[K		< 		os_memcpy(wpa_ie, wpabuf_head(sm->test_assoc_ie),
[K		< 			  wpabuf_len(sm->test_assoc_ie));
[K		< 		res = wpabuf_len(sm->test_assoc_ie);
[K		< 	} else
[K		< #endif /* CONFIG_TESTING_OPTIONS */
[K		< 	res = wpa_gen_wpa_ie(sm, wpa_ie, *wpa_ie_len);
[K		< 	if (res < 0)
[K		< 		return -1;
[K		< 	*wpa_ie_len = res;
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: Set own WPA IE default",
[K		< 		    wpa_ie, *wpa_ie_len);
[K		<
[K		< 	if (sm->assoc_wpa_ie == NULL) {
[K		< 		/*
[K		< 		 * Make a copy of the WPA/RSN IE so that 4-Way Handshake gets
[K		< 		 * the correct version of the IE even if PMKSA caching is
[K		< 		 * aborted (which would remove PMKID from IE generation).
[K		< 		 */
[K		< 		sm->assoc_wpa_ie = os_malloc(*wpa_ie_len);
[K		< 		if (sm->assoc_wpa_ie == NULL)
[K		< 			return -1;
[K		<
[K		< 		os_memcpy(sm->assoc_wpa_ie, wpa_ie, *wpa_ie_len);
[K		< 		sm->assoc_wpa_ie_len = *wpa_ie_len;
[K		< 	} else {
[K		< 		wpa_hexdump(MSG_DEBUG,
[K		< 			    "WPA: Leave previously set WPA IE default",
[K		< 			    sm->assoc_wpa_ie, sm->assoc_wpa_ie_len);
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_assoc_wpa_ie - Set own WPA/RSN IE from (Re)AssocReq
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @ie: Pointer to IE data (starting from id)
[K		<  * @len: IE length
[K		<  * Returns: 0 on success, -1 on failure
[K		<  *
[K		<  * Inform WPA state machine about the WPA/RSN IE used in (Re)Association
[K		<  * Request frame. The IE will be used to override the default value generated
[K		<  * with wpa_sm_set_assoc_wpa_ie_default().
[K		<  */
[K		< int wpa_sm_set_assoc_wpa_ie(struct wpa_sm *sm, const u8 *ie, size_t len)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< 	os_free(sm->assoc_wpa_ie);
[K		< 	if (ie == NULL || len == 0) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: clearing own WPA/RSN IE");
[K		< 		sm->assoc_wpa_ie = NULL;
[K		< 		sm->assoc_wpa_ie_len = 0;
[K		< 	} else {
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: set own WPA/RSN IE", ie, len);
[K		< 		sm->assoc_wpa_ie = os_malloc(len);
[K		< 		if (sm->assoc_wpa_ie == NULL)
[K		< 			return -1;
[K		<
[K		< 		os_memcpy(sm->assoc_wpa_ie, ie, len);
[K		< 		sm->assoc_wpa_ie_len = len;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_ap_wpa_ie - Set AP WPA IE from Beacon/ProbeResp
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @ie: Pointer to IE data (starting from id)
[K		<  * @len: IE length
[K		<  * Returns: 0 on success, -1 on failure
[K		<  *
[K		<  * Inform WPA state machine about the WPA IE used in Beacon / Probe Response
[K		<  * frame.
[K		<  */
[K		< int wpa_sm_set_ap_wpa_ie(struct wpa_sm *sm, const u8 *ie, size_t len)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< 	os_free(sm->ap_wpa_ie);
[K		< 	if (ie == NULL || len == 0) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: clearing AP WPA IE");
[K		< 		sm->ap_wpa_ie = NULL;
[K		< 		sm->ap_wpa_ie_len = 0;
[K		< 	} else {
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: set AP WPA IE", ie, len);
[K		< 		sm->ap_wpa_ie = os_malloc(len);
[K		< 		if (sm->ap_wpa_ie == NULL)
[K		< 			return -1;
[K		<
[K		< 		os_memcpy(sm->ap_wpa_ie, ie, len);
[K		< 		sm->ap_wpa_ie_len = len;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_ap_rsn_ie - Set AP RSN IE from Beacon/ProbeResp
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @ie: Pointer to IE data (starting from id)
[K		<  * @len: IE length
[K		<  * Returns: 0 on success, -1 on failure
[K		<  *
[K		<  * Inform WPA state machine about the RSN IE used in Beacon / Probe Response
[K		<  * frame.
[K		<  */
[K		< int wpa_sm_set_ap_rsn_ie(struct wpa_sm *sm, const u8 *ie, size_t len)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< 	os_free(sm->ap_rsn_ie);
[K		< 	if (ie == NULL || len == 0) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: clearing AP RSN IE");
[K		< 		sm->ap_rsn_ie = NULL;
[K		< 		sm->ap_rsn_ie_len = 0;
[K		< 	} else {
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: set AP RSN IE", ie, len);
[K		< 		sm->ap_rsn_ie = os_malloc(len);
[K		< 		if (sm->ap_rsn_ie == NULL)
[K		< 			return -1;
[K		<
[K		< 		os_memcpy(sm->ap_rsn_ie, ie, len);
[K		< 		sm->ap_rsn_ie_len = len;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_parse_own_wpa_ie - Parse own WPA/RSN IE
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @data: Pointer to data area for parsing results
[K		<  * Returns: 0 on success, -1 if IE is not known, or -2 on parsing failure
[K		<  *
[K		<  * Parse the contents of the own WPA or RSN IE from (Re)AssocReq and write the
[K		<  * parsed data into data.
[K		<  */
[K		< int wpa_sm_parse_own_wpa_ie(struct wpa_sm *sm, struct wpa_ie_data *data)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< 	if (sm->assoc_wpa_ie == NULL) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: No WPA/RSN IE available from association info");
[K		< 		return -1;
[K		< 	}
[K		< 	if (wpa_parse_wpa_ie(sm->assoc_wpa_ie, sm->assoc_wpa_ie_len, data))
[K		< 		return -2;
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< int wpa_sm_pmksa_cache_list(struct wpa_sm *sm, char *buf, size_t len)
[K		< {
[K		< 	return pmksa_cache_list(sm->pmksa, buf, len);
[K		< }
[K		<
[K		<
[K		< struct rsn_pmksa_cache_entry * wpa_sm_pmksa_cache_head(struct wpa_sm *sm)
[K		< {
[K		< 	return pmksa_cache_head(sm->pmksa);
[K		< }
[K		<
[K		<
[K		< struct rsn_pmksa_cache_entry *
[K		< wpa_sm_pmksa_cache_add_entry(struct wpa_sm *sm,
[K		< 			     struct rsn_pmksa_cache_entry * entry)
[K		< {
[K		< 	return pmksa_cache_add_entry(sm->pmksa, entry);
[K		< }
[K		<
[K		<
[K		< void wpa_sm_drop_sa(struct wpa_sm *sm)
[K		< {
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Clear old PMK and PTK");
[K		< 	sm->ptk_set = 0;
[K		< 	sm->tptk_set = 0;
[K		< 	os_memset(sm->pmk, 0, sizeof(sm->pmk));
[K		< 	os_memset(&sm->ptk, 0, sizeof(sm->ptk));
[K		< 	os_memset(&sm->tptk, 0, sizeof(sm->tptk));
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	os_memset(sm->xxkey, 0, sizeof(sm->xxkey));
[K		< 	os_memset(sm->pmk_r0, 0, sizeof(sm->pmk_r0));
[K		< 	os_memset(sm->pmk_r1, 0, sizeof(sm->pmk_r1));
[K		< #endif /* CONFIG_IEEE80211R */
[K		< }
[K		<
[K		<
[K		< int wpa_sm_has_ptk(struct wpa_sm *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return 0;
[K		< 	return sm->ptk_set;
[K		< }
[K		<
[K		<
[K		< void wpa_sm_update_replay_ctr(struct wpa_sm *sm, const u8 *replay_ctr)
[K		< {
[K		< 	os_memcpy(sm->rx_replay_counter, replay_ctr, WPA_REPLAY_COUNTER_LEN);
[K		< }
[K		<
[K		<
[K		< void wpa_sm_pmksa_cache_flush(struct wpa_sm *sm, void *network_ctx)
[K		< {
[K		< 	pmksa_cache_flush(sm->pmksa, network_ctx, NULL, 0);
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_WNM
[K		< int wpa_wnmsleep_install_key(struct wpa_sm *sm, u8 subelem_id, u8 *buf)
[K		< {
[K		< 	u16 keyinfo;
[K		< 	u8 keylen;  /* plaintext key len */
[K		< 	u8 *key_rsc;
[K		<
[K		< 	if (subelem_id == WNM_SLEEP_SUBELEM_GTK) {
[K		< 		struct wpa_gtk_data gd;
[K		<
[K		< 		os_memset(&gd, 0, sizeof(gd));
[K		< 		keylen = wpa_cipher_key_len(sm->group_cipher);
[K		< 		gd.key_rsc_len = wpa_cipher_rsc_len(sm->group_cipher);
[K		< 		gd.alg = wpa_cipher_to_alg(sm->group_cipher);
[K		< 		if (gd.alg == WPA_ALG_NONE) {
[K		< 			wpa_printf(MSG_DEBUG, "Unsupported group cipher suite");
[K		< 			return -1;
[K		< 		}
[K		<
[K		< 		key_rsc = buf + 5;
[K		< 		keyinfo = WPA_GET_LE16(buf + 2);
[K		< 		gd.gtk_len = keylen;
[K		< 		if (gd.gtk_len != buf[4]) {
[K		< 			wpa_printf(MSG_DEBUG, "GTK len mismatch len %d vs %d",
[K		< 				   gd.gtk_len, buf[4]);
[K		< 			return -1;
[K		< 		}
[K		< 		gd.keyidx = keyinfo & 0x03; /* B0 - B1 */
[K		< 		gd.tx = wpa_supplicant_gtk_tx_bit_workaround(
[K		< 		         sm, !!(keyinfo & WPA_KEY_INFO_TXRX));
[K		<
[K		< 		os_memcpy(gd.gtk, buf + 13, gd.gtk_len);
[K		<
[K		< 		wpa_hexdump_key(MSG_DEBUG, "Install GTK (WNM SLEEP)",
[K		< 				gd.gtk, gd.gtk_len);
[K		< 		if (wpa_supplicant_install_gtk(sm, &gd, key_rsc)) {
[K		< 			os_memset(&gd, 0, sizeof(gd));
[K		< 			wpa_printf(MSG_DEBUG, "Failed to install the GTK in "
[K		< 				   "WNM mode");
[K		< 			return -1;
[K		< 		}
[K		< 		os_memset(&gd, 0, sizeof(gd));
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	} else if (subelem_id == WNM_SLEEP_SUBELEM_IGTK) {
[K		< 		struct wpa_igtk_kde igd;
[K		< 		u16 keyidx;
[K		<
[K		< 		os_memset(&igd, 0, sizeof(igd));
[K		< 		keylen = wpa_cipher_key_len(sm->mgmt_group_cipher);
[K		< 		os_memcpy(igd.keyid, buf + 2, 2);
[K		< 		os_memcpy(igd.pn, buf + 4, 6);
[K		<
[K		< 		keyidx = WPA_GET_LE16(igd.keyid);
[K		< 		os_memcpy(igd.igtk, buf + 10, keylen);
[K		<
[K		< 		wpa_hexdump_key(MSG_DEBUG, "Install IGTK (WNM SLEEP)",
[K		< 				igd.igtk, keylen);
[K		< 		if (wpa_sm_set_key(sm, wpa_cipher_to_alg(sm->mgmt_group_cipher),
[K		< 				   broadcast_ether_addr,
[K		< 				   keyidx, 0, igd.pn, sizeof(igd.pn),
[K		< 				   igd.igtk, keylen) < 0) {
[K		< 			wpa_printf(MSG_DEBUG, "Failed to install the IGTK in "
[K		< 				   "WNM mode");
[K		< 			os_memset(&igd, 0, sizeof(igd));
[K		< 			return -1;
[K		< 		}
[K		< 		os_memset(&igd, 0, sizeof(igd));
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	} else {
[K		< 		wpa_printf(MSG_DEBUG, "Unknown element id");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		< #endif /* CONFIG_WNM */
[K		<
[K		<
[K		< #ifdef CONFIG_PEERKEY
[K		< int wpa_sm_rx_eapol_peerkey(struct wpa_sm *sm, const u8 *src_addr,
[K		< 			    const u8 *buf, size_t len)
[K		< {
[K		< 	struct wpa_peerkey *peerkey;
[K		<
[K		< 	for (peerkey = sm->peerkey; peerkey; peerkey = peerkey->next) {
[K		< 		if (os_memcmp(peerkey->addr, src_addr, ETH_ALEN) == 0)
[K		< 			break;
[K		< 	}
[K		<
[K		< 	if (!peerkey)
[K		< 		return 0;
[K		<
[K		< 	wpa_sm_rx_eapol(sm, src_addr, buf, len);
[K		<
[K		< 	return 1;
[K		< }
[K		< #endif /* CONFIG_PEERKEY */
[K		<
[K		<
[K		< #ifdef CONFIG_P2P
[K		<
[K		< int wpa_sm_get_p2p_ip_addr(struct wpa_sm *sm, u8 *buf)
[K		< {
[K		< 	if (sm == NULL || WPA_GET_BE32(sm->p2p_ip_addr) == 0)
[K		< 		return -1;
[K		< 	os_memcpy(buf, sm->p2p_ip_addr, 3 * 4);
[K		< 	return 0;
[K		< }
[K		<
[K		< #endif /* CONFIG_P2P */
[K		<
[K		<
[K		< void wpa_sm_set_rx_replay_ctr(struct wpa_sm *sm, const u8 *rx_replay_counter)
[K		< {
[K		< 	if (rx_replay_counter == NULL)
[K		< 		return;
[K		<
[K		< 	os_memcpy(sm->rx_replay_counter, rx_replay_counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		< 	sm->rx_replay_counter_set = 1;
[K		< 	wpa_printf(MSG_DEBUG, "Updated key replay counter");
[K		< }
[K		<
[K		<
[K		< void wpa_sm_set_ptk_kck_kek(struct wpa_sm *sm,
[K		< 			    const u8 *ptk_kck, size_t ptk_kck_len,
[K		< 			    const u8 *ptk_kek, size_t ptk_kek_len)
[K		< {
[K		< 	if (ptk_kck && ptk_kck_len <= WPA_KCK_MAX_LEN) {
[K		< 		os_memcpy(sm->ptk.kck, ptk_kck, ptk_kck_len);
[K		< 		sm->ptk.kck_len = ptk_kck_len;
[K		< 		wpa_printf(MSG_DEBUG, "Updated PTK KCK");
[K		< 	}
[K		< 	if (ptk_kek && ptk_kek_len <= WPA_KEK_MAX_LEN) {
[K		< 		os_memcpy(sm->ptk.kek, ptk_kek, ptk_kek_len);
[K		< 		sm->ptk.kek_len = ptk_kek_len;
[K		< 		wpa_printf(MSG_DEBUG, "Updated PTK KEK");
[K		< 	}
[K		< 	sm->ptk_set = 1;
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_TESTING_OPTIONS
[K		< void wpa_sm_set_test_assoc_ie(struct wpa_sm *sm, struct wpabuf *buf)
[K		< {
[K		< 	wpabuf_free(sm->test_assoc_ie);
[K		< 	sm->test_assoc_ie = buf;
[K		< }
[K		< #endif /* CONFIG_TESTING_OPTIONS */
[K		<
[K		<
[K		< #ifdef CONFIG_FILS
[K		<
[K		< struct wpabuf * fils_build_auth(struct wpa_sm *sm)
[K		< {
[K		< 	struct wpabuf *buf = NULL;
[K		< 	struct wpabuf *erp_msg;
[K		<
[K		< 	erp_msg = eapol_sm_build_erp_reauth_start(sm->eapol);
[K		< 	if (!erp_msg && !sm->cur_pmksa) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Neither ERP EAP-Initiate/Re-auth nor PMKSA cache entry is available - skip FILS");
[K		< 		goto fail;
[K		< 	}
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "FILS: Try to use FILS (erp=%d pmksa_cache=%d)",
[K		< 		   erp_msg != NULL, sm->cur_pmksa != NULL);
[K		<
[K		< 	sm->fils_completed = 0;
[K		<
[K		< 	if (!sm->assoc_wpa_ie) {
[K		< 		wpa_printf(MSG_INFO, "FILS: No own RSN IE set for FILS");
[K		< 		goto fail;
[K		< 	}
[K		<
[K		< 	if (random_get_bytes(sm->fils_nonce, FILS_NONCE_LEN) < 0 ||
[K		< 	    random_get_bytes(sm->fils_session, FILS_SESSION_LEN) < 0)
[K		< 		goto fail;
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "FILS: Generated FILS Nonce",
[K		< 		    sm->fils_nonce, FILS_NONCE_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "FILS: Generated FILS Session",
[K		< 		    sm->fils_session, FILS_SESSION_LEN);
[K		<
[K		< 	buf = wpabuf_alloc(1000 + sm->assoc_wpa_ie_len);
[K		< 	if (!buf)
[K		< 		goto fail;
[K		<
[K		< 	/* Fields following the Authentication algorithm number field */
[K		<
[K		< 	/* Authentication Transaction seq# */
[K		< 	wpabuf_put_le16(buf, 1);
[K		<
[K		< 	/* Status Code */
[K		< 	wpabuf_put_le16(buf, WLAN_STATUS_SUCCESS);
[K		<
[K		< 	/* TODO: Finite Cyclic Group when using PK or PFS */
[K		< 	/* TODO: Element when using PK or PFS */
[K		<
[K		< 	/* RSNE */
[K		< 	wpa_hexdump(MSG_DEBUG, "FILS: RSNE in FILS Authentication frame",
[K		< 		    sm->assoc_wpa_ie, sm->assoc_wpa_ie_len);
[K		< 	wpabuf_put_data(buf, sm->assoc_wpa_ie, sm->assoc_wpa_ie_len);
[K		<
[K		< 	/* TODO: MDE when using FILS for FT initial association */
[K		< 	/* TODO: FTE when using FILS for FT initial association */
[K		<
[K		< 	/* FILS Nonce */
[K		< 	wpabuf_put_u8(buf, WLAN_EID_EXTENSION); /* Element ID */
[K		< 	wpabuf_put_u8(buf, 1 + FILS_NONCE_LEN); /* Length */
[K		< 	/* Element ID Extension */
[K		< 	wpabuf_put_u8(buf, WLAN_EID_EXT_FILS_NONCE);
[K		< 	wpabuf_put_data(buf, sm->fils_nonce, FILS_NONCE_LEN);
[K		<
[K		< 	/* FILS Session */
[K		< 	wpabuf_put_u8(buf, WLAN_EID_EXTENSION); /* Element ID */
[K		< 	wpabuf_put_u8(buf, 1 + FILS_SESSION_LEN); /* Length */
[K		< 	/* Element ID Extension */
[K		< 	wpabuf_put_u8(buf, WLAN_EID_EXT_FILS_SESSION);
[K		< 	wpabuf_put_data(buf, sm->fils_session, FILS_SESSION_LEN);
[K		<
[K		< 	/* FILS Wrapped Data */
[K		< 	sm->fils_erp_pmkid_set = 0;
[K		< 	if (erp_msg) {
[K		< 		wpabuf_put_u8(buf, WLAN_EID_EXTENSION); /* Element ID */
[K		< 		wpabuf_put_u8(buf, 1 + wpabuf_len(erp_msg)); /* Length */
[K		< 		/* Element ID Extension */
[K		< 		wpabuf_put_u8(buf, WLAN_EID_EXT_FILS_WRAPPED_DATA);
[K		< 		wpabuf_put_buf(buf, erp_msg);
[K		< 		/* Calculate pending PMKID here so that we do not need to
[K		< 		 * maintain a copy of the EAP-Initiate/Reauth message. */
[K		< 		if (fils_pmkid_erp(sm->key_mgmt, wpabuf_head(erp_msg),
[K		< 				   wpabuf_len(erp_msg),
[K		< 				   sm->fils_erp_pmkid) == 0)
[K		< 			sm->fils_erp_pmkid_set = 1;
[K		< 	}
[K		<
[K		< 	wpa_hexdump_buf(MSG_DEBUG, "RSN: FILS fields for Authentication frame",
[K		< 			buf);
[K		<
[K		< fail:
[K		< 	wpabuf_free(erp_msg);
[K		< 	return buf;
[K		< }
[K		<
[K		<
[K		< int fils_process_auth(struct wpa_sm *sm, const u8 *data, size_t len)
[K		< {
[K		< 	const u8 *pos, *end;
[K		< 	struct ieee802_11_elems elems;
[K		< 	struct wpa_ie_data rsn;
[K		< 	int pmkid_match = 0;
[K		< 	u8 ick[FILS_ICK_MAX_LEN];
[K		< 	size_t ick_len;
[K		< 	int res;
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "FILS: Authentication frame fields",
[K		< 		    data, len);
[K		< 	pos = data;
[K		< 	end = data + len;
[K		<
[K		< 	/* TODO: Finite Cyclic Group when using PK or PFS */
[K		< 	/* TODO: Element when using PK or PFS */
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "FILS: Remaining IEs", pos, end - pos);
[K		< 	if (ieee802_11_parse_elems(pos, end - pos, &elems, 1) == ParseFailed) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Could not parse elements");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	/* RSNE */
[K		< 	wpa_hexdump(MSG_DEBUG, "FILS: RSN element", elems.rsn_ie,
[K		< 		    elems.rsn_ie_len);
[K		< 	if (!elems.rsn_ie ||
[K		< 	    wpa_parse_wpa_ie_rsn(elems.rsn_ie - 2, elems.rsn_ie_len + 2,
[K		< 				 &rsn) < 0) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: No RSN element");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (!elems.fils_nonce) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: No FILS Nonce field");
[K		< 		return -1;
[K		< 	}
[K		< 	os_memcpy(sm->fils_anonce, elems.fils_nonce, FILS_NONCE_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "FILS: ANonce", sm->fils_anonce, FILS_NONCE_LEN);
[K		<
[K		< 	/* TODO: MDE when using FILS+FT */
[K		< 	/* TODO: FTE when using FILS+FT */
[K		<
[K		< 	/* PMKID List */
[K		< 	if (rsn.pmkid && rsn.num_pmkid > 0) {
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: PMKID List",
[K		< 			    rsn.pmkid, rsn.num_pmkid * PMKID_LEN);
[K		<
[K		< 		if (rsn.num_pmkid != 1) {
[K		< 			wpa_printf(MSG_DEBUG, "FILS: Invalid PMKID selection");
[K		< 			return -1;
[K		< 		}
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: PMKID", rsn.pmkid, PMKID_LEN);
[K		< 		if (os_memcmp(sm->cur_pmksa->pmkid, rsn.pmkid, PMKID_LEN) != 0)
[K		< 		{
[K		< 			wpa_printf(MSG_DEBUG, "FILS: PMKID mismatch");
[K		< 			wpa_hexdump(MSG_DEBUG, "FILS: Expected PMKID",
[K		< 				    sm->cur_pmksa->pmkid, PMKID_LEN);
[K		< 			return -1;
[K		< 		}
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Matching PMKID - continue using PMKSA caching");
[K		< 		pmkid_match = 1;
[K		< 	}
[K		< 	if (!pmkid_match && sm->cur_pmksa) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: No PMKID match - cannot use cached PMKSA entry");
[K		< 		sm->cur_pmksa = NULL;
[K		< 	}
[K		<
[K		< 	/* FILS Session */
[K		< 	if (!elems.fils_session) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: No FILS Session element");
[K		< 		return -1;
[K		< 	}
[K		< 	wpa_hexdump(MSG_DEBUG, "FILS: FILS Session", elems.fils_session,
[K		< 		    FILS_SESSION_LEN);
[K		< 	if (os_memcmp(sm->fils_session, elems.fils_session, FILS_SESSION_LEN)
[K		< 	    != 0) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Session mismatch");
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Expected FILS Session",
[K		< 			    sm->fils_session, FILS_SESSION_LEN);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	/* FILS Wrapped Data */
[K		< 	if (!sm->cur_pmksa && elems.fils_wrapped_data) {
[K		< 		u8 rmsk[ERP_MAX_KEY_LEN];
[K		< 		size_t rmsk_len;
[K		<
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Wrapped Data",
[K		< 			    elems.fils_wrapped_data,
[K		< 			    elems.fils_wrapped_data_len);
[K		< 		eapol_sm_process_erp_finish(sm->eapol, elems.fils_wrapped_data,
[K		< 					    elems.fils_wrapped_data_len);
[K		< 		if (eapol_sm_failed(sm->eapol))
[K		< 			return -1;
[K		<
[K		< 		rmsk_len = ERP_MAX_KEY_LEN;
[K		< 		res = eapol_sm_get_key(sm->eapol, rmsk, rmsk_len);
[K		< 		if (res == PMK_LEN) {
[K		< 			rmsk_len = PMK_LEN;
[K		< 			res = eapol_sm_get_key(sm->eapol, rmsk, rmsk_len);
[K		< 		}
[K		< 		if (res)
[K		< 			return -1;
[K		<
[K		< 		res = fils_rmsk_to_pmk(sm->key_mgmt, rmsk, rmsk_len,
[K		< 				       sm->fils_nonce, sm->fils_anonce, NULL, 0,
[K		< 				       sm->pmk, &sm->pmk_len);
[K		< 		os_memset(rmsk, 0, sizeof(rmsk));
[K		< 		if (res)
[K		< 			return -1;
[K		<
[K		< 		if (!sm->fils_erp_pmkid_set) {
[K		< 			wpa_printf(MSG_DEBUG, "FILS: PMKID not available");
[K		< 			return -1;
[K		< 		}
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: PMKID", sm->fils_erp_pmkid,
[K		< 			    PMKID_LEN);
[K		< 		wpa_printf(MSG_DEBUG, "FILS: ERP processing succeeded - add PMKSA cache entry for the result");
[K		< 		sm->cur_pmksa = pmksa_cache_add(sm->pmksa, sm->pmk, sm->pmk_len,
[K		< 						sm->fils_erp_pmkid, NULL, 0,
[K		< 						sm->bssid, sm->own_addr,
[K		< 						sm->network_ctx, sm->key_mgmt);
[K		< 	}
[K		<
[K		< 	if (!sm->cur_pmksa) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: No remaining options to continue FILS authentication");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (fils_pmk_to_ptk(sm->pmk, sm->pmk_len, sm->own_addr, sm->bssid,
[K		< 			    sm->fils_nonce, sm->fils_anonce, &sm->ptk,
[K		< 			    ick, &ick_len, sm->key_mgmt, sm->pairwise_cipher) <
[K		< 	    0) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Failed to derive PTK");
[K		< 		return -1;
[K		< 	}
[K		< 	sm->ptk_set = 1;
[K		< 	sm->tptk_set = 0;
[K		< 	os_memset(&sm->tptk, 0, sizeof(sm->tptk));
[K		<
[K		< 	res = fils_key_auth_sk(ick, ick_len, sm->fils_nonce,
[K		< 			       sm->fils_anonce, sm->own_addr, sm->bssid,
[K		< 			       NULL, 0, NULL, 0, /* TODO: SK+PFS */
[K		< 			       sm->key_mgmt, sm->fils_key_auth_sta,
[K		< 			       sm->fils_key_auth_ap,
[K		< 			       &sm->fils_key_auth_len);
[K		< 	os_memset(ick, 0, sizeof(ick));
[K		< 	return res;
[K		< }
[K		<
[K		<
[K		< struct wpabuf * fils_build_assoc_req(struct wpa_sm *sm, const u8 **kek,
[K		< 				     size_t *kek_len, const u8 **snonce,
[K		< 				     const u8 **anonce,
[K		< 				     const struct wpabuf **hlp,
[K		< 				     unsigned int num_hlp)
[K		< {
[K		< 	struct wpabuf *buf;
[K		< 	size_t len;
[K		< 	unsigned int i;
[K		<
[K		< 	len = 1000;
[K		< 	for (i = 0; hlp && i < num_hlp; i++)
[K		< 		len += 10 + wpabuf_len(hlp[i]);
[K		< 	buf = wpabuf_alloc(len);
[K		< 	if (!buf)
[K		< 		return NULL;
[K		<
[K		< 	/* FILS Session */
[K		< 	wpabuf_put_u8(buf, WLAN_EID_EXTENSION); /* Element ID */
[K		< 	wpabuf_put_u8(buf, 1 + FILS_SESSION_LEN); /* Length */
[K		< 	/* Element ID Extension */
[K		< 	wpabuf_put_u8(buf, WLAN_EID_EXT_FILS_SESSION);
[K		< 	wpabuf_put_data(buf, sm->fils_session, FILS_SESSION_LEN);
[K		<
[K		< 	/* Everything after FILS Session element gets encrypted in the driver
[K		< 	 * with KEK. The buffer returned from here is the plaintext version. */
[K		<
[K		< 	/* TODO: FILS Public Key */
[K		<
[K		< 	/* FILS Key Confirm */
[K		< 	wpabuf_put_u8(buf, WLAN_EID_EXTENSION); /* Element ID */
[K		< 	wpabuf_put_u8(buf, 1 + sm->fils_key_auth_len); /* Length */
[K		< 	/* Element ID Extension */
[K		< 	wpabuf_put_u8(buf, WLAN_EID_EXT_FILS_KEY_CONFIRM);
[K		< 	wpabuf_put_data(buf, sm->fils_key_auth_sta, sm->fils_key_auth_len);
[K		<
[K		< 	/* FILS HLP Container */
[K		< 	for (i = 0; hlp && i < num_hlp; i++) {
[K		< 		const u8 *pos = wpabuf_head(hlp[i]);
[K		< 		size_t left = wpabuf_len(hlp[i]);
[K		<
[K		< 		wpabuf_put_u8(buf, WLAN_EID_EXTENSION); /* Element ID */
[K		< 		if (left <= 254)
[K		< 			len = 1 + left;
[K		< 		else
[K		< 			len = 255;
[K		< 		wpabuf_put_u8(buf, len); /* Length */
[K		< 		/* Element ID Extension */
[K		< 		wpabuf_put_u8(buf, WLAN_EID_EXT_FILS_HLP_CONTAINER);
[K		< 		/* Destination MAC Address, Source MAC Address, HLP Packet.
[K		< 		 * HLP Packet is in MSDU format (i.e., included the LLC/SNAP
[K		< 		 * header when LPD is used). */
[K		< 		wpabuf_put_data(buf, pos, len - 1);
[K		< 		pos += len - 1;
[K		< 		left -= len - 1;
[K		< 		while (left) {
[K		< 			wpabuf_put_u8(buf, WLAN_EID_FRAGMENT);
[K		< 			len = left > 255 ? 255 : left;
[K		< 			wpabuf_put_u8(buf, len);
[K		< 			wpabuf_put_data(buf, pos, len);
[K		< 			pos += len;
[K		< 			left -= len;
[K		< 		}
[K		< 	}
[K		<
[K		< 	/* TODO: FILS IP Address Assignment */
[K		<
[K		< 	wpa_hexdump_buf(MSG_DEBUG, "FILS: Association Request plaintext", buf);
[K		<
[K		< 	*kek = sm->ptk.kek;
[K		< 	*kek_len = sm->ptk.kek_len;
[K		< 	wpa_hexdump_key(MSG_DEBUG, "FILS: KEK for AEAD", *kek, *kek_len);
[K		< 	*snonce = sm->fils_nonce;
[K		< 	wpa_hexdump(MSG_DEBUG, "FILS: SNonce for AEAD AAD",
[K		< 		    *snonce, FILS_NONCE_LEN);
[K		< 	*anonce = sm->fils_anonce;
[K		< 	wpa_hexdump(MSG_DEBUG, "FILS: ANonce for AEAD AAD",
[K		< 		    *anonce, FILS_NONCE_LEN);
[K		<
[K		< 	return buf;
[K		< }
[K		<
[K		<
[K		< static void fils_process_hlp_resp(struct wpa_sm *sm, const u8 *resp, size_t len)
[K		< {
[K		< 	const u8 *pos, *end;
[K		<
[K		< 	wpa_hexdump(MSG_MSGDUMP, "FILS: HLP response", resp, len);
[K		< 	if (len < 2 * ETH_ALEN)
[K		< 		return;
[K		< 	pos = resp + 2 * ETH_ALEN;
[K		< 	end = resp + len;
[K		< 	if (end - pos >= 6 &&
[K		< 	    os_memcmp(pos, "\xaa\xaa\x03\x00\x00\x00", 6) == 0)
[K		< 		pos += 6; /* Remove SNAP/LLC header */
[K		< 	wpa_sm_fils_hlp_rx(sm, resp, resp + ETH_ALEN, pos, end - pos);
[K		< }
[K		<
[K		<
[K		< static void fils_process_hlp_container(struct wpa_sm *sm, const u8 *pos,
[K		< 				       size_t len)
[K		< {
[K		< 	const u8 *end = pos + len;
[K		< 	u8 *tmp, *tmp_pos;
[K		<
[K		< 	/* Check if there are any FILS HLP Container elements */
[K		< 	while (end - pos >= 2) {
[K		< 		if (2 + pos[1] > end - pos)
[K		< 			return;
[K		< 		if (pos[0] == WLAN_EID_EXTENSION &&
[K		< 		    pos[1] >= 1 + 2 * ETH_ALEN &&
[K		< 		    pos[2] == WLAN_EID_EXT_FILS_HLP_CONTAINER)
[K		< 			break;
[K		< 		pos += 2 + pos[1];
[K		< 	}
[K		< 	if (end - pos < 2)
[K		< 		return; /* No FILS HLP Container elements */
[K		<
[K		< 	tmp = os_malloc(end - pos);
[K		< 	if (!tmp)
[K		< 		return;
[K		<
[K		< 	while (end - pos >= 2) {
[K		< 		if (2 + pos[1] > end - pos ||
[K		< 		    pos[0] != WLAN_EID_EXTENSION ||
[K		< 		    pos[1] < 1 + 2 * ETH_ALEN ||
[K		< 		    pos[2] != WLAN_EID_EXT_FILS_HLP_CONTAINER)
[K		< 			break;
[K		< 		tmp_pos = tmp;
[K		< 		os_memcpy(tmp_pos, pos + 3, pos[1] - 1);
[K		< 		tmp_pos += pos[1] - 1;
[K		< 		pos += 2 + pos[1];
[K		<
[K		< 		/* Add possible fragments */
[K		< 		while (end - pos >= 2 && pos[0] == WLAN_EID_FRAGMENT &&
[K		< 		       2 + pos[1] <= end - pos) {
[K		< 			os_memcpy(tmp_pos, pos + 2, pos[1]);
[K		< 			tmp_pos += pos[1];
[K		< 			pos += 2 + pos[1];
[K		< 		}
[K		<
[K		< 		fils_process_hlp_resp(sm, tmp, tmp_pos - tmp);
[K		< 	}
[K		<
[K		< 	os_free(tmp);
[K		< }
[K		<
[K		<
[K		< int fils_process_assoc_resp(struct wpa_sm *sm, const u8 *resp, size_t len)
[K		< {
[K		< 	const struct ieee80211_mgmt *mgmt;
[K		< 	const u8 *end, *ie_start;
[K		< 	struct ieee802_11_elems elems;
[K		< 	int keylen, rsclen;
[K		< 	enum wpa_alg alg;
[K		< 	struct wpa_gtk_data gd;
[K		< 	int maxkeylen;
[K		< 	struct wpa_eapol_ie_parse kde;
[K		<
[K		< 	if (!sm || !sm->ptk_set) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: No KEK available");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (!wpa_key_mgmt_fils(sm->key_mgmt)) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Not a FILS AKM");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "FILS: (Re)Association Response frame",
[K		< 		    resp, len);
[K		<
[K		< 	mgmt = (const struct ieee80211_mgmt *) resp;
[K		< 	if (len < IEEE80211_HDRLEN + sizeof(mgmt->u.assoc_resp))
[K		< 		return -1;
[K		<
[K		< 	end = resp + len;
[K		< 	/* Same offset for Association Response and Reassociation Response */
[K		< 	ie_start = mgmt->u.assoc_resp.variable;
[K		<
[K		< 	if (ieee802_11_parse_elems(ie_start, end - ie_start, &elems, 1) ==
[K		< 	    ParseFailed) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Failed to parse decrypted elements");
[K		< 		goto fail;
[K		< 	}
[K		<
[K		< 	if (!elems.fils_session) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: No FILS Session element");
[K		< 		return -1;
[K		< 	}
[K		< 	if (os_memcmp(elems.fils_session, sm->fils_session,
[K		< 		      FILS_SESSION_LEN) != 0) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: FILS Session mismatch");
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Received FILS Session",
[K		< 			    elems.fils_session, FILS_SESSION_LEN);
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Expected FILS Session",
[K		< 			    sm->fils_session, FILS_SESSION_LEN);
[K		< 	}
[K		<
[K		< 	/* TODO: FILS Public Key */
[K		<
[K		< 	if (!elems.fils_key_confirm) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: No FILS Key Confirm element");
[K		< 		goto fail;
[K		< 	}
[K		< 	if (elems.fils_key_confirm_len != sm->fils_key_auth_len) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Unexpected Key-Auth length %d (expected %d)",
[K		< 			   elems.fils_key_confirm_len,
[K		< 			   (int) sm->fils_key_auth_len);
[K		< 		goto fail;
[K		< 	}
[K		< 	if (os_memcmp(elems.fils_key_confirm, sm->fils_key_auth_ap,
[K		< 		      sm->fils_key_auth_len) != 0) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Key-Auth mismatch");
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Received Key-Auth",
[K		< 			    elems.fils_key_confirm,
[K		< 			    elems.fils_key_confirm_len);
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Expected Key-Auth",
[K		< 			    sm->fils_key_auth_ap, sm->fils_key_auth_len);
[K		< 		goto fail;
[K		< 	}
[K		<
[K		< 	/* Key Delivery */
[K		< 	if (!elems.key_delivery) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: No Key Delivery element");
[K		< 		goto fail;
[K		< 	}
[K		<
[K		< 	/* Parse GTK and set the key to the driver */
[K		< 	os_memset(&gd, 0, sizeof(gd));
[K		< 	if (wpa_supplicant_parse_ies(elems.key_delivery + WPA_KEY_RSC_LEN,
[K		< 				     elems.key_delivery_len - WPA_KEY_RSC_LEN,
[K		< 				     &kde) < 0) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Failed to parse KDEs");
[K		< 		goto fail;
[K		< 	}
[K		< 	if (!kde.gtk) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: No GTK KDE");
[K		< 		goto fail;
[K		< 	}
[K		< 	maxkeylen = gd.gtk_len = kde.gtk_len - 2;
[K		< 	if (wpa_supplicant_check_group_cipher(sm, sm->group_cipher,
[K		< 					      gd.gtk_len, maxkeylen,
[K		< 					      &gd.key_rsc_len, &gd.alg))
[K		< 		goto fail;
[K		<
[K		< 	wpa_hexdump_key(MSG_DEBUG, "FILS: Received GTK", kde.gtk, kde.gtk_len);
[K		< 	gd.keyidx = kde.gtk[0] & 0x3;
[K		< 	gd.tx = wpa_supplicant_gtk_tx_bit_workaround(sm,
[K		< 						     !!(kde.gtk[0] & BIT(2)));
[K		< 	if (kde.gtk_len - 2 > sizeof(gd.gtk)) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Too long GTK in GTK KDE (len=%lu)",
[K		< 			   (unsigned long) kde.gtk_len - 2);
[K		< 		goto fail;
[K		< 	}
[K		< 	os_memcpy(gd.gtk, kde.gtk + 2, kde.gtk_len - 2);
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "FILS: Set GTK to driver");
[K		< 	if (wpa_supplicant_install_gtk(sm, &gd, elems.key_delivery) < 0) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Failed to set GTK");
[K		< 		goto fail;
[K		< 	}
[K		<
[K		< 	if (ieee80211w_set_keys(sm, &kde) < 0) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Failed to set IGTK");
[K		< 		goto fail;
[K		< 	}
[K		<
[K		< 	alg = wpa_cipher_to_alg(sm->pairwise_cipher);
[K		< 	keylen = wpa_cipher_key_len(sm->pairwise_cipher);
[K		< 	rsclen = wpa_cipher_rsc_len(sm->pairwise_cipher);
[K		< 	wpa_hexdump_key(MSG_DEBUG, "FILS: Set TK to driver",
[K		< 			sm->ptk.tk, keylen);
[K		< 	if (wpa_sm_set_key(sm, alg, sm->bssid, 0, 1, null_rsc, rsclen,
[K		< 			   sm->ptk.tk, keylen) < 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"FILS: Failed to set PTK to the driver (alg=%d keylen=%d bssid="
[K		< 			MACSTR ")",
[K		< 			alg, keylen, MAC2STR(sm->bssid));
[K		< 		goto fail;
[K		< 	}
[K		<
[K		< 	/* TODO: TK could be cleared after auth frame exchange now that driver
[K		< 	 * takes care of association frame encryption/decryption. */
[K		< 	/* TK is not needed anymore in supplicant */
[K		< 	os_memset(sm->ptk.tk, 0, WPA_TK_MAX_LEN);
[K		<
[K		< 	/* FILS HLP Container */
[K		< 	fils_process_hlp_container(sm, ie_start, end - ie_start);
[K		<
[K		< 	/* TODO: FILS IP Address Assignment */
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "FILS: Auth+Assoc completed successfully");
[K		< 	sm->fils_completed = 1;
[K		<
[K		< 	return 0;
[K		< fail:
[K		< 	return -1;
[K		< }
[K		<
[K		< #endif /* CONFIG_FILS */
[K		<
[K		<
[K		< int wpa_fils_is_completed(struct wpa_sm *sm)
[K		< {
[K		< #ifdef CONFIG_FILS
[K		< 	return sm && sm->fils_completed;
[K		< #else /* CONFIG_FILS */
[K		< 	return 0;
[K		< #endif /* CONFIG_FILS */
[K		< }
[K
	Successful transformation
[K
		/hostap/CVE-2017-13077_Android/Android/src/ap/ieee802_11.c
		------------------------------------------------------------------------------------------

[K	Original AST script
[K			AST Script:
[K				 Insert EnumConstantDecl(21538) EnumDecl(21528) 9
[K				 Insert FunctionDecl(21629) TranslationUnitDecl(0) 1159
[K				 Insert TypeLoc(21630) FunctionDecl(21629) 0
[K				 Insert TypeLoc(21631) TypeLoc(21630) 0
[K				 Insert ParmVarDecl(21632) TypeLoc(21630) 1
[K				 Insert TypeLoc(21633) ParmVarDecl(21632) 0
[K				 Insert TypeLoc(21634) TypeLoc(21633) 0
[K				 Insert TypeLoc(21635) TypeLoc(21634) 0
[K				 Insert DeclStmt(29104) CompoundStmt(29095) 2
[K				 Insert VarDecl(29105) DeclStmt(29104) 0
[K				 Insert TypeLoc(29106) VarDecl(29105) 0
[K				 Insert IntegerLiteral(29107) VarDecl(29105) 1
[K				 Insert BinaryOperator(29109) IfStmt(29108) 0
[K				 Move UnaryOperator(29110) BinaryOperator(29109) 0
[K				 Insert ParenExpr(29113) BinaryOperator(29109) 1
[K				 Insert BinaryOperator(29114) ParenExpr(29113) 0
[K				 Insert UnaryOperator(29115) BinaryOperator(29114) 0
[K				 Insert ParenExpr(29116) UnaryOperator(29115) 0
[K				 Insert BinaryOperator(29117) ParenExpr(29116) 0
[K				 Insert MemberExpr(29118) BinaryOperator(29117) 0
[K				 Insert DeclRefExpr(29119) MemberExpr(29118) 0
[K				 Insert Macro(29120) BinaryOperator(29117) 1
[K				 Insert UnaryOperator(29121) BinaryOperator(29114) 1
[K				 Insert CallExpr(29122) UnaryOperator(29121) 0
[K				 Insert DeclRefExpr(29123) CallExpr(29122) 0
[K				 Insert MemberExpr(29124) CallExpr(29122) 1
[K				 Insert DeclRefExpr(29125) MemberExpr(29124) 0
[K				 Insert CompoundStmt(29126) IfStmt(29108) 1
[K				 Move CallExpr(29127) CompoundStmt(29126) 0
[K				 Insert CallExpr(29132) CompoundStmt(29126) 1
[K				 Insert DeclRefExpr(29133) CallExpr(29132) 0
[K				 Insert MemberExpr(29134) CallExpr(29132) 1
[K				 Insert DeclRefExpr(29135) MemberExpr(29134) 0
[K				 Insert DeclRefExpr(29136) CallExpr(29132) 2
[K				 Insert BinaryOperator(29137) CompoundStmt(29126) 2
[K				 Insert DeclRefExpr(29138) BinaryOperator(29137) 0
[K				 Insert IntegerLiteral(29139) BinaryOperator(29137) 1
[K				 Update DeclRefExpr(29151) DeclRefExpr(29185)
[K				 Update DeclRefExpr(29163) DeclRefExpr(29196)
[K				 Delete MemberExpr(29150)
[K				 Delete MemberExpr(29162)
[K	Generated AST script
[K			AST Script:
[K				 Delete MemberExpr(28138)
[K				 Delete MemberExpr(28126)
[K				 Delete CallExpr(28076)
[K				 Delete UnaryOperator(28073)
[K				 Insert EnumConstantDecl(21538) into EnumDecl(21043) at 9
[K				 Insert FunctionDecl(21629) into TranslationUnitDecl(0) at 1133
[K				 Insert DeclStmt(29104) into CompoundStmt(28063) at 2
[K				 Insert BinaryOperator(29109) into IfStmt(28072) at 0
[K				 Insert CompoundStmt(29126) into IfStmt(28072) at 1
[K				 Update DeclRefExpr(28127) to DeclRefExpr(29185)
[K				 Update DeclRefExpr(28139) to DeclRefExpr(29196)
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/ieee802_11.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/ieee802_11.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/ieee802_11.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/ieee802_11.c
[K					extracting macro definitions
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/ieee802_11.c
[K	Original Patch
[K		2632a2633
[K		> 	int set = 1;
[K		2639a2641,2644
[K		> 	 *
[K		> 	 * Skip this if the STA has already completed FT reassociation and the
[K		> 	 * TK has been configured since the TX/RX PN must not be reset to 0 for
[K		> 	 * the same key.
[K		2641c2646,2648
[K		< 	if (!sta->added_unassoc)
[K		---
[K		> 	if (!sta->added_unassoc &&
[K		> 	    (!(sta->flags & WLAN_STA_AUTHORIZED) ||
[K		> 	     !wpa_auth_sta_ft_tk_already_set(sta->wpa_sm))) {
[K		2642a2650,2652
[K		> 		wpa_auth_sm_event(sta->wpa_sm, WPA_DRV_STA_REMOVED);
[K		> 		set = 0;
[K		> 	}
[K		2665c2675
[K		< 			    sta->added_unassoc)) {
[K		---
[K		> 			    set)) {
[K		2669c2679
[K		< 			       sta->added_unassoc ? "set" : "add");
[K		---
[K		> 			       set ? "set" : "add");
[K	Generated Patch
[K		2211a2212,2213
[K		>  int set = 1;
[K		>
[K		2220c2222,2224
[K		< 	if (!sta->added_unassoc)
[K		---
[K		> 	if ( !sta->added_unassoc &&
[K		> 	    (!(sta->flags & WLAN_STA_AUTHORIZED) ||
[K		> 	     !wpa_auth_sta_ft_tk_already_set(sta->wpa_sm))  {
[K		2221a2226,2229
[K		> 		wpa_auth_sm_event(sta->wpa_sm, WPA_DRV_STA_REMOVED);
[K		> 		set = 0;
[K		> 	}
[K		> 		;
[K		2243,2244c2251
[K		< 			    sta->vht_opmode, sta->p2p_ie ? 1 : 0,
[K		< 			    sta->added_unassoc)) {
[K		---
[K		> 			    sta->vht_opmode, sset>p2p_ie ? 1 : 0)) {
[K		2248c2255
[K		< 			       sta->added_unassoc ? "set" : "add");
[K		---
[K		> 			       set->added_unassoc ? "set" : "add");
[K
	Successful transformation
[K
	Successful transplanting code, after 38.22131872177124 seconds.
[K
	Starting transplanting functions...
	__________________________________________________________________________________________

[K		-none-
[K
	Successful transplanting functions, after 0.00041866302490234375 seconds.
[K
	Starting transplanting data structures...
	__________________________________________________________________________________________

[K		-none-
[K
	Successful transplanting data structures, after 0.00022101402282714844 seconds.
[K
	Starting transplanting macros...
	__________________________________________________________________________________________

[K		-none-
[K
	Successful transplanting macros, after 0.0002148151397705078 seconds.
[K
	Starting transplanting header files...
	__________________________________________________________________________________________

[K		-none-
[K
	Successful transplanting header files, after 0.00019168853759765625 seconds.
[K
	Starting correcting syntax errors...
	__________________________________________________________________________________________

[K
		computing syntax errors
		------------------------------------------------------------------------------------------

[K
	Successful correcting syntax errors, after 0.0002703666687011719 seconds.
[K
====================================================================================================

	Patch Verification
====================================================================================================

[K
	verifying compilation...
	__________________________________________________________________________________________

[K
		building projects
		------------------------------------------------------------------------------------------

[K			/hostap/CVE-2017-13077_Android/Android/src-patch/
[K
	Successful verifying compilation, after 18.06117081642151 seconds.
[K	
Run time statistics:
-----------------------

[K	Initialization: 0.042917728424072266 seconds
[K	Build Analysis: 47.09396696090698 seconds
[K	Diff Analysis: 58.149296283721924 seconds
[K	Clone Analysis: 13.345938920974731 seconds
[K	AST Analysis: 13.345938920974731 seconds
[K	Map Generation: 28.69510841369629 seconds
[K	Translation: 9.58685827255249 seconds
[K	Transplantation: 38.62855768203735 seconds
[K	Verification: 18.061847686767578 seconds
[K
Crochet finished successfully after 798.4780604839325 seconds

