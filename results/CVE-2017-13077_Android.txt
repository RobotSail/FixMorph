[K	

####################################################################################################

	Crochet - Horizontal Code Edit Transfer
	Test conducted on: 17-Jan-2020 (15:01:36.508853)

####################################################################################################
[K
====================================================================================================

	Initializing project for Transfer
====================================================================================================

[K
	loading configuration
	__________________________________________________________________________________________

[K		reading configuration values
[K
	set environment
	__________________________________________________________________________________________

[K		setting environment values
[K
====================================================================================================

	Building Projects
====================================================================================================

[K
	building binaries
	__________________________________________________________________________________________

[K
		restoring projects
		------------------------------------------------------------------------------------------

[K		/hostap/CVE-2017-13077_Android/hostap-2016/src/
[K		/hostap/CVE-2017-13077_Android/hostap-2017/src/
[K		/hostap/CVE-2017-13077_Android/Android/src/
[K		/hostap/CVE-2017-13077_Android/Android/src-patch/
[K
		cleaning projects
		------------------------------------------------------------------------------------------

[K		/hostap/CVE-2017-13077_Android/hostap-2016/src/
[K		/hostap/CVE-2017-13077_Android/hostap-2017/src/
[K		/hostap/CVE-2017-13077_Android/Android/src/
[K		/hostap/CVE-2017-13077_Android/Android/src-patch/
[K
		configuring projects
		------------------------------------------------------------------------------------------

[K		/hostap/CVE-2017-13077_Android/hostap-2016/src/
[K		/hostap/CVE-2017-13077_Android/hostap-2017/src/
[K		/hostap/CVE-2017-13077_Android/Android/src/
[K		/hostap/CVE-2017-13077_Android/Android/src-patch/
[K
		building projects
		------------------------------------------------------------------------------------------

[K		/hostap/CVE-2017-13077_Android/hostap-2016/src/
[K		/hostap/CVE-2017-13077_Android/hostap-2017/src/
[K		/hostap/CVE-2017-13077_Android/Android/src/
[K		/hostap/CVE-2017-13077_Android/Android/src-patch/
[K
	Successful building binaries, after 42.62270522117615 seconds.
[K
====================================================================================================

	Analysing Changes
====================================================================================================

[K
	analysing source diff
	__________________________________________________________________________________________

[K		finding changed files...
[K
		analysing header files
		------------------------------------------------------------------------------------------

[K			extracting changed header files...
[K			header files:
[K				/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth.h
[K				/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth_i.h
[K
		analysing C/CPP source files
		------------------------------------------------------------------------------------------

[K			extracting changed c/cpp files...
[K			source files:
[K				/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/ieee802_11.c
[K				/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth.c
[K				/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth_ft.c
[K
		analysing changed code segments
		------------------------------------------------------------------------------------------

[K			collecting diff info...
[K			/hostap/CVE-2017-13077_Android/hostap-2016/src/:
[K				add_associated_sta in Pa/ap/ieee802_11.c
[K				add_associated_sta 2628-2682[K[K			/hostap/CVE-2017-13077_Android/hostap-2017/src/:
[K				add_associated_sta in Pb/ap/ieee802_11.c
[K				add_associated_sta 2628-2692[K[K			/hostap/CVE-2017-13077_Android/hostap-2016/src/:
[K				wpa_auth_sm_event in Pa/ap/wpa_auth.c
[K				wpa_auth_sm_event 1708-1820[K[K				wpa_auth_sta_wpa_version in Pa/ap/wpa_auth.c
[K				wpa_auth_sta_wpa_version 3936-3941[K[K			/hostap/CVE-2017-13077_Android/hostap-2017/src/:
[K				wpa_auth_sm_event in Pb/ap/wpa_auth.c
[K				wpa_auth_sm_event 1708-1823[K[K				wpa_auth_sta_wpa_version in Pb/ap/wpa_auth.c
[K				wpa_auth_sta_wpa_version 3939-3944[K[K			/hostap/CVE-2017-13077_Android/hostap-2016/src/:
[K				wpa_ft_install_ptk in Pa/ap/wpa_auth_ft.c
[K				wpa_ft_install_ptk 1926-1952[K[K				wpa_ft_process_auth_req in Pa/ap/wpa_auth_ft.c
[K				wpa_ft_process_auth_req 2044-2189[K[K			/hostap/CVE-2017-13077_Android/hostap-2017/src/:
[K				wpa_ft_install_ptk in Pb/ap/wpa_auth_ft.c
[K				wpa_ft_install_ptk 1926-1961[K[K				wpa_ft_process_auth_req in Pb/ap/wpa_auth_ft.c
[K				wpa_ft_process_auth_req 2053-2199[K[K
	Successful analysing source diff, after 6.956268787384033 seconds.
[K
	analysing ast diff
	__________________________________________________________________________________________

[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth_ft.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:1951
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/ieee802_11.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:2642
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth_ft.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:2154
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/ieee802_11.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:2632
[K			filtering AST script by merging and grouping
[K			merging AST script
[K		line number:2639
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:1786
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth_ft.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:1939
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:3940
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
		/hostap/CVE-2017-13077_Android/hostap-2016/src/ap/ieee802_11.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:2669
[K			filtering AST script by merging and grouping
[K			merging AST script
[K		line number:2641
[K			filtering AST script by merging and grouping
[K			merging AST script
[K		line number:2665
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
	Successful analysing ast diff, after 51.10285973548889 seconds.
[K
====================================================================================================

	Clone Detection
====================================================================================================

[K
	generating vectors for target
	__________________________________________________________________________________________

[K
		Generating vector files for all functions in Target
		------------------------------------------------------------------------------------------

[K			generating vectors for *\.c files in Pc...
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/common/ctrl_iface_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/common/wpa_helpers.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/common/cli.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/common/wpa_ctrl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/wps/wps_registrar.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/wps/wps_validate.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/fst/fst.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/fst/fst_ctrl_aux.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/fst/fst_session.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/fst/fst_ctrl_iface.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/fst/fst_group.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/fst/fst_iface.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/vlan_ioctl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/taxonomy.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/acs.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/mbo_ap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/vlan_util.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/vlan_full.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/fils_hlp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/ap/ieee802_11_he.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/l2_packet/l2_packet_freebsd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/l2_packet/l2_packet_pcap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/l2_packet/l2_packet_privsep.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/l2_packet/l2_packet_winpcap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/l2_packet/l2_packet_ndis.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/l2_packet/l2_packet_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_otp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_sim.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_md5.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_pax.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_ikev2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_tnc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_gpsk.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_aka.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_fast_pac.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_pwd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_mschapv2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_psk.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_tls_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_fast.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_proxy_dummy.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/tncc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/ikev2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_ttls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_leap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_sake.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_gtc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_peap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_eke.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_wsc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/eap_tls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/eap_peer/mschapv2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/crypto/sha384.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_Android/Android/src/crypto/tls_openssl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_-2018-14526_11_1/FreeBSD-11.1/src/crypto/sha384-internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/crypto/tls_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/crypto/crypto_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/crypto/fips_prf_openssl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/crypto/crypto_gnutls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/crypto/tls_gnutls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/crypto/tls_openssl_ocsp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/crypto/crypto_openssl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/crypto/crypto_libtomcrypt.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/crypto/sha256-kdf.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/crypto/sha1-internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/crypto/sha384-prf.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/tls/libtommath.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/os_win32.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/ext_password.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/browser-system.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/os_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/browser-android.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/eloop_win.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/xml-utils.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/edit_simple.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/browser-wpadebug.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/http_curl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/browser.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/pcsc_funcs.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/os_internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/xml_libxml2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/utils/edit_readline.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_monitor.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_android.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_event.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_hostap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_privsep.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/linux_ioctl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_wext.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_ndis.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_bsd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/drivers.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_wired.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_atheros.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/ndis_events.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/netlink.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_nl80211.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_openbsd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_roboswitch.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_macsec_qca.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_capa.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/rfkill.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_scan.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/drivers/driver_ndis_.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_wsc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_gpsk.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_gtc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_eke.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_mschapv2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_tls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_pax.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_tls_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_md5.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_ikev2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_fast.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_peap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_sake.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_ttls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_sim.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_tnc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_aka.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_psk.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/tncs.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/ikev2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_sim_db.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/eap_server/eap_server_pwd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/pae/ieee802_1x_cp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/pae/ieee802_1x_kay.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/pae/ieee802_1x_key.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_11_1/FreeBSD-11.1/src/pae/ieee802_1x_secy_ops.c
[K
	Successful generating vectors for target, after 383.85918402671814 seconds.
[K
	finding clones in target
	__________________________________________________________________________________________

[K
		Finding clone functions in Target
		------------------------------------------------------------------------------------------

[K		checking vectors for C files in Pa...
[K		checking vectors for C files in Pc...
[K		finding clones for edited functions:

[K			Finding match for wpa_auth_sm_event in $Pa/ap/wpa_auth.c:
[K			Function: wpa_auth_sm_event in $Pc/ap/wpa_auth.c
[K			Distance: 0.0002533212110277353

[K			Finding match for add_associated_sta in $Pa/ap/ieee802_11.c:
[K			Function: add_associated_sta in $Pc/ap/ieee802_11.c
[K			Distance: 0.0

[K			Finding match for wpa_auth_sta_wpa_version in $Pa/ap/wpa_auth.c:
[K			Function: wpa_auth_sta_wpa_version in $Pc/ap/wpa_auth.c
[K			Distance: 0.0

[K			Finding match for wpa_ft_install_ptk in $Pa/ap/wpa_auth_ft.c:
[K			Function: wpa_ft_install_ptk in $Pc/ap/wpa_auth_ft.c
[K			Distance: 0.0

[K			Finding match for wpa_ft_process_auth_req in $Pa/ap/wpa_auth_ft.c:
[K			Function: wpa_ft_process_auth_req in $Pc/ap/wpa_auth_ft.c
[K			Distance: 2.545294166451336e-06

[K
	Successful finding clones in target, after 99.79832053184509 seconds.
[K
====================================================================================================

	Generating GumTree script for patch
====================================================================================================

[K
	Starting generating script for C files...
	__________________________________________________________________________________________

[K	Generating edit script: wpa_auth.c to wpa_auth.c...
[K	Generating edit script: ieee802_11.c to ieee802_11.c...
[K	Generating edit script: wpa_auth.c to wpa_auth.c...
[K	Generating edit script: wpa_auth_ft.c to wpa_auth_ft.c...
[K	Generating edit script: wpa_auth_ft.c to wpa_auth_ft.c...
[K
	Successful generating script for C files, after 12.1415696144104 seconds.
[K
====================================================================================================

	Variable Mapping
====================================================================================================

[K
	Variable mapping for C files
	__________________________________________________________________________________________

[K	Generating mapping: ieee802_11.c to ieee802_11.c...
[K	Generating mapping: wpa_auth.c to wpa_auth.c...
[K	Generating mapping: wpa_auth_ft.c to wpa_auth_ft.c...
[K
====================================================================================================

	Translate GumTree Script
====================================================================================================

[K
	Translating scripts for C files
	__________________________________________________________________________________________

[K	Generating JSON temp files for each pertinent file...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2016/src/ap/ieee802_11.c in Pa...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2017/src/ap/ieee802_11.c in Pb...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/Android/src/ap/ieee802_11.c in Pc...
[K	Failed at locating match for EnumConstantDecl(21537)
[K	Trying to get pos anyway.
[K	Failed at match for child.
[K	Generating JSON temp files for each pertinent file...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth.c in Pa...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2017/src/ap/wpa_auth.c in Pb...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/Android/src/ap/wpa_auth.c in Pc...
[K	Failed at locating match for EnumConstantDecl(12975)
[K	Trying to get pos anyway.
[K	Failed at locating match for CaseStmt(20068)
[K	Trying to get pos anyway.
[K	Failed at match for child.
[K	Generating JSON temp files for each pertinent file...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2016/src/ap/wpa_auth_ft.c in Pa...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/hostap-2017/src/ap/wpa_auth_ft.c in Pb...
[K			Clang AST parse /hostap/CVE-2017-13077_Android/Android/src/ap/wpa_auth_ft.c in Pc...
[K	Failed at locating match for EnumConstantDecl(11448)
[K	Trying to get pos anyway.
[K
====================================================================================================

	Applying transformation
====================================================================================================

[K
	Starting transplanting code...
	__________________________________________________________________________________________

[K
		/hostap/CVE-2017-13077_Android/Android/src/ap/wpa_auth.c
		------------------------------------------------------------------------------------------

[K	Original AST script
[K			AST Script:
[K				 Insert EnumConstantDecl(12976) EnumDecl(12966) 9
[K				 Insert FunctionDecl(13067) TranslationUnitDecl(0) 811
[K				 Insert TypeLoc(13068) FunctionDecl(13067) 0
[K				 Insert TypeLoc(13069) TypeLoc(13068) 0
[K				 Insert ParmVarDecl(13070) TypeLoc(13068) 1
[K				 Insert TypeLoc(13071) ParmVarDecl(13070) 0
[K				 Insert TypeLoc(13072) TypeLoc(13071) 0
[K				 Insert TypeLoc(13073) TypeLoc(13072) 0
[K				 Insert FieldDecl(14894) RecordDecl(14793) 31
[K				 Insert TypeLoc(14895) FieldDecl(14894) 0
[K				 Insert CaseStmt(20081) CompoundStmt(19989) 12
[K				 Insert DeclRefExpr(20082) CaseStmt(20081) 0
[K				 Insert BinaryOperator(20083) CaseStmt(20081) 1
[K				 Insert MemberExpr(20084) BinaryOperator(20083) 0
[K				 Insert DeclRefExpr(20085) MemberExpr(20084) 0
[K				 Insert DeclRefExpr(20086) BinaryOperator(20083) 1
[K				 Insert ReturnStmt(20087) CompoundStmt(19989) 13
[K				 Insert IntegerLiteral(20088) ReturnStmt(20087) 0
[K				 Insert FunctionDecl(24047) TranslationUnitDecl(0) 1059
[K				 Insert TypeLoc(24048) FunctionDecl(24047) 0
[K				 Insert TypeLoc(24049) TypeLoc(24048) 0
[K				 Insert ParmVarDecl(24050) TypeLoc(24048) 1
[K				 Insert TypeLoc(24051) ParmVarDecl(24050) 0
[K				 Insert TypeLoc(24052) TypeLoc(24051) 0
[K				 Insert TypeLoc(24053) TypeLoc(24052) 0
[K				 Insert CompoundStmt(24054) FunctionDecl(24047) 1
[K				 Insert IfStmt(24055) CompoundStmt(24054) 0
[K				 Insert BinaryOperator(24056) IfStmt(24055) 0
[K				 Insert UnaryOperator(24057) BinaryOperator(24056) 0
[K				 Insert DeclRefExpr(24058) UnaryOperator(24057) 0
[K				 Insert UnaryOperator(24059) BinaryOperator(24056) 1
[K				 Insert CallExpr(24060) UnaryOperator(24059) 0
[K				 Insert DeclRefExpr(24061) CallExpr(24060) 0
[K				 Insert MemberExpr(24062) CallExpr(24060) 1
[K				 Insert DeclRefExpr(24063) MemberExpr(24062) 0
[K				 Insert ReturnStmt(24064) IfStmt(24055) 1
[K				 Insert IntegerLiteral(24065) ReturnStmt(24064) 0
[K				 Insert ReturnStmt(24066) CompoundStmt(24054) 1
[K				 Insert MemberExpr(24067) ReturnStmt(24066) 0
[K				 Insert DeclRefExpr(24068) MemberExpr(24067) 0
[K	Generated AST script
[K			AST Script:
[K				 Insert EnumConstantDecl(12976) into EnumDecl(12837) at 9
[K				 Insert FunctionDecl(13067) into TranslationUnitDecl(0) at 801
[K				 Insert FieldDecl(14894) into RecordDecl(14475) at 30
[K				 Insert CaseStmt(20081) into CompoundStmt(19518) at 12
[K				 Insert ReturnStmt(20087) into CompoundStmt(19518) at 13
[K				 Insert FunctionDecl(24047) into TranslationUnitDecl(0) at 1032
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth.c
[K	Original Patch
[K		1786a1787,1789
[K		> 	case WPA_DRV_STA_REMOVED:
[K		> 		sm->tk_already_set = FALSE;
[K		> 		return 0;
[K		3940a3944,3951
[K		> }
[K		>
[K		>
[K		> int wpa_auth_sta_ft_tk_already_set(struct wpa_state_machine *sm)
[K		> {
[K		> 	if (!sm || !wpa_key_mgmt_ft(sm->wpa_key_mgmt))
[K		> 		return 0;
[K		> 	return sm->tk_already_set;
[K	Generated Patch
[K		1,4218d0
[K		< /*
[K		<  * IEEE 802.11 RSN / WPA Authenticator
[K		<  * Copyright (c) 2004-2015, Jouni Malinen <j@w1.fi>
[K		<  *
[K		<  * This software may be distributed under the terms of the BSD license.
[K		<  * See README for more details.
[K		<  */
[K		<
[K		< #include "utils/includes.h"
[K		<
[K		< #include "utils/common.h"
[K		< #include "utils/eloop.h"
[K		< #include "utils/state_machine.h"
[K		< #include "utils/bitfield.h"
[K		< #include "common/ieee802_11_defs.h"
[K		< #include "crypto/aes.h"
[K		< #include "crypto/aes_wrap.h"
[K		< #include "crypto/aes_siv.h"
[K		< #include "crypto/crypto.h"
[K		< #include "crypto/sha1.h"
[K		< #include "crypto/sha256.h"
[K		< #include "crypto/random.h"
[K		< #include "eapol_auth/eapol_auth_sm.h"
[K		< #include "ap_config.h"
[K		< #include "ieee802_11.h"
[K		< #include "wpa_auth.h"
[K		< #include "pmksa_cache_auth.h"
[K		< #include "wpa_auth_i.h"
[K		< #include "wpa_auth_ie.h"
[K		<
[K		< #define STATE_MACHINE_DATA struct wpa_state_machine
[K		< #define STATE_MACHINE_DEBUG_PREFIX "WPA"
[K		< #define STATE_MACHINE_ADDR sm->addr
[K		<
[K		<
[K		< static void wpa_send_eapol_timeout(void *eloop_ctx, void *timeout_ctx);
[K		< static int wpa_sm_step(struct wpa_state_machine *sm);
[K		< static int wpa_verify_key_mic(int akmp, struct wpa_ptk *PTK, u8 *data,
[K		< 			      size_t data_len);
[K		< #ifdef CONFIG_FILS
[K		< static int wpa_aead_decrypt(struct wpa_state_machine *sm, struct wpa_ptk *ptk,
[K		< 			    u8 *buf, size_t buf_len, u16 *_key_data_len);
[K		< #endif /* CONFIG_FILS */
[K		< static void wpa_sm_call_step(void *eloop_ctx, void *timeout_ctx);
[K		< static void wpa_group_sm_step(struct wpa_authenticator *wpa_auth,
[K		< 			      struct wpa_group *group);
[K		< static void wpa_request_new_ptk(struct wpa_state_machine *sm);
[K		< static int wpa_gtk_update(struct wpa_authenticator *wpa_auth,
[K		< 			  struct wpa_group *group);
[K		< static int wpa_group_config_group_keys(struct wpa_authenticator *wpa_auth,
[K		< 				       struct wpa_group *group);
[K		< static int wpa_derive_ptk(struct wpa_state_machine *sm, const u8 *snonce,
[K		< 			  const u8 *pmk, unsigned int pmk_len,
[K		< 			  struct wpa_ptk *ptk);
[K		< static void wpa_group_free(struct wpa_authenticator *wpa_auth,
[K		< 			   struct wpa_group *group);
[K		< static void wpa_group_get(struct wpa_authenticator *wpa_auth,
[K		< 			  struct wpa_group *group);
[K		< static void wpa_group_put(struct wpa_authenticator *wpa_auth,
[K		< 			  struct wpa_group *group);
[K		< static u8 * ieee80211w_kde_add(struct wpa_state_machine *sm, u8 *pos);
[K		<
[K		< static const u32 eapol_key_timeout_first = 100; /* ms */
[K		< static const u32 eapol_key_timeout_subseq = 1000; /* ms */
[K		< static const u32 eapol_key_timeout_first_group = 500; /* ms */
[K		<
[K		< /* TODO: make these configurable */
[K		< static const int dot11RSNAConfigPMKLifetime = 43200;
[K		< static const int dot11RSNAConfigPMKReauthThreshold = 70;
[K		< static const int dot11RSNAConfigSATimeout = 60;
[K		<
[K		<
[K		< static inline int wpa_auth_mic_failure_report(
[K		< 	struct wpa_authenticator *wpa_auth, const u8 *addr)
[K		< {
[K		< 	if (wpa_auth->cb->mic_failure_report)
[K		< 		return wpa_auth->cb->mic_failure_report(wpa_auth->cb_ctx, addr);
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static inline void wpa_auth_psk_failure_report(
[K		< 	struct wpa_authenticator *wpa_auth, const u8 *addr)
[K		< {
[K		< 	if (wpa_auth->cb->psk_failure_report)
[K		< 		wpa_auth->cb->psk_failure_report(wpa_auth->cb_ctx, addr);
[K		< }
[K		<
[K		<
[K		< static inline void wpa_auth_set_eapol(struct wpa_authenticator *wpa_auth,
[K		< 				      const u8 *addr, wpa_eapol_variable var,
[K		< 				      int value)
[K		< {
[K		< 	if (wpa_auth->cb->set_eapol)
[K		< 		wpa_auth->cb->set_eapol(wpa_auth->cb_ctx, addr, var, value);
[K		< }
[K		<
[K		<
[K		< static inline int wpa_auth_get_eapol(struct wpa_authenticator *wpa_auth,
[K		< 				     const u8 *addr, wpa_eapol_variable var)
[K		< {
[K		< 	if (wpa_auth->cb->get_eapol == NULL)
[K		< 		return -1;
[K		< 	return wpa_auth->cb->get_eapol(wpa_auth->cb_ctx, addr, var);
[K		< }
[K		<
[K		<
[K		< static inline const u8 * wpa_auth_get_psk(struct wpa_authenticator *wpa_auth,
[K		< 					  const u8 *addr,
[K		< 					  const u8 *p2p_dev_addr,
[K		< 					  const u8 *prev_psk)
[K		< {
[K		< 	if (wpa_auth->cb->get_psk == NULL)
[K		< 		return NULL;
[K		< 	return wpa_auth->cb->get_psk(wpa_auth->cb_ctx, addr, p2p_dev_addr,
[K		< 				     prev_psk);
[K		< }
[K		<
[K		<
[K		< static inline int wpa_auth_get_msk(struct wpa_authenticator *wpa_auth,
[K		< 				   const u8 *addr, u8 *msk, size_t *len)
[K		< {
[K		< 	if (wpa_auth->cb->get_msk == NULL)
[K		< 		return -1;
[K		< 	return wpa_auth->cb->get_msk(wpa_auth->cb_ctx, addr, msk, len);
[K		< }
[K		<
[K		<
[K		< static inline int wpa_auth_set_key(struct wpa_authenticator *wpa_auth,
[K		< 				   int vlan_id,
[K		< 				   enum wpa_alg alg, const u8 *addr, int idx,
[K		< 				   u8 *key, size_t key_len)
[K		< {
[K		< 	if (wpa_auth->cb->set_key == NULL)
[K		< 		return -1;
[K		< 	return wpa_auth->cb->set_key(wpa_auth->cb_ctx, vlan_id, alg, addr, idx,
[K		< 				     key, key_len);
[K		< }
[K		<
[K		<
[K		< static inline int wpa_auth_get_seqnum(struct wpa_authenticator *wpa_auth,
[K		< 				      const u8 *addr, int idx, u8 *seq)
[K		< {
[K		< 	if (wpa_auth->cb->get_seqnum == NULL)
[K		< 		return -1;
[K		< 	return wpa_auth->cb->get_seqnum(wpa_auth->cb_ctx, addr, idx, seq);
[K		< }
[K		<
[K		<
[K		< static inline int
[K		< wpa_auth_send_eapol(struct wpa_authenticator *wpa_auth, const u8 *addr,
[K		< 		    const u8 *data, size_t data_len, int encrypt)
[K		< {
[K		< 	if (wpa_auth->cb->send_eapol == NULL)
[K		< 		return -1;
[K		< 	return wpa_auth->cb->send_eapol(wpa_auth->cb_ctx, addr, data, data_len,
[K		< 					encrypt);
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_MESH
[K		< static inline int wpa_auth_start_ampe(struct wpa_authenticator *wpa_auth,
[K		< 				      const u8 *addr)
[K		< {
[K		< 	if (wpa_auth->cb->start_ampe == NULL)
[K		< 		return -1;
[K		< 	return wpa_auth->cb->start_ampe(wpa_auth->cb_ctx, addr);
[K		< }
[K		< #endif /* CONFIG_MESH */
[K		<
[K		<
[K		< int wpa_auth_for_each_sta(struct wpa_authenticator *wpa_auth,
[K		< 			  int (*cb)(struct wpa_state_machine *sm, void *ctx),
[K		< 			  void *cb_ctx)
[K		< {
[K		< 	if (wpa_auth->cb->for_each_sta == NULL)
[K		< 		return 0;
[K		< 	return wpa_auth->cb->for_each_sta(wpa_auth->cb_ctx, cb, cb_ctx);
[K		< }
[K		<
[K		<
[K		< int wpa_auth_for_each_auth(struct wpa_authenticator *wpa_auth,
[K		< 			   int (*cb)(struct wpa_authenticator *a, void *ctx),
[K		< 			   void *cb_ctx)
[K		< {
[K		< 	if (wpa_auth->cb->for_each_auth == NULL)
[K		< 		return 0;
[K		< 	return wpa_auth->cb->for_each_auth(wpa_auth->cb_ctx, cb, cb_ctx);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_logger(struct wpa_authenticator *wpa_auth, const u8 *addr,
[K		< 		     logger_level level, const char *txt)
[K		< {
[K		< 	if (wpa_auth->cb->logger == NULL)
[K		< 		return;
[K		< 	wpa_auth->cb->logger(wpa_auth->cb_ctx, addr, level, txt);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_vlogger(struct wpa_authenticator *wpa_auth, const u8 *addr,
[K		< 		      logger_level level, const char *fmt, ...)
[K		< {
[K		< 	char *format;
[K		< 	int maxlen;
[K		< 	va_list ap;
[K		<
[K		< 	if (wpa_auth->cb->logger == NULL)
[K		< 		return;
[K		<
[K		< 	maxlen = os_strlen(fmt) + 100;
[K		< 	format = os_malloc(maxlen);
[K		< 	if (!format)
[K		< 		return;
[K		<
[K		< 	va_start(ap, fmt);
[K		< 	vsnprintf(format, maxlen, fmt, ap);
[K		< 	va_end(ap);
[K		<
[K		< 	wpa_auth_logger(wpa_auth, addr, level, format);
[K		<
[K		< 	os_free(format);
[K		< }
[K		<
[K		<
[K		< static void wpa_sta_disconnect(struct wpa_authenticator *wpa_auth,
[K		< 			       const u8 *addr)
[K		< {
[K		< 	if (wpa_auth->cb->disconnect == NULL)
[K		< 		return;
[K		< 	wpa_printf(MSG_DEBUG, "wpa_sta_disconnect STA " MACSTR, MAC2STR(addr));
[K		< 	wpa_auth->cb->disconnect(wpa_auth->cb_ctx, addr,
[K		< 				 WLAN_REASON_PREV_AUTH_NOT_VALID);
[K		< }
[K		<
[K		<
[K		< static int wpa_use_aes_cmac(struct wpa_state_machine *sm)
[K		< {
[K		< 	int ret = 0;
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt))
[K		< 		ret = 1;
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (wpa_key_mgmt_sha256(sm->wpa_key_mgmt))
[K		< 		ret = 1;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	if (sm->wpa_key_mgmt == WPA_KEY_MGMT_OSEN)
[K		< 		ret = 1;
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< static void wpa_rekey_gmk(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = eloop_ctx;
[K		<
[K		< 	if (random_get_bytes(wpa_auth->group->GMK, WPA_GMK_LEN)) {
[K		< 		wpa_printf(MSG_ERROR, "Failed to get random data for WPA "
[K		< 			   "initialization.");
[K		< 	} else {
[K		< 		wpa_auth_logger(wpa_auth, NULL, LOGGER_DEBUG, "GMK rekeyd");
[K		< 		wpa_hexdump_key(MSG_DEBUG, "GMK",
[K		< 				wpa_auth->group->GMK, WPA_GMK_LEN);
[K		< 	}
[K		<
[K		< 	if (wpa_auth->conf.wpa_gmk_rekey) {
[K		< 		eloop_register_timeout(wpa_auth->conf.wpa_gmk_rekey, 0,
[K		< 				       wpa_rekey_gmk, wpa_auth, NULL);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< static void wpa_rekey_gtk(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = eloop_ctx;
[K		< 	struct wpa_group *group, *next;
[K		<
[K		< 	wpa_auth_logger(wpa_auth, NULL, LOGGER_DEBUG, "rekeying GTK");
[K		< 	group = wpa_auth->group;
[K		< 	while (group) {
[K		< 		wpa_group_get(wpa_auth, group);
[K		<
[K		< 		group->GTKReKey = TRUE;
[K		< 		do {
[K		< 			group->changed = FALSE;
[K		< 			wpa_group_sm_step(wpa_auth, group);
[K		< 		} while (group->changed);
[K		<
[K		< 		next = group->next;
[K		< 		wpa_group_put(wpa_auth, group);
[K		< 		group = next;
[K		< 	}
[K		<
[K		< 	if (wpa_auth->conf.wpa_group_rekey) {
[K		< 		eloop_register_timeout(wpa_auth->conf.wpa_group_rekey,
[K		< 				       0, wpa_rekey_gtk, wpa_auth, NULL);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< static void wpa_rekey_ptk(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = eloop_ctx;
[K		< 	struct wpa_state_machine *sm = timeout_ctx;
[K		<
[K		< 	wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG, "rekeying PTK");
[K		< 	wpa_request_new_ptk(sm);
[K		< 	wpa_sm_step(sm);
[K		< }
[K		<
[K		<
[K		< static int wpa_auth_pmksa_clear_cb(struct wpa_state_machine *sm, void *ctx)
[K		< {
[K		< 	if (sm->pmksa == ctx)
[K		< 		sm->pmksa = NULL;
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_auth_pmksa_free_cb(struct rsn_pmksa_cache_entry *entry,
[K		< 				   void *ctx)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = ctx;
[K		< 	wpa_auth_for_each_sta(wpa_auth, wpa_auth_pmksa_clear_cb, entry);
[K		< }
[K		<
[K		<
[K		< static int wpa_group_init_gmk_and_counter(struct wpa_authenticator *wpa_auth,
[K		< 					  struct wpa_group *group)
[K		< {
[K		< 	u8 buf[ETH_ALEN + 8 + sizeof(unsigned long)];
[K		< 	u8 rkey[32];
[K		< 	unsigned long ptr;
[K		<
[K		< 	if (random_get_bytes(group->GMK, WPA_GMK_LEN) < 0)
[K		< 		return -1;
[K		< 	wpa_hexdump_key(MSG_DEBUG, "GMK", group->GMK, WPA_GMK_LEN);
[K		<
[K		< 	/*
[K		< 	 * Counter = PRF-256(Random number, "Init Counter",
[K		< 	 *                   Local MAC Address || Time)
[K		< 	 */
[K		< 	os_memcpy(buf, wpa_auth->addr, ETH_ALEN);
[K		< 	wpa_get_ntp_timestamp(buf + ETH_ALEN);
[K		< 	ptr = (unsigned long) group;
[K		< 	os_memcpy(buf + ETH_ALEN + 8, &ptr, sizeof(ptr));
[K		< 	if (random_get_bytes(rkey, sizeof(rkey)) < 0)
[K		< 		return -1;
[K		<
[K		< 	if (sha1_prf(rkey, sizeof(rkey), "Init Counter", buf, sizeof(buf),
[K		< 		     group->Counter, WPA_NONCE_LEN) < 0)
[K		< 		return -1;
[K		< 	wpa_hexdump_key(MSG_DEBUG, "Key Counter",
[K		< 			group->Counter, WPA_NONCE_LEN);
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static struct wpa_group * wpa_group_init(struct wpa_authenticator *wpa_auth,
[K		< 					 int vlan_id, int delay_init)
[K		< {
[K		< 	struct wpa_group *group;
[K		<
[K		< 	group = os_zalloc(sizeof(struct wpa_group));
[K		< 	if (group == NULL)
[K		< 		return NULL;
[K		<
[K		< 	group->GTKAuthenticator = TRUE;
[K		< 	group->vlan_id = vlan_id;
[K		< 	group->GTK_len = wpa_cipher_key_len(wpa_auth->conf.wpa_group);
[K		<
[K		< 	if (random_pool_ready() != 1) {
[K		< 		wpa_printf(MSG_INFO, "WPA: Not enough entropy in random pool "
[K		< 			   "for secure operations - update keys later when "
[K		< 			   "the first station connects");
[K		< 	}
[K		<
[K		< 	/*
[K		< 	 * Set initial GMK/Counter value here. The actual values that will be
[K		< 	 * used in negotiations will be set once the first station tries to
[K		< 	 * connect. This allows more time for collecting additional randomness
[K		< 	 * on embedded devices.
[K		< 	 */
[K		< 	if (wpa_group_init_gmk_and_counter(wpa_auth, group) < 0) {
[K		< 		wpa_printf(MSG_ERROR, "Failed to get random data for WPA "
[K		< 			   "initialization.");
[K		< 		os_free(group);
[K		< 		return NULL;
[K		< 	}
[K		<
[K		< 	group->GInit = TRUE;
[K		< 	if (delay_init) {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Delay group state machine start "
[K		< 			   "until Beacon frames have been configured");
[K		< 		/* Initialization is completed in wpa_init_keys(). */
[K		< 	} else {
[K		< 		wpa_group_sm_step(wpa_auth, group);
[K		< 		group->GInit = FALSE;
[K		< 		wpa_group_sm_step(wpa_auth, group);
[K		< 	}
[K		<
[K		< 	return group;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_init - Initialize WPA authenticator
[K		<  * @addr: Authenticator address
[K		<  * @conf: Configuration for WPA authenticator
[K		<  * @cb: Callback functions for WPA authenticator
[K		<  * Returns: Pointer to WPA authenticator data or %NULL on failure
[K		<  */
[K		< struct wpa_authenticator * wpa_init(const u8 *addr,
[K		< 				    struct wpa_auth_config *conf,
[K		< 				    const struct wpa_auth_callbacks *cb,
[K		< 				    void *cb_ctx)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth;
[K		<
[K		< 	wpa_auth = os_zalloc(sizeof(struct wpa_authenticator));
[K		< 	if (wpa_auth == NULL)
[K		< 		return NULL;
[K		< 	os_memcpy(wpa_auth->addr, addr, ETH_ALEN);
[K		< 	os_memcpy(&wpa_auth->conf, conf, sizeof(*conf));
[K		< 	wpa_auth->cb = cb;
[K		< 	wpa_auth->cb_ctx = cb_ctx;
[K		<
[K		< 	if (wpa_auth_gen_wpa_ie(wpa_auth)) {
[K		< 		wpa_printf(MSG_ERROR, "Could not generate WPA IE.");
[K		< 		os_free(wpa_auth);
[K		< 		return NULL;
[K		< 	}
[K		<
[K		< 	wpa_auth->group = wpa_group_init(wpa_auth, 0, 1);
[K		< 	if (wpa_auth->group == NULL) {
[K		< 		os_free(wpa_auth->wpa_ie);
[K		< 		os_free(wpa_auth);
[K		< 		return NULL;
[K		< 	}
[K		<
[K		< 	wpa_auth->pmksa = pmksa_cache_auth_init(wpa_auth_pmksa_free_cb,
[K		< 						wpa_auth);
[K		< 	if (wpa_auth->pmksa == NULL) {
[K		< 		wpa_printf(MSG_ERROR, "PMKSA cache initialization failed.");
[K		< 		os_free(wpa_auth->group);
[K		< 		os_free(wpa_auth->wpa_ie);
[K		< 		os_free(wpa_auth);
[K		< 		return NULL;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	wpa_auth->ft_pmk_cache = wpa_ft_pmk_cache_init();
[K		< 	if (wpa_auth->ft_pmk_cache == NULL) {
[K		< 		wpa_printf(MSG_ERROR, "FT PMK cache initialization failed.");
[K		< 		os_free(wpa_auth->group);
[K		< 		os_free(wpa_auth->wpa_ie);
[K		< 		pmksa_cache_auth_deinit(wpa_auth->pmksa);
[K		< 		os_free(wpa_auth);
[K		< 		return NULL;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		< 	if (wpa_auth->conf.wpa_gmk_rekey) {
[K		< 		eloop_register_timeout(wpa_auth->conf.wpa_gmk_rekey, 0,
[K		< 				       wpa_rekey_gmk, wpa_auth, NULL);
[K		< 	}
[K		<
[K		< 	if (wpa_auth->conf.wpa_group_rekey) {
[K		< 		eloop_register_timeout(wpa_auth->conf.wpa_group_rekey, 0,
[K		< 				       wpa_rekey_gtk, wpa_auth, NULL);
[K		< 	}
[K		<
[K		< #ifdef CONFIG_P2P
[K		< 	if (WPA_GET_BE32(conf->ip_addr_start)) {
[K		< 		int count = WPA_GET_BE32(conf->ip_addr_end) -
[K		< 			WPA_GET_BE32(conf->ip_addr_start) + 1;
[K		< 		if (count > 1000)
[K		< 			count = 1000;
[K		< 		if (count > 0)
[K		< 			wpa_auth->ip_pool = bitfield_alloc(count);
[K		< 	}
[K		< #endif /* CONFIG_P2P */
[K		<
[K		< 	return wpa_auth;
[K		< }
[K		<
[K		<
[K		< int wpa_init_keys(struct wpa_authenticator *wpa_auth)
[K		< {
[K		< 	struct wpa_group *group = wpa_auth->group;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Start group state machine to set initial "
[K		< 		   "keys");
[K		< 	wpa_group_sm_step(wpa_auth, group);
[K		< 	group->GInit = FALSE;
[K		< 	wpa_group_sm_step(wpa_auth, group);
[K		< 	if (group->wpa_group_state == WPA_GROUP_FATAL_FAILURE)
[K		< 		return -1;
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_deinit - Deinitialize WPA authenticator
[K		<  * @wpa_auth: Pointer to WPA authenticator data from wpa_init()
[K		<  */
[K		< void wpa_deinit(struct wpa_authenticator *wpa_auth)
[K		< {
[K		< 	struct wpa_group *group, *prev;
[K		<
[K		< 	eloop_cancel_timeout(wpa_rekey_gmk, wpa_auth, NULL);
[K		< 	eloop_cancel_timeout(wpa_rekey_gtk, wpa_auth, NULL);
[K		<
[K		< 	pmksa_cache_auth_deinit(wpa_auth->pmksa);
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	wpa_ft_pmk_cache_deinit(wpa_auth->ft_pmk_cache);
[K		< 	wpa_auth->ft_pmk_cache = NULL;
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		< #ifdef CONFIG_P2P
[K		< 	bitfield_free(wpa_auth->ip_pool);
[K		< #endif /* CONFIG_P2P */
[K		<
[K		<
[K		< 	os_free(wpa_auth->wpa_ie);
[K		<
[K		< 	group = wpa_auth->group;
[K		< 	while (group) {
[K		< 		prev = group;
[K		< 		group = group->next;
[K		< 		os_free(prev);
[K		< 	}
[K		<
[K		< 	os_free(wpa_auth);
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_reconfig - Update WPA authenticator configuration
[K		<  * @wpa_auth: Pointer to WPA authenticator data from wpa_init()
[K		<  * @conf: Configuration for WPA authenticator
[K		<  */
[K		< int wpa_reconfig(struct wpa_authenticator *wpa_auth,
[K		< 		 struct wpa_auth_config *conf)
[K		< {
[K		< 	struct wpa_group *group;
[K		< 	if (wpa_auth == NULL)
[K		< 		return 0;
[K		<
[K		< 	os_memcpy(&wpa_auth->conf, conf, sizeof(*conf));
[K		< 	if (wpa_auth_gen_wpa_ie(wpa_auth)) {
[K		< 		wpa_printf(MSG_ERROR, "Could not generate WPA IE.");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	/*
[K		< 	 * Reinitialize GTK to make sure it is suitable for the new
[K		< 	 * configuration.
[K		< 	 */
[K		< 	group = wpa_auth->group;
[K		< 	group->GTK_len = wpa_cipher_key_len(wpa_auth->conf.wpa_group);
[K		< 	group->GInit = TRUE;
[K		< 	wpa_group_sm_step(wpa_auth, group);
[K		< 	group->GInit = FALSE;
[K		< 	wpa_group_sm_step(wpa_auth, group);
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< struct wpa_state_machine *
[K		< wpa_auth_sta_init(struct wpa_authenticator *wpa_auth, const u8 *addr,
[K		< 		  const u8 *p2p_dev_addr)
[K		< {
[K		< 	struct wpa_state_machine *sm;
[K		<
[K		< 	if (wpa_auth->group->wpa_group_state == WPA_GROUP_FATAL_FAILURE)
[K		< 		return NULL;
[K		<
[K		< 	sm = os_zalloc(sizeof(struct wpa_state_machine));
[K		< 	if (sm == NULL)
[K		< 		return NULL;
[K		< 	os_memcpy(sm->addr, addr, ETH_ALEN);
[K		< 	if (p2p_dev_addr)
[K		< 		os_memcpy(sm->p2p_dev_addr, p2p_dev_addr, ETH_ALEN);
[K		<
[K		< 	sm->wpa_auth = wpa_auth;
[K		< 	sm->group = wpa_auth->group;
[K		< 	wpa_group_get(sm->wpa_auth, sm->group);
[K		<
[K		< 	return sm;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_sta_associated(struct wpa_authenticator *wpa_auth,
[K		< 			    struct wpa_state_machine *sm)
[K		< {
[K		< 	if (wpa_auth == NULL || !wpa_auth->conf.wpa || sm == NULL)
[K		< 		return -1;
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (sm->ft_completed) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"FT authentication already completed - do not "
[K		< 				"start 4-way handshake");
[K		< 		/* Go to PTKINITDONE state to allow GTK rekeying */
[K		< 		sm->wpa_ptk_state = WPA_PTK_PTKINITDONE;
[K		< 		sm->Pair = TRUE;
[K		< 		return 0;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		< #ifdef CONFIG_FILS
[K		< 	if (sm->fils_completed) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"FILS authentication already completed - do not start 4-way handshake");
[K		< 		/* Go to PTKINITDONE state to allow GTK rekeying */
[K		< 		sm->wpa_ptk_state = WPA_PTK_PTKINITDONE;
[K		< 		sm->Pair = TRUE;
[K		< 		return 0;
[K		< 	}
[K		< #endif /* CONFIG_FILS */
[K		<
[K		< 	if (sm->started) {
[K		< 		os_memset(&sm->key_replay, 0, sizeof(sm->key_replay));
[K		< 		sm->ReAuthenticationRequest = TRUE;
[K		< 		return wpa_sm_step(sm);
[K		< 	}
[K		<
[K		< 	wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 			"start authentication");
[K		< 	sm->started = 1;
[K		<
[K		< 	sm->Init = TRUE;
[K		< 	if (wpa_sm_step(sm) == 1)
[K		< 		return 1; /* should not really happen */
[K		< 	sm->Init = FALSE;
[K		< 	sm->AuthenticationRequest = TRUE;
[K		< 	return wpa_sm_step(sm);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_sta_no_wpa(struct wpa_state_machine *sm)
[K		< {
[K		< 	/* WPA/RSN was not used - clear WPA state. This is needed if the STA
[K		< 	 * reassociates back to the same AP while the previous entry for the
[K		< 	 * STA has not yet been removed. */
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	sm->wpa_key_mgmt = 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_free_sta_sm(struct wpa_state_machine *sm)
[K		< {
[K		< #ifdef CONFIG_P2P
[K		< 	if (WPA_GET_BE32(sm->ip_addr)) {
[K		< 		u32 start;
[K		< 		wpa_printf(MSG_DEBUG, "P2P: Free assigned IP "
[K		< 			   "address %u.%u.%u.%u from " MACSTR,
[K		< 			   sm->ip_addr[0], sm->ip_addr[1],
[K		< 			   sm->ip_addr[2], sm->ip_addr[3],
[K		< 			   MAC2STR(sm->addr));
[K		< 		start = WPA_GET_BE32(sm->wpa_auth->conf.ip_addr_start);
[K		< 		bitfield_clear(sm->wpa_auth->ip_pool,
[K		< 			       WPA_GET_BE32(sm->ip_addr) - start);
[K		< 	}
[K		< #endif /* CONFIG_P2P */
[K		< 	if (sm->GUpdateStationKeys) {
[K		< 		sm->group->GKeyDoneStations--;
[K		< 		sm->GUpdateStationKeys = FALSE;
[K		< 	}
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	os_free(sm->assoc_resp_ftie);
[K		< 	wpabuf_free(sm->ft_pending_req_ies);
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< 	os_free(sm->last_rx_eapol_key);
[K		< 	os_free(sm->wpa_ie);
[K		< 	wpa_group_put(sm->wpa_auth, sm->group);
[K		< 	os_free(sm);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_sta_deinit(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	if (sm->wpa_auth->conf.wpa_strict_rekey && sm->has_GTK) {
[K		< 		wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"strict rekeying - force GTK rekey since STA "
[K		< 				"is leaving");
[K		< 		eloop_cancel_timeout(wpa_rekey_gtk, sm->wpa_auth, NULL);
[K		< 		eloop_register_timeout(0, 500000, wpa_rekey_gtk, sm->wpa_auth,
[K		< 				       NULL);
[K		< 	}
[K		<
[K		< 	eloop_cancel_timeout(wpa_send_eapol_timeout, sm->wpa_auth, sm);
[K		< 	sm->pending_1_of_4_timeout = 0;
[K		< 	eloop_cancel_timeout(wpa_sm_call_step, sm, NULL);
[K		< 	eloop_cancel_timeout(wpa_rekey_ptk, sm->wpa_auth, sm);
[K		< 	if (sm->in_step_loop) {
[K		< 		/* Must not free state machine while wpa_sm_step() is running.
[K		< 		 * Freeing will be completed in the end of wpa_sm_step(). */
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Registering pending STA state "
[K		< 			   "machine deinit for " MACSTR, MAC2STR(sm->addr));
[K		< 		sm->pending_deinit = 1;
[K		< 	} else
[K		< 		wpa_free_sta_sm(sm);
[K		< }
[K		<
[K		<
[K		< static void wpa_request_new_ptk(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	sm->PTKRequest = TRUE;
[K		< 	sm->PTK_valid = 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_replay_counter_valid(struct wpa_key_replay_counter *ctr,
[K		< 				    const u8 *replay_counter)
[K		< {
[K		< 	int i;
[K		< 	for (i = 0; i < RSNA_MAX_EAPOL_RETRIES; i++) {
[K		< 		if (!ctr[i].valid)
[K		< 			break;
[K		< 		if (os_memcmp(replay_counter, ctr[i].counter,
[K		< 			      WPA_REPLAY_COUNTER_LEN) == 0)
[K		< 			return 1;
[K		< 	}
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_replay_counter_mark_invalid(struct wpa_key_replay_counter *ctr,
[K		< 					    const u8 *replay_counter)
[K		< {
[K		< 	int i;
[K		< 	for (i = 0; i < RSNA_MAX_EAPOL_RETRIES; i++) {
[K		< 		if (ctr[i].valid &&
[K		< 		    (replay_counter == NULL ||
[K		< 		     os_memcmp(replay_counter, ctr[i].counter,
[K		< 			       WPA_REPLAY_COUNTER_LEN) == 0))
[K		< 			ctr[i].valid = FALSE;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< static int ft_check_msg_2_of_4(struct wpa_authenticator *wpa_auth,
[K		< 			       struct wpa_state_machine *sm,
[K		< 			       struct wpa_eapol_ie_parse *kde)
[K		< {
[K		< 	struct wpa_ie_data ie;
[K		< 	struct rsn_mdie *mdie;
[K		<
[K		< 	if (wpa_parse_wpa_ie_rsn(kde->rsn_ie, kde->rsn_ie_len, &ie) < 0 ||
[K		< 	    ie.num_pmkid != 1 || ie.pmkid == NULL) {
[K		< 		wpa_printf(MSG_DEBUG, "FT: No PMKR1Name in "
[K		< 			   "FT 4-way handshake message 2/4");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	os_memcpy(sm->sup_pmk_r1_name, ie.pmkid, PMKID_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "FT: PMKR1Name from Supplicant",
[K		< 		    sm->sup_pmk_r1_name, PMKID_LEN);
[K		<
[K		< 	if (!kde->mdie || !kde->ftie) {
[K		< 		wpa_printf(MSG_DEBUG, "FT: No %s in FT 4-way handshake "
[K		< 			   "message 2/4", kde->mdie ? "FTIE" : "MDIE");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	mdie = (struct rsn_mdie *) (kde->mdie + 2);
[K		< 	if (kde->mdie[1] < sizeof(struct rsn_mdie) ||
[K		< 	    os_memcmp(wpa_auth->conf.mobility_domain, mdie->mobility_domain,
[K		< 		      MOBILITY_DOMAIN_ID_LEN) != 0) {
[K		< 		wpa_printf(MSG_DEBUG, "FT: MDIE mismatch");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (sm->assoc_resp_ftie &&
[K		< 	    (kde->ftie[1] != sm->assoc_resp_ftie[1] ||
[K		< 	     os_memcmp(kde->ftie, sm->assoc_resp_ftie,
[K		< 		       2 + sm->assoc_resp_ftie[1]) != 0)) {
[K		< 		wpa_printf(MSG_DEBUG, "FT: FTIE mismatch");
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: FTIE in EAPOL-Key msg 2/4",
[K		< 			    kde->ftie, kde->ftie_len);
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: FTIE in (Re)AssocResp",
[K		< 			    sm->assoc_resp_ftie, 2 + sm->assoc_resp_ftie[1]);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		<
[K		< static int wpa_receive_error_report(struct wpa_authenticator *wpa_auth,
[K		< 				    struct wpa_state_machine *sm, int group)
[K		< {
[K		< 	/* Supplicant reported a Michael MIC error */
[K		< 	wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 			 "received EAPOL-Key Error Request "
[K		< 			 "(STA detected Michael MIC failure (group=%d))",
[K		< 			 group);
[K		<
[K		< 	if (group && wpa_auth->conf.wpa_group != WPA_CIPHER_TKIP) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"ignore Michael MIC failure report since "
[K		< 				"group cipher is not TKIP");
[K		< 	} else if (!group && sm->pairwise != WPA_CIPHER_TKIP) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"ignore Michael MIC failure report since "
[K		< 				"pairwise cipher is not TKIP");
[K		< 	} else {
[K		< 		if (wpa_auth_mic_failure_report(wpa_auth, sm->addr) > 0)
[K		< 			return 1; /* STA entry was removed */
[K		< 		sm->dot11RSNAStatsTKIPRemoteMICFailures++;
[K		< 		wpa_auth->dot11RSNAStatsTKIPRemoteMICFailures++;
[K		< 	}
[K		<
[K		< 	/*
[K		< 	 * Error report is not a request for a new key handshake, but since
[K		< 	 * Authenticator may do it, let's change the keys now anyway.
[K		< 	 */
[K		< 	wpa_request_new_ptk(sm);
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_try_alt_snonce(struct wpa_state_machine *sm, u8 *data,
[K		< 			      size_t data_len)
[K		< {
[K		< 	struct wpa_ptk PTK;
[K		< 	int ok = 0;
[K		< 	const u8 *pmk = NULL;
[K		< 	unsigned int pmk_len;
[K		<
[K		< 	os_memset(&PTK, 0, sizeof(PTK));
[K		< 	for (;;) {
[K		< 		if (wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt)) {
[K		< 			pmk = wpa_auth_get_psk(sm->wpa_auth, sm->addr,
[K		< 					       sm->p2p_dev_addr, pmk);
[K		< 			if (pmk == NULL)
[K		< 				break;
[K		< 			pmk_len = PMK_LEN;
[K		< 		} else {
[K		< 			pmk = sm->PMK;
[K		< 			pmk_len = sm->pmk_len;
[K		< 		}
[K		<
[K		< 		if (wpa_derive_ptk(sm, sm->alt_SNonce, pmk, pmk_len, &PTK) < 0)
[K		< 			break;
[K		<
[K		< 		if (wpa_verify_key_mic(sm->wpa_key_mgmt, &PTK, data, data_len)
[K		< 		    == 0) {
[K		< 			ok = 1;
[K		< 			break;
[K		< 		}
[K		<
[K		< 		if (!wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt))
[K		< 			break;
[K		< 	}
[K		<
[K		< 	if (!ok) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "WPA: Earlier SNonce did not result in matching MIC");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	wpa_printf(MSG_DEBUG,
[K		< 		   "WPA: Earlier SNonce resulted in matching MIC");
[K		< 	sm->alt_snonce_valid = 0;
[K		< 	os_memcpy(sm->SNonce, sm->alt_SNonce, WPA_NONCE_LEN);
[K		< 	os_memcpy(&sm->PTK, &PTK, sizeof(PTK));
[K		< 	sm->PTK_valid = TRUE;
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< void wpa_receive(struct wpa_authenticator *wpa_auth,
[K		< 		 struct wpa_state_machine *sm,
[K		< 		 u8 *data, size_t data_len)
[K		< {
[K		< 	struct ieee802_1x_hdr *hdr;
[K		< 	struct wpa_eapol_key *key;
[K		< 	u16 key_info, key_data_length;
[K		< 	enum { PAIRWISE_2, PAIRWISE_4, GROUP_2, REQUEST,
[K		< 	       SMK_M1, SMK_M3, SMK_ERROR } msg;
[K		< 	char *msgtxt;
[K		< 	struct wpa_eapol_ie_parse kde;
[K		< 	const u8 *key_data;
[K		< 	size_t keyhdrlen, mic_len;
[K		< 	u8 *mic;
[K		<
[K		< 	if (wpa_auth == NULL || !wpa_auth->conf.wpa || sm == NULL)
[K		< 		return;
[K		< 	wpa_hexdump(MSG_MSGDUMP, "WPA: RX EAPOL data", data, data_len);
[K		<
[K		< 	mic_len = wpa_mic_len(sm->wpa_key_mgmt);
[K		< 	keyhdrlen = sizeof(*key) + mic_len + 2;
[K		<
[K		< 	if (data_len < sizeof(*hdr) + keyhdrlen) {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Ignore too short EAPOL-Key frame");
[K		< 		return;
[K		< 	}
[K		<
[K		< 	hdr = (struct ieee802_1x_hdr *) data;
[K		< 	key = (struct wpa_eapol_key *) (hdr + 1);
[K		< 	mic = (u8 *) (key + 1);
[K		< 	key_info = WPA_GET_BE16(key->key_info);
[K		< 	key_data = mic + mic_len + 2;
[K		< 	key_data_length = WPA_GET_BE16(mic + mic_len);
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Received EAPOL-Key from " MACSTR
[K		< 		   " key_info=0x%x type=%u mic_len=%u key_data_length=%u",
[K		< 		   MAC2STR(sm->addr), key_info, key->type,
[K		< 		   (unsigned int) mic_len, key_data_length);
[K		< 	wpa_hexdump(MSG_MSGDUMP,
[K		< 		    "WPA: EAPOL-Key header (ending before Key MIC)",
[K		< 		    key, sizeof(*key));
[K		< 	wpa_hexdump(MSG_MSGDUMP, "WPA: EAPOL-Key Key MIC",
[K		< 		    mic, mic_len);
[K		< 	if (key_data_length > data_len - sizeof(*hdr) - keyhdrlen) {
[K		< 		wpa_printf(MSG_INFO, "WPA: Invalid EAPOL-Key frame - "
[K		< 			   "key_data overflow (%d > %lu)",
[K		< 			   key_data_length,
[K		< 			   (unsigned long) (data_len - sizeof(*hdr) -
[K		< 					    keyhdrlen));
[K		< 		return;
[K		< 	}
[K		<
[K		< 	if (sm->wpa == WPA_VERSION_WPA2) {
[K		< 		if (key->type == EAPOL_KEY_TYPE_WPA) {
[K		< 			/*
[K		< 			 * Some deployed station implementations seem to send
[K		< 			 * msg 4/4 with incorrect type value in WPA2 mode.
[K		< 			 */
[K		< 			wpa_printf(MSG_DEBUG, "Workaround: Allow EAPOL-Key "
[K		< 				   "with unexpected WPA type in RSN mode");
[K		< 		} else if (key->type != EAPOL_KEY_TYPE_RSN) {
[K		< 			wpa_printf(MSG_DEBUG, "Ignore EAPOL-Key with "
[K		< 				   "unexpected type %d in RSN mode",
[K		< 				   key->type);
[K		< 			return;
[K		< 		}
[K		< 	} else {
[K		< 		if (key->type != EAPOL_KEY_TYPE_WPA) {
[K		< 			wpa_printf(MSG_DEBUG, "Ignore EAPOL-Key with "
[K		< 				   "unexpected type %d in WPA mode",
[K		< 				   key->type);
[K		< 			return;
[K		< 		}
[K		< 	}
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: Received Key Nonce", key->key_nonce,
[K		< 		    WPA_NONCE_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: Received Replay Counter",
[K		< 		    key->replay_counter, WPA_REPLAY_COUNTER_LEN);
[K		<
[K		< 	/* FIX: verify that the EAPOL-Key frame was encrypted if pairwise keys
[K		< 	 * are set */
[K		<
[K		< 	if ((key_info & (WPA_KEY_INFO_SMK_MESSAGE | WPA_KEY_INFO_REQUEST)) ==
[K		< 	    (WPA_KEY_INFO_SMK_MESSAGE | WPA_KEY_INFO_REQUEST)) {
[K		< 		if (key_info & WPA_KEY_INFO_ERROR) {
[K		< 			msg = SMK_ERROR;
[K		< 			msgtxt = "SMK Error";
[K		< 		} else {
[K		< 			msg = SMK_M1;
[K		< 			msgtxt = "SMK M1";
[K		< 		}
[K		< 	} else if (key_info & WPA_KEY_INFO_SMK_MESSAGE) {
[K		< 		msg = SMK_M3;
[K		< 		msgtxt = "SMK M3";
[K		< 	} else if (key_info & WPA_KEY_INFO_REQUEST) {
[K		< 		msg = REQUEST;
[K		< 		msgtxt = "Request";
[K		< 	} else if (!(key_info & WPA_KEY_INFO_KEY_TYPE)) {
[K		< 		msg = GROUP_2;
[K		< 		msgtxt = "2/2 Group";
[K		< 	} else if (key_data_length == 0 ||
[K		< 		   (mic_len == 0 && (key_info & WPA_KEY_INFO_ENCR_KEY_DATA) &&
[K		< 		    key_data_length == AES_BLOCK_SIZE)) {
[K		< 		msg = PAIRWISE_4;
[K		< 		msgtxt = "4/4 Pairwise";
[K		< 	} else {
[K		< 		msg = PAIRWISE_2;
[K		< 		msgtxt = "2/4 Pairwise";
[K		< 	}
[K		<
[K		< 	/* TODO: key_info type validation for PeerKey */
[K		< 	if (msg == REQUEST || msg == PAIRWISE_2 || msg == PAIRWISE_4 ||
[K		< 	    msg == GROUP_2) {
[K		< 		u16 ver = key_info & WPA_KEY_INFO_TYPE_MASK;
[K		< 		if (sm->pairwise == WPA_CIPHER_CCMP ||
[K		< 		    sm->pairwise == WPA_CIPHER_GCMP) {
[K		< 			if (wpa_use_aes_cmac(sm) &&
[K		< 			    sm->wpa_key_mgmt != WPA_KEY_MGMT_OSEN &&
[K		< 			    !wpa_key_mgmt_suite_b(sm->wpa_key_mgmt) &&
[K		< 			    !wpa_key_mgmt_fils(sm->wpa_key_mgmt) &&
[K		< 			    ver != WPA_KEY_INFO_TYPE_AES_128_CMAC) {
[K		< 				wpa_auth_logger(wpa_auth, sm->addr,
[K		< 						LOGGER_WARNING,
[K		< 						"advertised support for "
[K		< 						"AES-128-CMAC, but did not "
[K		< 						"use it");
[K		< 				return;
[K		< 			}
[K		<
[K		< 			if (!wpa_use_aes_cmac(sm) &&
[K		< 			    !wpa_key_mgmt_fils(sm->wpa_key_mgmt) &&
[K		< 			    ver != WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
[K		< 				wpa_auth_logger(wpa_auth, sm->addr,
[K		< 						LOGGER_WARNING,
[K		< 						"did not use HMAC-SHA1-AES "
[K		< 						"with CCMP/GCMP");
[K		< 				return;
[K		< 			}
[K		< 		}
[K		<
[K		< 		if ((wpa_key_mgmt_suite_b(sm->wpa_key_mgmt) ||
[K		< 		     wpa_key_mgmt_fils(sm->wpa_key_mgmt)) &&
[K		< 		    ver != WPA_KEY_INFO_TYPE_AKM_DEFINED) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_WARNING,
[K		< 					"did not use EAPOL-Key descriptor version 0 as required for AKM-defined cases");
[K		< 			return;
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_REQUEST) {
[K		< 		if (sm->req_replay_counter_used &&
[K		< 		    os_memcmp(key->replay_counter, sm->req_replay_counter,
[K		< 			      WPA_REPLAY_COUNTER_LEN) <= 0) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_WARNING,
[K		< 					"received EAPOL-Key request with "
[K		< 					"replayed counter");
[K		< 			return;
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (!(key_info & WPA_KEY_INFO_REQUEST) &&
[K		< 	    !wpa_replay_counter_valid(sm->key_replay, key->replay_counter)) {
[K		< 		int i;
[K		<
[K		< 		if (msg == PAIRWISE_2 &&
[K		< 		    wpa_replay_counter_valid(sm->prev_key_replay,
[K		< 					     key->replay_counter) &&
[K		< 		    sm->wpa_ptk_state == WPA_PTK_PTKINITNEGOTIATING &&
[K		< 		    os_memcmp(sm->SNonce, key->key_nonce, WPA_NONCE_LEN) != 0)
[K		< 		{
[K		< 			/*
[K		< 			 * Some supplicant implementations (e.g., Windows XP
[K		< 			 * WZC) update SNonce for each EAPOL-Key 2/4. This
[K		< 			 * breaks the workaround on accepting any of the
[K		< 			 * pending requests, so allow the SNonce to be updated
[K		< 			 * even if we have already sent out EAPOL-Key 3/4.
[K		< 			 */
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					 "Process SNonce update from STA "
[K		< 					 "based on retransmitted EAPOL-Key "
[K		< 					 "1/4");
[K		< 			sm->update_snonce = 1;
[K		< 			os_memcpy(sm->alt_SNonce, sm->SNonce, WPA_NONCE_LEN);
[K		< 			sm->alt_snonce_valid = TRUE;
[K		< 			os_memcpy(sm->alt_replay_counter,
[K		< 				  sm->key_replay[0].counter,
[K		< 				  WPA_REPLAY_COUNTER_LEN);
[K		< 			goto continue_processing;
[K		< 		}
[K		<
[K		< 		if (msg == PAIRWISE_4 && sm->alt_snonce_valid &&
[K		< 		    sm->wpa_ptk_state == WPA_PTK_PTKINITNEGOTIATING &&
[K		< 		    os_memcmp(key->replay_counter, sm->alt_replay_counter,
[K		< 			      WPA_REPLAY_COUNTER_LEN) == 0) {
[K		< 			/*
[K		< 			 * Supplicant may still be using the old SNonce since
[K		< 			 * there was two EAPOL-Key 2/4 messages and they had
[K		< 			 * different SNonce values.
[K		< 			 */
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					 "Try to process received EAPOL-Key 4/4 based on old Replay Counter and SNonce from an earlier EAPOL-Key 1/4");
[K		< 			goto continue_processing;
[K		< 		}
[K		<
[K		< 		if (msg == PAIRWISE_2 &&
[K		< 		    wpa_replay_counter_valid(sm->prev_key_replay,
[K		< 					     key->replay_counter) &&
[K		< 		    sm->wpa_ptk_state == WPA_PTK_PTKINITNEGOTIATING) {
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					 "ignore retransmitted EAPOL-Key %s - "
[K		< 					 "SNonce did not change", msgtxt);
[K		< 		} else {
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					 "received EAPOL-Key %s with "
[K		< 					 "unexpected replay counter", msgtxt);
[K		< 		}
[K		< 		for (i = 0; i < RSNA_MAX_EAPOL_RETRIES; i++) {
[K		< 			if (!sm->key_replay[i].valid)
[K		< 				break;
[K		< 			wpa_hexdump(MSG_DEBUG, "pending replay counter",
[K		< 				    sm->key_replay[i].counter,
[K		< 				    WPA_REPLAY_COUNTER_LEN);
[K		< 		}
[K		< 		wpa_hexdump(MSG_DEBUG, "received replay counter",
[K		< 			    key->replay_counter, WPA_REPLAY_COUNTER_LEN);
[K		< 		return;
[K		< 	}
[K		<
[K		< continue_processing:
[K		< #ifdef CONFIG_FILS
[K		< 	if (sm->wpa == WPA_VERSION_WPA2 && mic_len == 0 &&
[K		< 	    !(key_info & WPA_KEY_INFO_ENCR_KEY_DATA)) {
[K		< 		wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				 "WPA: Encr Key Data bit not set even though AEAD cipher is supposed to be used - drop frame");
[K		< 		return;
[K		< 	}
[K		< #endif /* CONFIG_FILS */
[K		<
[K		< 	switch (msg) {
[K		< 	case PAIRWISE_2:
[K		< 		if (sm->wpa_ptk_state != WPA_PTK_PTKSTART &&
[K		< 		    sm->wpa_ptk_state != WPA_PTK_PTKCALCNEGOTIATING &&
[K		< 		    (!sm->update_snonce ||
[K		< 		     sm->wpa_ptk_state != WPA_PTK_PTKINITNEGOTIATING)) {
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					 "received EAPOL-Key msg 2/4 in "
[K		< 					 "invalid state (%d) - dropped",
[K		< 					 sm->wpa_ptk_state);
[K		< 			return;
[K		< 		}
[K		< 		random_add_randomness(key->key_nonce, WPA_NONCE_LEN);
[K		< 		if (sm->group->reject_4way_hs_for_entropy) {
[K		< 			/*
[K		< 			 * The system did not have enough entropy to generate
[K		< 			 * strong random numbers. Reject the first 4-way
[K		< 			 * handshake(s) and collect some entropy based on the
[K		< 			 * information from it. Once enough entropy is
[K		< 			 * available, the next atempt will trigger GMK/Key
[K		< 			 * Counter update and the station will be allowed to
[K		< 			 * continue.
[K		< 			 */
[K		< 			wpa_printf(MSG_DEBUG, "WPA: Reject 4-way handshake to "
[K		< 				   "collect more entropy for random number "
[K		< 				   "generation");
[K		< 			random_mark_pool_ready();
[K		< 			wpa_sta_disconnect(wpa_auth, sm->addr);
[K		< 			return;
[K		< 		}
[K		< 		break;
[K		< 	case PAIRWISE_4:
[K		< 		if (sm->wpa_ptk_state != WPA_PTK_PTKINITNEGOTIATING ||
[K		< 		    !sm->PTK_valid) {
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					 "received EAPOL-Key msg 4/4 in "
[K		< 					 "invalid state (%d) - dropped",
[K		< 					 sm->wpa_ptk_state);
[K		< 			return;
[K		< 		}
[K		< 		break;
[K		< 	case GROUP_2:
[K		< 		if (sm->wpa_ptk_group_state != WPA_PTK_GROUP_REKEYNEGOTIATING
[K		< 		    || !sm->PTK_valid) {
[K		< 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					 "received EAPOL-Key msg 2/2 in "
[K		< 					 "invalid state (%d) - dropped",
[K		< 					 sm->wpa_ptk_group_state);
[K		< 			return;
[K		< 		}
[K		< 		break;
[K		< #ifdef CONFIG_PEERKEY
[K		< 	case SMK_M1:
[K		< 	case SMK_M3:
[K		< 	case SMK_ERROR:
[K		< 		if (!wpa_auth->conf.peerkey) {
[K		< 			wpa_printf(MSG_DEBUG, "RSN: SMK M1/M3/Error, but "
[K		< 				   "PeerKey use disabled - ignoring message");
[K		< 			return;
[K		< 		}
[K		< 		if (!sm->PTK_valid) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"received EAPOL-Key msg SMK in "
[K		< 					"invalid state - dropped");
[K		< 			return;
[K		< 		}
[K		< 		break;
[K		< #else /* CONFIG_PEERKEY */
[K		< 	case SMK_M1:
[K		< 	case SMK_M3:
[K		< 	case SMK_ERROR:
[K		< 		return; /* STSL disabled - ignore SMK messages */
[K		< #endif /* CONFIG_PEERKEY */
[K		< 	case REQUEST:
[K		< 		break;
[K		< 	}
[K		<
[K		< 	wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 			 "received EAPOL-Key frame (%s)", msgtxt);
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_ACK) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"received invalid EAPOL-Key: Key Ack set");
[K		< 		return;
[K		< 	}
[K		<
[K		< 	if (!wpa_key_mgmt_fils(sm->wpa_key_mgmt) &&
[K		< 	    !(key_info & WPA_KEY_INFO_MIC)) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"received invalid EAPOL-Key: Key MIC not set");
[K		< 		return;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_FILS
[K		< 	if (wpa_key_mgmt_fils(sm->wpa_key_mgmt) &&
[K		< 	    (key_info & WPA_KEY_INFO_MIC)) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"received invalid EAPOL-Key: Key MIC set");
[K		< 		return;
[K		< 	}
[K		< #endif /* CONFIG_FILS */
[K		<
[K		< 	sm->MICVerified = FALSE;
[K		< 	if (sm->PTK_valid && !sm->update_snonce) {
[K		< 		if (mic_len &&
[K		< 		    wpa_verify_key_mic(sm->wpa_key_mgmt, &sm->PTK, data,
[K		< 				       data_len) &&
[K		< 		    (msg != PAIRWISE_4 || !sm->alt_snonce_valid ||
[K		< 		     wpa_try_alt_snonce(sm, data, data_len))) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"received EAPOL-Key with invalid MIC");
[K		< 			return;
[K		< 		}
[K		< #ifdef CONFIG_FILS
[K		< 		if (!mic_len &&
[K		< 		    wpa_aead_decrypt(sm, &sm->PTK, data, data_len,
[K		< 				     &key_data_length) < 0) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"received EAPOL-Key with invalid MIC");
[K		< 			return;
[K		< 		}
[K		< #endif /* CONFIG_FILS */
[K		< 		sm->MICVerified = TRUE;
[K		< 		eloop_cancel_timeout(wpa_send_eapol_timeout, wpa_auth, sm);
[K		< 		sm->pending_1_of_4_timeout = 0;
[K		< 	}
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_REQUEST) {
[K		< 		if (sm->MICVerified) {
[K		< 			sm->req_replay_counter_used = 1;
[K		< 			os_memcpy(sm->req_replay_counter, key->replay_counter,
[K		< 				  WPA_REPLAY_COUNTER_LEN);
[K		< 		} else {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"received EAPOL-Key request with "
[K		< 					"invalid MIC");
[K		< 			return;
[K		< 		}
[K		<
[K		< 		/*
[K		< 		 * TODO: should decrypt key data field if encryption was used;
[K		< 		 * even though MAC address KDE is not normally encrypted,
[K		< 		 * supplicant is allowed to encrypt it.
[K		< 		 */
[K		< 		if (msg == SMK_ERROR) {
[K		< #ifdef CONFIG_PEERKEY
[K		< 			wpa_smk_error(wpa_auth, sm, key_data, key_data_length);
[K		< #endif /* CONFIG_PEERKEY */
[K		< 			return;
[K		< 		} else if (key_info & WPA_KEY_INFO_ERROR) {
[K		< 			if (wpa_receive_error_report(
[K		< 				    wpa_auth, sm,
[K		< 				    !(key_info & WPA_KEY_INFO_KEY_TYPE)) > 0)
[K		< 				return; /* STA entry was removed */
[K		< 		} else if (key_info & WPA_KEY_INFO_KEY_TYPE) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"received EAPOL-Key Request for new "
[K		< 					"4-Way Handshake");
[K		< 			wpa_request_new_ptk(sm);
[K		< #ifdef CONFIG_PEERKEY
[K		< 		} else if (msg == SMK_M1) {
[K		< 			wpa_smk_m1(wpa_auth, sm, key, key_data,
[K		< 				   key_data_length);
[K		< #endif /* CONFIG_PEERKEY */
[K		< 		} else if (key_data_length > 0 &&
[K		< 			   wpa_parse_kde_ies(key_data, key_data_length,
[K		< 					     &kde) == 0 &&
[K		< 			   kde.mac_addr) {
[K		< 		} else {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"received EAPOL-Key Request for GTK "
[K		< 					"rekeying");
[K		< 			eloop_cancel_timeout(wpa_rekey_gtk, wpa_auth, NULL);
[K		< 			wpa_rekey_gtk(wpa_auth, NULL);
[K		< 		}
[K		< 	} else {
[K		< 		/* Do not allow the same key replay counter to be reused. */
[K		< 		wpa_replay_counter_mark_invalid(sm->key_replay,
[K		< 						key->replay_counter);
[K		<
[K		< 		if (msg == PAIRWISE_2) {
[K		< 			/*
[K		< 			 * Maintain a copy of the pending EAPOL-Key frames in
[K		< 			 * case the EAPOL-Key frame was retransmitted. This is
[K		< 			 * needed to allow EAPOL-Key msg 2/4 reply to another
[K		< 			 * pending msg 1/4 to update the SNonce to work around
[K		< 			 * unexpected supplicant behavior.
[K		< 			 */
[K		< 			os_memcpy(sm->prev_key_replay, sm->key_replay,
[K		< 				  sizeof(sm->key_replay));
[K		< 		} else {
[K		< 			os_memset(sm->prev_key_replay, 0,
[K		< 				  sizeof(sm->prev_key_replay));
[K		< 		}
[K		<
[K		< 		/*
[K		< 		 * Make sure old valid counters are not accepted anymore and
[K		< 		 * do not get copied again.
[K		< 		 */
[K		< 		wpa_replay_counter_mark_invalid(sm->key_replay, NULL);
[K		< 	}
[K		<
[K		< #ifdef CONFIG_PEERKEY
[K		< 	if (msg == SMK_M3) {
[K		< 		wpa_smk_m3(wpa_auth, sm, key, key_data, key_data_length);
[K		< 		return;
[K		< 	}
[K		< #endif /* CONFIG_PEERKEY */
[K		<
[K		< 	os_free(sm->last_rx_eapol_key);
[K		< 	sm->last_rx_eapol_key = os_malloc(data_len);
[K		< 	if (sm->last_rx_eapol_key == NULL)
[K		< 		return;
[K		< 	os_memcpy(sm->last_rx_eapol_key, data, data_len);
[K		< 	sm->last_rx_eapol_key_len = data_len;
[K		<
[K		< 	sm->rx_eapol_key_secure = !!(key_info & WPA_KEY_INFO_SECURE);
[K		< 	sm->EAPOLKeyReceived = TRUE;
[K		< 	sm->EAPOLKeyPairwise = !!(key_info & WPA_KEY_INFO_KEY_TYPE);
[K		< 	sm->EAPOLKeyRequest = !!(key_info & WPA_KEY_INFO_REQUEST);
[K		< 	os_memcpy(sm->SNonce, key->key_nonce, WPA_NONCE_LEN);
[K		< 	wpa_sm_step(sm);
[K		< }
[K		<
[K		<
[K		< static int wpa_gmk_to_gtk(const u8 *gmk, const char *label, const u8 *addr,
[K		< 			  const u8 *gnonce, u8 *gtk, size_t gtk_len)
[K		< {
[K		< 	u8 data[ETH_ALEN + WPA_NONCE_LEN + 8 + 16];
[K		< 	u8 *pos;
[K		< 	int ret = 0;
[K		<
[K		< 	/* GTK = PRF-X(GMK, "Group key expansion",
[K		< 	 *	AA || GNonce || Time || random data)
[K		< 	 * The example described in the IEEE 802.11 standard uses only AA and
[K		< 	 * GNonce as inputs here. Add some more entropy since this derivation
[K		< 	 * is done only at the Authenticator and as such, does not need to be
[K		< 	 * exactly same.
[K		< 	 */
[K		< 	os_memcpy(data, addr, ETH_ALEN);
[K		< 	os_memcpy(data + ETH_ALEN, gnonce, WPA_NONCE_LEN);
[K		< 	pos = data + ETH_ALEN + WPA_NONCE_LEN;
[K		< 	wpa_get_ntp_timestamp(pos);
[K		< 	pos += 8;
[K		< 	if (random_get_bytes(pos, 16) < 0)
[K		< 		ret = -1;
[K		<
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	sha256_prf(gmk, WPA_GMK_LEN, label, data, sizeof(data), gtk, gtk_len);
[K		< #else /* CONFIG_IEEE80211W */
[K		< 	if (sha1_prf(gmk, WPA_GMK_LEN, label, data, sizeof(data), gtk, gtk_len)
[K		< 	    < 0)
[K		< 		ret = -1;
[K		< #endif /* CONFIG_IEEE80211W */
[K		<
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< static void wpa_send_eapol_timeout(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = eloop_ctx;
[K		< 	struct wpa_state_machine *sm = timeout_ctx;
[K		<
[K		< 	sm->pending_1_of_4_timeout = 0;
[K		< 	wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG, "EAPOL-Key timeout");
[K		< 	sm->TimeoutEvt = TRUE;
[K		< 	wpa_sm_step(sm);
[K		< }
[K		<
[K		<
[K		< void __wpa_send_eapol(struct wpa_authenticator *wpa_auth,
[K		< 		      struct wpa_state_machine *sm, int key_info,
[K		< 		      const u8 *key_rsc, const u8 *nonce,
[K		< 		      const u8 *kde, size_t kde_len,
[K		< 		      int keyidx, int encr, int force_version)
[K		< {
[K		< 	struct ieee802_1x_hdr *hdr;
[K		< 	struct wpa_eapol_key *key;
[K		< 	size_t len, mic_len, keyhdrlen;
[K		< 	int alg;
[K		< 	int key_data_len, pad_len = 0;
[K		< 	u8 *buf, *pos;
[K		< 	int version, pairwise;
[K		< 	int i;
[K		< 	u8 *key_mic, *key_data;
[K		<
[K		< 	mic_len = wpa_mic_len(sm->wpa_key_mgmt);
[K		< 	keyhdrlen = sizeof(*key) + mic_len + 2;
[K		<
[K		< 	len = sizeof(struct ieee802_1x_hdr) + keyhdrlen;
[K		<
[K		< 	if (force_version)
[K		< 		version = force_version;
[K		< 	else if (sm->wpa_key_mgmt == WPA_KEY_MGMT_OSEN ||
[K		< 		 wpa_key_mgmt_suite_b(sm->wpa_key_mgmt) ||
[K		< 		 wpa_key_mgmt_fils(sm->wpa_key_mgmt))
[K		< 		version = WPA_KEY_INFO_TYPE_AKM_DEFINED;
[K		< 	else if (wpa_use_aes_cmac(sm))
[K		< 		version = WPA_KEY_INFO_TYPE_AES_128_CMAC;
[K		< 	else if (sm->pairwise != WPA_CIPHER_TKIP)
[K		< 		version = WPA_KEY_INFO_TYPE_HMAC_SHA1_AES;
[K		< 	else
[K		< 		version = WPA_KEY_INFO_TYPE_HMAC_MD5_RC4;
[K		<
[K		< 	pairwise = !!(key_info & WPA_KEY_INFO_KEY_TYPE);
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Send EAPOL(version=%d secure=%d mic=%d "
[K		< 		   "ack=%d install=%d pairwise=%d kde_len=%lu keyidx=%d "
[K		< 		   "encr=%d)",
[K		< 		   version,
[K		< 		   (key_info & WPA_KEY_INFO_SECURE) ? 1 : 0,
[K		< 		   (key_info & WPA_KEY_INFO_MIC) ? 1 : 0,
[K		< 		   (key_info & WPA_KEY_INFO_ACK) ? 1 : 0,
[K		< 		   (key_info & WPA_KEY_INFO_INSTALL) ? 1 : 0,
[K		< 		   pairwise, (unsigned long) kde_len, keyidx, encr);
[K		<
[K		< 	key_data_len = kde_len;
[K		<
[K		< 	if ((version == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES ||
[K		< 	     sm->wpa_key_mgmt == WPA_KEY_MGMT_OSEN ||
[K		< 	     wpa_key_mgmt_suite_b(sm->wpa_key_mgmt) ||
[K		< 	     version == WPA_KEY_INFO_TYPE_AES_128_CMAC) && encr) {
[K		< 		pad_len = key_data_len % 8;
[K		< 		if (pad_len)
[K		< 			pad_len = 8 - pad_len;
[K		< 		key_data_len += pad_len + 8;
[K		< 	}
[K		<
[K		< 	len += key_data_len;
[K		< 	if (!mic_len && encr)
[K		< 		len += AES_BLOCK_SIZE;
[K		<
[K		< 	hdr = os_zalloc(len);
[K		< 	if (hdr == NULL)
[K		< 		return;
[K		< 	hdr->version = wpa_auth->conf.eapol_version;
[K		< 	hdr->type = IEEE802_1X_TYPE_EAPOL_KEY;
[K		< 	hdr->length = host_to_be16(len  - sizeof(*hdr));
[K		< 	key = (struct wpa_eapol_key *) (hdr + 1);
[K		< 	key_mic = (u8 *) (key + 1);
[K		< 	key_data = ((u8 *) (hdr + 1)) + keyhdrlen;
[K		<
[K		< 	key->type = sm->wpa == WPA_VERSION_WPA2 ?
[K		< 		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
[K		< 	key_info |= version;
[K		< 	if (encr && sm->wpa == WPA_VERSION_WPA2)
[K		< 		key_info |= WPA_KEY_INFO_ENCR_KEY_DATA;
[K		< 	if (sm->wpa != WPA_VERSION_WPA2)
[K		< 		key_info |= keyidx << WPA_KEY_INFO_KEY_INDEX_SHIFT;
[K		< 	WPA_PUT_BE16(key->key_info, key_info);
[K		<
[K		< 	alg = pairwise ? sm->pairwise : wpa_auth->conf.wpa_group;
[K		< 	if ((key_info & WPA_KEY_INFO_SMK_MESSAGE) ||
[K		< 	    (sm->wpa == WPA_VERSION_WPA2 && !pairwise))
[K		< 		WPA_PUT_BE16(key->key_length, 0);
[K		< 	else
[K		< 		WPA_PUT_BE16(key->key_length, wpa_cipher_key_len(alg));
[K		<
[K		< 	/* FIX: STSL: what to use as key_replay_counter? */
[K		< 	for (i = RSNA_MAX_EAPOL_RETRIES - 1; i > 0; i--) {
[K		< 		sm->key_replay[i].valid = sm->key_replay[i - 1].valid;
[K		< 		os_memcpy(sm->key_replay[i].counter,
[K		< 			  sm->key_replay[i - 1].counter,
[K		< 			  WPA_REPLAY_COUNTER_LEN);
[K		< 	}
[K		< 	inc_byte_array(sm->key_replay[0].counter, WPA_REPLAY_COUNTER_LEN);
[K		< 	os_memcpy(key->replay_counter, sm->key_replay[0].counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: Replay Counter",
[K		< 		    key->replay_counter, WPA_REPLAY_COUNTER_LEN);
[K		< 	sm->key_replay[0].valid = TRUE;
[K		<
[K		< 	if (nonce)
[K		< 		os_memcpy(key->key_nonce, nonce, WPA_NONCE_LEN);
[K		<
[K		< 	if (key_rsc)
[K		< 		os_memcpy(key->key_rsc, key_rsc, WPA_KEY_RSC_LEN);
[K		<
[K		< 	if (kde && !encr) {
[K		< 		os_memcpy(key_data, kde, kde_len);
[K		< 		WPA_PUT_BE16(key_mic + mic_len, kde_len);
[K		< #ifdef CONFIG_FILS
[K		< 	} else if (!mic_len) {
[K		< 		const u8 *aad[1];
[K		< 		size_t aad_len[1];
[K		<
[K		< 		WPA_PUT_BE16(key_mic, AES_BLOCK_SIZE + kde_len);
[K		< 		wpa_hexdump_key(MSG_DEBUG, "Plaintext EAPOL-Key Key Data",
[K		< 				kde, kde_len);
[K		<
[K		< 		wpa_hexdump_key(MSG_DEBUG, "WPA: KEK",
[K		< 				sm->PTK.kek, sm->PTK.kek_len);
[K		< 		/* AES-SIV AAD from EAPOL protocol version field (inclusive) to
[K		< 		 * to Key Data (exclusive). */
[K		< 		aad[0] = (u8 *) hdr;
[K		< 		aad_len[0] = key_mic + 2 - (u8 *) hdr;
[K		< 		if (aes_siv_encrypt(sm->PTK.kek, sm->PTK.kek_len, kde, kde_len,
[K		< 				    1, aad, aad_len, key_mic + 2) < 0) {
[K		< 			wpa_printf(MSG_DEBUG, "WPA: AES-SIV encryption failed");
[K		< 			return;
[K		< 		}
[K		<
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: Encrypted Key Data from SIV",
[K		< 			    key_mic + 2, AES_BLOCK_SIZE + kde_len);
[K		< #endif /* CONFIG_FILS */
[K		< 	} else if (encr && kde) {
[K		< 		buf = os_zalloc(key_data_len);
[K		< 		if (buf == NULL) {
[K		< 			os_free(hdr);
[K		< 			return;
[K		< 		}
[K		< 		pos = buf;
[K		< 		os_memcpy(pos, kde, kde_len);
[K		< 		pos += kde_len;
[K		<
[K		< 		if (pad_len)
[K		< 			*pos++ = 0xdd;
[K		<
[K		< 		wpa_hexdump_key(MSG_DEBUG, "Plaintext EAPOL-Key Key Data",
[K		< 				buf, key_data_len);
[K		< 		if (version == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES ||
[K		< 		    sm->wpa_key_mgmt == WPA_KEY_MGMT_OSEN ||
[K		< 		    wpa_key_mgmt_suite_b(sm->wpa_key_mgmt) ||
[K		< 		    version == WPA_KEY_INFO_TYPE_AES_128_CMAC) {
[K		< 			if (aes_wrap(sm->PTK.kek, sm->PTK.kek_len,
[K		< 				     (key_data_len - 8) / 8, buf, key_data)) {
[K		< 				os_free(hdr);
[K		< 				os_free(buf);
[K		< 				return;
[K		< 			}
[K		< 			WPA_PUT_BE16(key_mic + mic_len, key_data_len);
[K		< #ifndef CONFIG_NO_RC4
[K		< 		} else if (sm->PTK.kek_len == 16) {
[K		< 			u8 ek[32];
[K		< 			os_memcpy(key->key_iv,
[K		< 				  sm->group->Counter + WPA_NONCE_LEN - 16, 16);
[K		< 			inc_byte_array(sm->group->Counter, WPA_NONCE_LEN);
[K		< 			os_memcpy(ek, key->key_iv, 16);
[K		< 			os_memcpy(ek + 16, sm->PTK.kek, sm->PTK.kek_len);
[K		< 			os_memcpy(key_data, buf, key_data_len);
[K		< 			rc4_skip(ek, 32, 256, key_data, key_data_len);
[K		< 			WPA_PUT_BE16(key_mic + mic_len, key_data_len);
[K		< #endif /* CONFIG_NO_RC4 */
[K		< 		} else {
[K		< 			os_free(hdr);
[K		< 			os_free(buf);
[K		< 			return;
[K		< 		}
[K		< 		os_free(buf);
[K		< 	}
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_MIC) {
[K		< 		if (!sm->PTK_valid || !mic_len) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					"PTK not valid when sending EAPOL-Key "
[K		< 					"frame");
[K		< 			os_free(hdr);
[K		< 			return;
[K		< 		}
[K		<
[K		< 		wpa_eapol_key_mic(sm->PTK.kck, sm->PTK.kck_len,
[K		< 				  sm->wpa_key_mgmt, version,
[K		< 				  (u8 *) hdr, len, key_mic);
[K		< #ifdef CONFIG_TESTING_OPTIONS
[K		< 		if (!pairwise &&
[K		< 		    wpa_auth->conf.corrupt_gtk_rekey_mic_probability > 0.0 &&
[K		< 		    drand48() <
[K		< 		    wpa_auth->conf.corrupt_gtk_rekey_mic_probability) {
[K		< 			wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"Corrupting group EAPOL-Key Key MIC");
[K		< 			key_mic[0]++;
[K		< 		}
[K		< #endif /* CONFIG_TESTING_OPTIONS */
[K		< 	}
[K		<
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_inc_EapolFramesTx,
[K		< 			   1);
[K		< 	wpa_auth_send_eapol(wpa_auth, sm->addr, (u8 *) hdr, len,
[K		< 			    sm->pairwise_set);
[K		< 	os_free(hdr);
[K		< }
[K		<
[K		<
[K		< static void wpa_send_eapol(struct wpa_authenticator *wpa_auth,
[K		< 			   struct wpa_state_machine *sm, int key_info,
[K		< 			   const u8 *key_rsc, const u8 *nonce,
[K		< 			   const u8 *kde, size_t kde_len,
[K		< 			   int keyidx, int encr)
[K		< {
[K		< 	int timeout_ms;
[K		< 	int pairwise = key_info & WPA_KEY_INFO_KEY_TYPE;
[K		< 	u32 ctr;
[K		<
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	__wpa_send_eapol(wpa_auth, sm, key_info, key_rsc, nonce, kde, kde_len,
[K		< 			 keyidx, encr, 0);
[K		<
[K		< 	ctr = pairwise ? sm->TimeoutCtr : sm->GTimeoutCtr;
[K		< 	if (ctr == 1 && wpa_auth->conf.tx_status)
[K		< 		timeout_ms = pairwise ? eapol_key_timeout_first :
[K		< 			eapol_key_timeout_first_group;
[K		< 	else
[K		< 		timeout_ms = eapol_key_timeout_subseq;
[K		< 	if (pairwise && ctr == 1 && !(key_info & WPA_KEY_INFO_MIC))
[K		< 		sm->pending_1_of_4_timeout = 1;
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Use EAPOL-Key timeout of %u ms (retry "
[K		< 		   "counter %u)", timeout_ms, ctr);
[K		< 	eloop_register_timeout(timeout_ms / 1000, (timeout_ms % 1000) * 1000,
[K		< 			       wpa_send_eapol_timeout, wpa_auth, sm);
[K		< }
[K		<
[K		<
[K		< static int wpa_verify_key_mic(int akmp, struct wpa_ptk *PTK, u8 *data,
[K		< 			      size_t data_len)
[K		< {
[K		< 	struct ieee802_1x_hdr *hdr;
[K		< 	struct wpa_eapol_key *key;
[K		< 	u16 key_info;
[K		< 	int ret = 0;
[K		< 	u8 mic[WPA_EAPOL_KEY_MIC_MAX_LEN], *mic_pos;
[K		< 	size_t mic_len = wpa_mic_len(akmp);
[K		<
[K		< 	if (data_len < sizeof(*hdr) + sizeof(*key))
[K		< 		return -1;
[K		<
[K		< 	hdr = (struct ieee802_1x_hdr *) data;
[K		< 	key = (struct wpa_eapol_key *) (hdr + 1);
[K		< 	mic_pos = (u8 *) (key + 1);
[K		< 	key_info = WPA_GET_BE16(key->key_info);
[K		< 	os_memcpy(mic, mic_pos, mic_len);
[K		< 	os_memset(mic_pos, 0, mic_len);
[K		< 	if (wpa_eapol_key_mic(PTK->kck, PTK->kck_len, akmp,
[K		< 			      key_info & WPA_KEY_INFO_TYPE_MASK,
[K		< 			      data, data_len, mic_pos) ||
[K		< 	    os_memcmp_const(mic, mic_pos, mic_len) != 0)
[K		< 		ret = -1;
[K		< 	os_memcpy(mic_pos, mic, mic_len);
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< void wpa_remove_ptk(struct wpa_state_machine *sm)
[K		< {
[K		< 	sm->PTK_valid = FALSE;
[K		< 	os_memset(&sm->PTK, 0, sizeof(sm->PTK));
[K		< 	if (wpa_auth_set_key(sm->wpa_auth, 0, WPA_ALG_NONE, sm->addr, 0, NULL,
[K		< 			     0))
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "RSN: PTK removal from the driver failed");
[K		< 	sm->pairwise_set = FALSE;
[K		< 	eloop_cancel_timeout(wpa_rekey_ptk, sm->wpa_auth, sm);
[K		< }
[K		<
[K		<
[K		< int wpa_auth_sm_event(struct wpa_state_machine *sm, enum wpa_event event)
[K		< {
[K		< 	int remove_ptk = 1;
[K		<
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< 	wpa_auth_vlogger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 			 "event %d notification", event);
[K		<
[K		< 	switch (event) {
[K		< 	case WPA_AUTH:
[K		< #ifdef CONFIG_MESH
[K		< 		/* PTKs are derived through AMPE */
[K		< 		if (wpa_auth_start_ampe(sm->wpa_auth, sm->addr)) {
[K		< 			/* not mesh */
[K		< 			break;
[K		< 		}
[K		< 		return 0;
[K		< #endif /* CONFIG_MESH */
[K		< 	case WPA_ASSOC:
[K		< 		break;
[K		< 	case WPA_DEAUTH:
[K		< 	case WPA_DISASSOC:
[K		< 		sm->DeauthenticationRequest = TRUE;
[K		< 		break;
[K		< 	case WPA_REAUTH:
[K		< 	case WPA_REAUTH_EAPOL:
[K		< 		if (!sm->started) {
[K		< 			/*
[K		< 			 * When using WPS, we may end up here if the STA
[K		< 			 * manages to re-associate without the previous STA
[K		< 			 * entry getting removed. Consequently, we need to make
[K		< 			 * sure that the WPA state machines gets initialized
[K		< 			 * properly at this point.
[K		< 			 */
[K		< 			wpa_printf(MSG_DEBUG, "WPA state machine had not been "
[K		< 				   "started - initialize now");
[K		< 			sm->started = 1;
[K		< 			sm->Init = TRUE;
[K		< 			if (wpa_sm_step(sm) == 1)
[K		< 				return 1; /* should not really happen */
[K		< 			sm->Init = FALSE;
[K		< 			sm->AuthenticationRequest = TRUE;
[K		< 			break;
[K		< 		}
[K		< 		if (sm->GUpdateStationKeys) {
[K		< 			/*
[K		< 			 * Reauthentication cancels the pending group key
[K		< 			 * update for this STA.
[K		< 			 */
[K		< 			sm->group->GKeyDoneStations--;
[K		< 			sm->GUpdateStationKeys = FALSE;
[K		< 			sm->PtkGroupInit = TRUE;
[K		< 		}
[K		< 		sm->ReAuthenticationRequest = TRUE;
[K		< 		break;
[K		< 	case WPA_ASSOC_FT:
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 		wpa_printf(MSG_DEBUG, "FT: Retry PTK configuration "
[K		< 			   "after association");
[K		< 		wpa_ft_install_ptk(sm);
[K		<
[K		< 		/* Using FT protocol, not WPA auth state machine */
[K		< 		sm->ft_completed = 1;
[K		< 		return 0;
[K		< #else /* CONFIG_IEEE80211R_AP */
[K		< 		break;
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< 	}
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	sm->ft_completed = 0;
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (sm->mgmt_frame_prot && event == WPA_AUTH)
[K		< 		remove_ptk = 0;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< #ifdef CONFIG_FILS
[K		< 	if (wpa_key_mgmt_fils(sm->wpa_key_mgmt) &&
[K		< 	    (event == WPA_AUTH || event == WPA_ASSOC))
[K		< 		remove_ptk = 0;
[K		< #endif /* CONFIG_FILS */
[K		<
[K		< 	if (remove_ptk) {
[K		< 		sm->PTK_valid = FALSE;
[K		< 		os_memset(&sm->PTK, 0, sizeof(sm->PTK));
[K		<
[K		< 		if (event != WPA_REAUTH_EAPOL)
[K		< 			wpa_remove_ptk(sm);
[K		< 	}
[K		<
[K		< 	if (sm->in_step_loop) {
[K		< 		/*
[K		< 		 * wpa_sm_step() is already running - avoid recursive call to
[K		< 		 * it by making the existing loop process the new update.
[K		< 		 */
[K		< 		sm->changed = TRUE;
[K		< 		return 0;
[K		< 	}
[K		< 	return wpa_sm_step(sm);
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, INITIALIZE)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, INITIALIZE, wpa_ptk);
[K		< 	if (sm->Init) {
[K		< 		/* Init flag is not cleared here, so avoid busy
[K		< 		 * loop by claiming nothing changed. */
[K		< 		sm->changed = FALSE;
[K		< 	}
[K		<
[K		< 	sm->keycount = 0;
[K		< 	if (sm->GUpdateStationKeys)
[K		< 		sm->group->GKeyDoneStations--;
[K		< 	sm->GUpdateStationKeys = FALSE;
[K		< 	if (sm->wpa == WPA_VERSION_WPA)
[K		< 		sm->PInitAKeys = FALSE;
[K		< 	if (1 /* Unicast cipher supported AND (ESS OR ((IBSS or WDS) and
[K		< 	       * Local AA > Remote AA)) */) {
[K		< 		sm->Pair = TRUE;
[K		< 	}
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_portEnabled, 0);
[K		< 	wpa_remove_ptk(sm);
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_portValid, 0);
[K		< 	sm->TimeoutCtr = 0;
[K		< 	if (wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt)) {
[K		< 		wpa_auth_set_eapol(sm->wpa_auth, sm->addr,
[K		< 				   WPA_EAPOL_authorized, 0);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, DISCONNECT)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, DISCONNECT, wpa_ptk);
[K		< 	sm->Disconnect = FALSE;
[K		< 	wpa_sta_disconnect(sm->wpa_auth, sm->addr);
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, DISCONNECTED)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, DISCONNECTED, wpa_ptk);
[K		< 	sm->DeauthenticationRequest = FALSE;
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, AUTHENTICATION)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, AUTHENTICATION, wpa_ptk);
[K		< 	os_memset(&sm->PTK, 0, sizeof(sm->PTK));
[K		< 	sm->PTK_valid = FALSE;
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_portControl_Auto,
[K		< 			   1);
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_portEnabled, 1);
[K		< 	sm->AuthenticationRequest = FALSE;
[K		< }
[K		<
[K		<
[K		< static void wpa_group_ensure_init(struct wpa_authenticator *wpa_auth,
[K		< 				  struct wpa_group *group)
[K		< {
[K		< 	if (group->first_sta_seen)
[K		< 		return;
[K		< 	/*
[K		< 	 * System has run bit further than at the time hostapd was started
[K		< 	 * potentially very early during boot up. This provides better chances
[K		< 	 * of collecting more randomness on embedded systems. Re-initialize the
[K		< 	 * GMK and Counter here to improve their strength if there was not
[K		< 	 * enough entropy available immediately after system startup.
[K		< 	 */
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Re-initialize GMK/Counter on first "
[K		< 		   "station");
[K		< 	if (random_pool_ready() != 1) {
[K		< 		wpa_printf(MSG_INFO, "WPA: Not enough entropy in random pool "
[K		< 			   "to proceed - reject first 4-way handshake");
[K		< 		group->reject_4way_hs_for_entropy = TRUE;
[K		< 	} else {
[K		< 		group->first_sta_seen = TRUE;
[K		< 		group->reject_4way_hs_for_entropy = FALSE;
[K		< 	}
[K		<
[K		< 	if (wpa_group_init_gmk_and_counter(wpa_auth, group) < 0 ||
[K		< 	    wpa_gtk_update(wpa_auth, group) < 0 ||
[K		< 	    wpa_group_config_group_keys(wpa_auth, group) < 0) {
[K		< 		wpa_printf(MSG_INFO, "WPA: GMK/GTK setup failed");
[K		< 		group->first_sta_seen = FALSE;
[K		< 		group->reject_4way_hs_for_entropy = TRUE;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, AUTHENTICATION2)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, AUTHENTICATION2, wpa_ptk);
[K		<
[K		< 	wpa_group_ensure_init(sm->wpa_auth, sm->group);
[K		< 	sm->ReAuthenticationRequest = FALSE;
[K		<
[K		< 	/*
[K		< 	 * Definition of ANonce selection in IEEE Std 802.11i-2004 is somewhat
[K		< 	 * ambiguous. The Authenticator state machine uses a counter that is
[K		< 	 * incremented by one for each 4-way handshake. However, the security
[K		< 	 * analysis of 4-way handshake points out that unpredictable nonces
[K		< 	 * help in preventing precomputation attacks. Instead of the state
[K		< 	 * machine definition, use an unpredictable nonce value here to provide
[K		< 	 * stronger protection against potential precomputation attacks.
[K		< 	 */
[K		< 	if (random_get_bytes(sm->ANonce, WPA_NONCE_LEN)) {
[K		< 		wpa_printf(MSG_ERROR, "WPA: Failed to get random data for "
[K		< 			   "ANonce.");
[K		< 		sm->Disconnect = TRUE;
[K		< 		return;
[K		< 	}
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: Assign ANonce", sm->ANonce,
[K		< 		    WPA_NONCE_LEN);
[K		< 	/* IEEE 802.11i does not clear TimeoutCtr here, but this is more
[K		< 	 * logical place than INITIALIZE since AUTHENTICATION2 can be
[K		< 	 * re-entered on ReAuthenticationRequest without going through
[K		< 	 * INITIALIZE. */
[K		< 	sm->TimeoutCtr = 0;
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, INITPMK)
[K		< {
[K		< 	u8 msk[2 * PMK_LEN];
[K		< 	size_t len = 2 * PMK_LEN;
[K		<
[K		< 	SM_ENTRY_MA(WPA_PTK, INITPMK, wpa_ptk);
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	sm->xxkey_len = 0;
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< 	if (sm->pmksa) {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: PMK from PMKSA cache");
[K		< 		os_memcpy(sm->PMK, sm->pmksa->pmk, sm->pmksa->pmk_len);
[K		< 		sm->pmk_len = sm->pmksa->pmk_len;
[K		< 	} else if (wpa_auth_get_msk(sm->wpa_auth, sm->addr, msk, &len) == 0) {
[K		< 		unsigned int pmk_len;
[K		<
[K		< 		if (wpa_key_mgmt_sha384(sm->wpa_key_mgmt))
[K		< 			pmk_len = PMK_LEN_SUITE_B_192;
[K		< 		else
[K		< 			pmk_len = PMK_LEN;
[K		< 		wpa_printf(MSG_DEBUG, "WPA: PMK from EAPOL state machine "
[K		< 			   "(MSK len=%lu PMK len=%u)", (unsigned long) len,
[K		< 			   pmk_len);
[K		< 		if (len < pmk_len) {
[K		< 			wpa_printf(MSG_DEBUG,
[K		< 				   "WPA: MSK not long enough (%u) to create PMK (%u)",
[K		< 				   (unsigned int) len, (unsigned int) pmk_len);
[K		< 			sm->Disconnect = TRUE;
[K		< 			return;
[K		< 		}
[K		< 		os_memcpy(sm->PMK, msk, pmk_len);
[K		< 		sm->pmk_len = pmk_len;
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 		if (len >= 2 * PMK_LEN) {
[K		< 			os_memcpy(sm->xxkey, msk + PMK_LEN, PMK_LEN);
[K		< 			sm->xxkey_len = PMK_LEN;
[K		< 		}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< 	} else {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Could not get PMK, get_msk: %p",
[K		< 			   sm->wpa_auth->cb->get_msk);
[K		< 		sm->Disconnect = TRUE;
[K		< 		return;
[K		< 	}
[K		< 	os_memset(msk, 0, sizeof(msk));
[K		<
[K		< 	sm->req_replay_counter_used = 0;
[K		< 	/* IEEE 802.11i does not set keyRun to FALSE, but not doing this
[K		< 	 * will break reauthentication since EAPOL state machines may not be
[K		< 	 * get into AUTHENTICATING state that clears keyRun before WPA state
[K		< 	 * machine enters AUTHENTICATION2 state and goes immediately to INITPMK
[K		< 	 * state and takes PMK from the previously used AAA Key. This will
[K		< 	 * eventually fail in 4-Way Handshake because Supplicant uses PMK
[K		< 	 * derived from the new AAA Key. Setting keyRun = FALSE here seems to
[K		< 	 * be good workaround for this issue. */
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_keyRun, 0);
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, INITPSK)
[K		< {
[K		< 	const u8 *psk;
[K		< 	SM_ENTRY_MA(WPA_PTK, INITPSK, wpa_ptk);
[K		< 	psk = wpa_auth_get_psk(sm->wpa_auth, sm->addr, sm->p2p_dev_addr, NULL);
[K		< 	if (psk) {
[K		< 		os_memcpy(sm->PMK, psk, PMK_LEN);
[K		< 		sm->pmk_len = PMK_LEN;
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 		os_memcpy(sm->xxkey, psk, PMK_LEN);
[K		< 		sm->xxkey_len = PMK_LEN;
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< 	}
[K		< 	sm->req_replay_counter_used = 0;
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, PTKSTART)
[K		< {
[K		< 	u8 buf[2 + RSN_SELECTOR_LEN + PMKID_LEN], *pmkid = NULL;
[K		< 	size_t pmkid_len = 0;
[K		<
[K		< 	SM_ENTRY_MA(WPA_PTK, PTKSTART, wpa_ptk);
[K		< 	sm->PTKRequest = FALSE;
[K		< 	sm->TimeoutEvt = FALSE;
[K		< 	sm->alt_snonce_valid = FALSE;
[K		<
[K		< 	sm->TimeoutCtr++;
[K		< 	if (sm->TimeoutCtr > sm->wpa_auth->conf.wpa_pairwise_update_count) {
[K		< 		/* No point in sending the EAPOL-Key - we will disconnect
[K		< 		 * immediately following this. */
[K		< 		return;
[K		< 	}
[K		<
[K		< 	wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 			"sending 1/4 msg of 4-Way Handshake");
[K		< 	/*
[K		< 	 * TODO: Could add PMKID even with WPA2-PSK, but only if there is only
[K		< 	 * one possible PSK for this STA.
[K		< 	 */
[K		< 	if (sm->wpa == WPA_VERSION_WPA2 &&
[K		< 	    wpa_key_mgmt_wpa_ieee8021x(sm->wpa_key_mgmt) &&
[K		< 	    sm->wpa_key_mgmt != WPA_KEY_MGMT_OSEN) {
[K		< 		pmkid = buf;
[K		< 		pmkid_len = 2 + RSN_SELECTOR_LEN + PMKID_LEN;
[K		< 		pmkid[0] = WLAN_EID_VENDOR_SPECIFIC;
[K		< 		pmkid[1] = RSN_SELECTOR_LEN + PMKID_LEN;
[K		< 		RSN_SELECTOR_PUT(&pmkid[2], RSN_KEY_DATA_PMKID);
[K		< 		if (sm->pmksa) {
[K		< 			os_memcpy(&pmkid[2 + RSN_SELECTOR_LEN],
[K		< 				  sm->pmksa->pmkid, PMKID_LEN);
[K		< 		} else if (wpa_key_mgmt_suite_b(sm->wpa_key_mgmt)) {
[K		< 			/* No KCK available to derive PMKID */
[K		< 			pmkid = NULL;
[K		< 		} else {
[K		< 			/*
[K		< 			 * Calculate PMKID since no PMKSA cache entry was
[K		< 			 * available with pre-calculated PMKID.
[K		< 			 */
[K		< 			rsn_pmkid(sm->PMK, sm->pmk_len, sm->wpa_auth->addr,
[K		< 				  sm->addr, &pmkid[2 + RSN_SELECTOR_LEN],
[K		< 				  wpa_key_mgmt_sha256(sm->wpa_key_mgmt));
[K		< 		}
[K		< 	}
[K		< 	wpa_send_eapol(sm->wpa_auth, sm,
[K		< 		       WPA_KEY_INFO_ACK | WPA_KEY_INFO_KEY_TYPE, NULL,
[K		< 		       sm->ANonce, pmkid, pmkid_len, 0, 0);
[K		< }
[K		<
[K		<
[K		< static int wpa_derive_ptk(struct wpa_state_machine *sm, const u8 *snonce,
[K		< 			  const u8 *pmk, unsigned int pmk_len,
[K		< 			  struct wpa_ptk *ptk)
[K		< {
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt))
[K		< 		return wpa_auth_derive_ptk_ft(sm, pmk, ptk);
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		< 	return wpa_pmk_to_ptk(pmk, pmk_len, "Pairwise key expansion",
[K		< 			      sm->wpa_auth->addr, sm->addr, sm->ANonce, snonce,
[K		< 			      ptk, sm->wpa_key_mgmt, sm->pairwise);
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_FILS
[K		<
[K		< int fils_auth_pmk_to_ptk(struct wpa_state_machine *sm, const u8 *pmk,
[K		< 			 size_t pmk_len, const u8 *snonce, const u8 *anonce)
[K		< {
[K		< 	u8 ick[FILS_ICK_MAX_LEN];
[K		< 	size_t ick_len;
[K		< 	int res;
[K		<
[K		< 	res = fils_pmk_to_ptk(pmk, pmk_len, sm->addr, sm->wpa_auth->addr,
[K		< 			      snonce, anonce, &sm->PTK, ick, &ick_len,
[K		< 			      sm->wpa_key_mgmt, sm->pairwise);
[K		< 	if (res < 0)
[K		< 		return res;
[K		< 	sm->PTK_valid = TRUE;
[K		<
[K		< 	res = fils_key_auth_sk(ick, ick_len, snonce, anonce,
[K		< 			       sm->addr, sm->wpa_auth->addr,
[K		< 			       NULL, 0, NULL, 0, /* TODO: SK+PFS */
[K		< 			       sm->wpa_key_mgmt, sm->fils_key_auth_sta,
[K		< 			       sm->fils_key_auth_ap,
[K		< 			       &sm->fils_key_auth_len);
[K		< 	os_memset(ick, 0, sizeof(ick));
[K		<
[K		< 	/* Store nonces for (Re)Association Request/Response frame processing */
[K		< 	os_memcpy(sm->SNonce, snonce, FILS_NONCE_LEN);
[K		< 	os_memcpy(sm->ANonce, anonce, FILS_NONCE_LEN);
[K		<
[K		< 	return res;
[K		< }
[K		<
[K		<
[K		< static int wpa_aead_decrypt(struct wpa_state_machine *sm, struct wpa_ptk *ptk,
[K		< 			    u8 *buf, size_t buf_len, u16 *_key_data_len)
[K		< {
[K		< 	struct ieee802_1x_hdr *hdr;
[K		< 	struct wpa_eapol_key *key;
[K		< 	u8 *pos;
[K		< 	u16 key_data_len;
[K		< 	u8 *tmp;
[K		< 	const u8 *aad[1];
[K		< 	size_t aad_len[1];
[K		<
[K		< 	hdr = (struct ieee802_1x_hdr *) buf;
[K		< 	key = (struct wpa_eapol_key *) (hdr + 1);
[K		< 	pos = (u8 *) (key + 1);
[K		< 	key_data_len = WPA_GET_BE16(pos);
[K		< 	if (key_data_len < AES_BLOCK_SIZE ||
[K		< 	    key_data_len > buf_len - sizeof(*hdr) - sizeof(*key) - 2) {
[K		< 		wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"No room for AES-SIV data in the frame");
[K		< 		return -1;
[K		< 	}
[K		< 	pos += 2; /* Pointing at the Encrypted Key Data field */
[K		<
[K		< 	tmp = os_malloc(key_data_len);
[K		< 	if (!tmp)
[K		< 		return -1;
[K		<
[K		< 	/* AES-SIV AAD from EAPOL protocol version field (inclusive) to
[K		< 	 * to Key Data (exclusive). */
[K		< 	aad[0] = buf;
[K		< 	aad_len[0] = pos - buf;
[K		< 	if (aes_siv_decrypt(ptk->kek, ptk->kek_len, pos, key_data_len,
[K		< 			    1, aad, aad_len, tmp) < 0) {
[K		< 		wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"Invalid AES-SIV data in the frame");
[K		< 		bin_clear_free(tmp, key_data_len);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	/* AEAD decryption and validation completed successfully */
[K		< 	key_data_len -= AES_BLOCK_SIZE;
[K		< 	wpa_hexdump_key(MSG_DEBUG, "WPA: Decrypted Key Data",
[K		< 			tmp, key_data_len);
[K		<
[K		< 	/* Replace Key Data field with the decrypted version */
[K		< 	os_memcpy(pos, tmp, key_data_len);
[K		< 	pos -= 2; /* Key Data Length field */
[K		< 	WPA_PUT_BE16(pos, key_data_len);
[K		< 	bin_clear_free(tmp, key_data_len);
[K		< 	if (_key_data_len)
[K		< 		*_key_data_len = key_data_len;
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< int fils_decrypt_assoc(struct wpa_state_machine *sm, const u8 *fils_session,
[K		< 		       const struct ieee80211_mgmt *mgmt, size_t frame_len,
[K		< 		       u8 *pos, size_t left)
[K		< {
[K		< 	u16 fc, stype;
[K		< 	const u8 *end, *ie_start, *ie, *session, *crypt;
[K		< 	struct ieee802_11_elems elems;
[K		< 	const u8 *aad[5];
[K		< 	size_t aad_len[5];
[K		<
[K		< 	if (!sm || !sm->PTK_valid) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: No KEK to decrypt Assocication Request frame");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (!wpa_key_mgmt_fils(sm->wpa_key_mgmt)) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Not a FILS AKM - reject association");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	end = ((const u8 *) mgmt) + frame_len;
[K		< 	fc = le_to_host16(mgmt->frame_control);
[K		< 	stype = WLAN_FC_GET_STYPE(fc);
[K		< 	if (stype == WLAN_FC_STYPE_REASSOC_REQ)
[K		< 		ie_start = mgmt->u.reassoc_req.variable;
[K		< 	else
[K		< 		ie_start = mgmt->u.assoc_req.variable;
[K		< 	ie = ie_start;
[K		<
[K		< 	/*
[K		< 	 * Find FILS Session element which is the last unencrypted element in
[K		< 	 * the frame.
[K		< 	 */
[K		< 	session = NULL;
[K		< 	while (ie + 1 < end) {
[K		< 		if (ie + 2 + ie[1] > end)
[K		< 			break;
[K		< 		if (ie[0] == WLAN_EID_EXTENSION &&
[K		< 		    ie[1] >= 1 + FILS_SESSION_LEN &&
[K		< 		    ie[2] == WLAN_EID_EXT_FILS_SESSION) {
[K		< 			session = ie;
[K		< 			break;
[K		< 		}
[K		< 		ie += 2 + ie[1];
[K		< 	}
[K		<
[K		< 	if (!session) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Could not find FILS Session element in Association Request frame - reject");
[K		< 		return -1;
[K		< 	}
[K		< 	if (os_memcmp(fils_session, session + 3, FILS_SESSION_LEN) != 0) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Session mismatch");
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Expected FILS Session",
[K		< 			    fils_session, FILS_SESSION_LEN);
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Received FILS Session",
[K		< 			    session + 3, FILS_SESSION_LEN);
[K		< 		return -1;
[K		< 	}
[K		< 	crypt = session + 2 + session[1];
[K		<
[K		< 	if (end - crypt < AES_BLOCK_SIZE) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Too short frame to include AES-SIV data");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	/* AES-SIV AAD vectors */
[K		<
[K		< 	/* The STA's MAC address */
[K		< 	aad[0] = mgmt->sa;
[K		< 	aad_len[0] = ETH_ALEN;
[K		< 	/* The AP's BSSID */
[K		< 	aad[1] = mgmt->da;
[K		< 	aad_len[1] = ETH_ALEN;
[K		< 	/* The STA's nonce */
[K		< 	aad[2] = sm->SNonce;
[K		< 	aad_len[2] = FILS_NONCE_LEN;
[K		< 	/* The AP's nonce */
[K		< 	aad[3] = sm->ANonce;
[K		< 	aad_len[3] = FILS_NONCE_LEN;
[K		< 	/*
[K		< 	 * The (Re)Association Request frame from the Capability Information
[K		< 	 * field to the FILS Session element (both inclusive).
[K		< 	 */
[K		< 	aad[4] = (const u8 *) &mgmt->u.assoc_req.capab_info;
[K		< 	aad_len[4] = crypt - aad[4];
[K		<
[K		< 	if (aes_siv_decrypt(sm->PTK.kek, sm->PTK.kek_len, crypt, end - crypt,
[K		< 			    5, aad, aad_len, pos + (crypt - ie_start)) < 0) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Invalid AES-SIV data in the frame");
[K		< 		return -1;
[K		< 	}
[K		< 	wpa_hexdump(MSG_DEBUG, "FILS: Decrypted Association Request elements",
[K		< 		    pos, left - AES_BLOCK_SIZE);
[K		<
[K		< 	if (ieee802_11_parse_elems(pos, left - AES_BLOCK_SIZE, &elems, 1) ==
[K		< 	    ParseFailed) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Failed to parse decrypted elements");
[K		< 		return -1;
[K		< 	}
[K		< 	if (!elems.fils_key_confirm) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: No FILS Key Confirm element");
[K		< 		return -1;
[K		< 	}
[K		< 	if (elems.fils_key_confirm_len != sm->fils_key_auth_len) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Unexpected Key-Auth length %d (expected %d)",
[K		< 			   elems.fils_key_confirm_len,
[K		< 			   (int) sm->fils_key_auth_len);
[K		< 		return -1;
[K		< 	}
[K		< 	if (os_memcmp(elems.fils_key_confirm, sm->fils_key_auth_sta,
[K		< 		      sm->fils_key_auth_len) != 0) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Key-Auth mismatch");
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Received Key-Auth",
[K		< 			    elems.fils_key_confirm,
[K		< 			    elems.fils_key_confirm_len);
[K		< 		wpa_hexdump(MSG_DEBUG, "FILS: Expected Key-Auth",
[K		< 			    sm->fils_key_auth_sta, sm->fils_key_auth_len);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return left - AES_BLOCK_SIZE;
[K		< }
[K		<
[K		<
[K		< int fils_encrypt_assoc(struct wpa_state_machine *sm, u8 *buf,
[K		< 		       size_t current_len, size_t max_len,
[K		< 		       const struct wpabuf *hlp)
[K		< {
[K		< 	u8 *end = buf + max_len;
[K		< 	u8 *pos = buf + current_len;
[K		< 	struct ieee80211_mgmt *mgmt;
[K		< 	struct wpabuf *plain;
[K		< 	u8 *len, *tmp, *tmp2;
[K		< 	u8 hdr[2];
[K		< 	u8 *gtk, dummy_gtk[32];
[K		< 	size_t gtk_len;
[K		< 	struct wpa_group *gsm;
[K		< 	const u8 *aad[5];
[K		< 	size_t aad_len[5];
[K		<
[K		< 	if (!sm || !sm->PTK_valid)
[K		< 		return -1;
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG,
[K		< 		    "FILS: Association Response frame before FILS processing",
[K		< 		    buf, current_len);
[K		<
[K		< 	mgmt = (struct ieee80211_mgmt *) buf;
[K		<
[K		< 	/* AES-SIV AAD vectors */
[K		<
[K		< 	/* The AP's BSSID */
[K		< 	aad[0] = mgmt->sa;
[K		< 	aad_len[0] = ETH_ALEN;
[K		< 	/* The STA's MAC address */
[K		< 	aad[1] = mgmt->da;
[K		< 	aad_len[1] = ETH_ALEN;
[K		< 	/* The AP's nonce */
[K		< 	aad[2] = sm->ANonce;
[K		< 	aad_len[2] = FILS_NONCE_LEN;
[K		< 	/* The STA's nonce */
[K		< 	aad[3] = sm->SNonce;
[K		< 	aad_len[3] = FILS_NONCE_LEN;
[K		< 	/*
[K		< 	 * The (Re)Association Response frame from the Capability Information
[K		< 	 * field (the same offset in both Association and Reassociation
[K		< 	 * Response frames) to the FILS Session element (both inclusive).
[K		< 	 */
[K		< 	aad[4] = (const u8 *) &mgmt->u.assoc_resp.capab_info;
[K		< 	aad_len[4] = pos - aad[4];
[K		<
[K		< 	/* The following elements will be encrypted with AES-SIV */
[K		<
[K		< 	plain = wpabuf_alloc(1000);
[K		< 	if (!plain)
[K		< 		return -1;
[K		<
[K		< 	/* TODO: FILS Public Key */
[K		<
[K		< 	/* FILS Key Confirmation */
[K		< 	wpabuf_put_u8(plain, WLAN_EID_EXTENSION); /* Element ID */
[K		< 	wpabuf_put_u8(plain, 1 + sm->fils_key_auth_len); /* Length */
[K		< 	/* Element ID Extension */
[K		< 	wpabuf_put_u8(plain, WLAN_EID_EXT_FILS_KEY_CONFIRM);
[K		< 	wpabuf_put_data(plain, sm->fils_key_auth_ap, sm->fils_key_auth_len);
[K		<
[K		< 	/* FILS HLP Container */
[K		< 	if (hlp)
[K		< 		wpabuf_put_buf(plain, hlp);
[K		<
[K		< 	/* TODO: FILS IP Address Assignment */
[K		<
[K		< 	/* Key Delivery */
[K		< 	gsm = sm->group;
[K		< 	wpabuf_put_u8(plain, WLAN_EID_EXTENSION); /* Element ID */
[K		< 	len = wpabuf_put(plain, 1);
[K		< 	wpabuf_put_u8(plain, WLAN_EID_EXT_KEY_DELIVERY);
[K		< 	wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN,
[K		< 			    wpabuf_put(plain, WPA_KEY_RSC_LEN));
[K		< 	/* GTK KDE */
[K		< 	gtk = gsm->GTK[gsm->GN - 1];
[K		< 	gtk_len = gsm->GTK_len;
[K		< 	if (sm->wpa_auth->conf.disable_gtk) {
[K		< 		/*
[K		< 		 * Provide unique random GTK to each STA to prevent use
[K		< 		 * of GTK in the BSS.
[K		< 		 */
[K		< 		if (random_get_bytes(dummy_gtk, gtk_len) < 0) {
[K		< 			wpabuf_free(plain);
[K		< 			return -1;
[K		< 		}
[K		< 		gtk = dummy_gtk;
[K		< 	}
[K		< 	hdr[0] = gsm->GN & 0x03;
[K		< 	hdr[1] = 0;
[K		< 	tmp = wpabuf_put(plain, 0);
[K		< 	tmp2 = wpa_add_kde(tmp, RSN_KEY_DATA_GROUPKEY, hdr, 2,
[K		< 			   gtk, gtk_len);
[K		< 	wpabuf_put(plain, tmp2 - tmp);
[K		<
[K		< 	/* IGTK KDE */
[K		< 	tmp = wpabuf_put(plain, 0);
[K		< 	tmp2 = ieee80211w_kde_add(sm, tmp);
[K		< 	wpabuf_put(plain, tmp2 - tmp);
[K		<
[K		< 	*len = (u8 *) wpabuf_put(plain, 0) - len - 1;
[K		<
[K		< 	if (pos + wpabuf_len(plain) + AES_BLOCK_SIZE > end) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "FILS: Not enough room for FILS elements");
[K		< 		wpabuf_free(plain);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	wpa_hexdump_buf_key(MSG_DEBUG, "FILS: Association Response plaintext",
[K		< 			    plain);
[K		<
[K		< 	if (aes_siv_encrypt(sm->PTK.kek, sm->PTK.kek_len,
[K		< 			    wpabuf_head(plain), wpabuf_len(plain),
[K		< 			    5, aad, aad_len, pos) < 0) {
[K		< 		wpabuf_free(plain);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG,
[K		< 		    "FILS: Encrypted Association Response elements",
[K		< 		    pos, AES_BLOCK_SIZE + wpabuf_len(plain));
[K		< 	current_len += wpabuf_len(plain) + AES_BLOCK_SIZE;
[K		< 	wpabuf_free(plain);
[K		<
[K		< 	sm->fils_completed = 1;
[K		<
[K		< 	return current_len;
[K		< }
[K		<
[K		<
[K		< int fils_set_tk(struct wpa_state_machine *sm)
[K		< {
[K		< 	enum wpa_alg alg;
[K		< 	int klen;
[K		<
[K		< 	if (!sm || !sm->PTK_valid)
[K		< 		return -1;
[K		<
[K		< 	alg = wpa_cipher_to_alg(sm->pairwise);
[K		< 	klen = wpa_cipher_key_len(sm->pairwise);
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "FILS: Configure TK to the driver");
[K		< 	if (wpa_auth_set_key(sm->wpa_auth, 0, alg, sm->addr, 0,
[K		< 			     sm->PTK.tk, klen)) {
[K		< 		wpa_printf(MSG_DEBUG, "FILS: Failed to set TK to the driver");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		< #endif /* CONFIG_FILS */
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, PTKCALCNEGOTIATING)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = sm->wpa_auth;
[K		< 	struct wpa_ptk PTK;
[K		< 	int ok = 0, psk_found = 0;
[K		< 	const u8 *pmk = NULL;
[K		< 	unsigned int pmk_len;
[K		< 	int ft;
[K		< 	const u8 *eapol_key_ie, *key_data, *mic;
[K		< 	u16 key_data_length;
[K		< 	size_t mic_len, eapol_key_ie_len;
[K		< 	struct ieee802_1x_hdr *hdr;
[K		< 	struct wpa_eapol_key *key;
[K		< 	struct wpa_eapol_ie_parse kde;
[K		<
[K		< 	SM_ENTRY_MA(WPA_PTK, PTKCALCNEGOTIATING, wpa_ptk);
[K		< 	sm->EAPOLKeyReceived = FALSE;
[K		< 	sm->update_snonce = FALSE;
[K		< 	os_memset(&PTK, 0, sizeof(PTK));
[K		<
[K		< 	mic_len = wpa_mic_len(sm->wpa_key_mgmt);
[K		<
[K		< 	/* WPA with IEEE 802.1X: use the derived PMK from EAP
[K		< 	 * WPA-PSK: iterate through possible PSKs and select the one matching
[K		< 	 * the packet */
[K		< 	for (;;) {
[K		< 		if (wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt)) {
[K		< 			pmk = wpa_auth_get_psk(sm->wpa_auth, sm->addr,
[K		< 					       sm->p2p_dev_addr, pmk);
[K		< 			if (pmk == NULL)
[K		< 				break;
[K		< 			psk_found = 1;
[K		< 			pmk_len = PMK_LEN;
[K		< 		} else {
[K		< 			pmk = sm->PMK;
[K		< 			pmk_len = sm->pmk_len;
[K		< 		}
[K		<
[K		< 		if (wpa_derive_ptk(sm, sm->SNonce, pmk, pmk_len, &PTK) < 0)
[K		< 			break;
[K		<
[K		< 		if (mic_len &&
[K		< 		    wpa_verify_key_mic(sm->wpa_key_mgmt, &PTK,
[K		< 				       sm->last_rx_eapol_key,
[K		< 				       sm->last_rx_eapol_key_len) == 0) {
[K		< 			ok = 1;
[K		< 			break;
[K		< 		}
[K		<
[K		< #ifdef CONFIG_FILS
[K		< 		if (!mic_len &&
[K		< 		    wpa_aead_decrypt(sm, &PTK, sm->last_rx_eapol_key,
[K		< 				     sm->last_rx_eapol_key_len, NULL) == 0) {
[K		< 			ok = 1;
[K		< 			break;
[K		< 		}
[K		< #endif /* CONFIG_FILS */
[K		<
[K		< 		if (!wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt))
[K		< 			break;
[K		< 	}
[K		<
[K		< 	if (!ok) {
[K		< 		wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"invalid MIC in msg 2/4 of 4-Way Handshake");
[K		< 		if (psk_found)
[K		< 			wpa_auth_psk_failure_report(sm->wpa_auth, sm->addr);
[K		< 		return;
[K		< 	}
[K		<
[K		< 	/*
[K		< 	 * Note: last_rx_eapol_key length fields have already been validated in
[K		< 	 * wpa_receive().
[K		< 	 */
[K		< 	hdr = (struct ieee802_1x_hdr *) sm->last_rx_eapol_key;
[K		< 	key = (struct wpa_eapol_key *) (hdr + 1);
[K		< 	mic = (u8 *) (key + 1);
[K		< 	key_data = mic + mic_len + 2;
[K		< 	key_data_length = WPA_GET_BE16(mic + mic_len);
[K		< 	if (key_data_length > sm->last_rx_eapol_key_len - sizeof(*hdr) -
[K		< 	    sizeof(*key) - mic_len - 2)
[K		< 		return;
[K		<
[K		< 	if (wpa_parse_kde_ies(key_data, key_data_length, &kde) < 0) {
[K		< 		wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				 "received EAPOL-Key msg 2/4 with invalid Key Data contents");
[K		< 		return;
[K		< 	}
[K		< 	if (kde.rsn_ie) {
[K		< 		eapol_key_ie = kde.rsn_ie;
[K		< 		eapol_key_ie_len = kde.rsn_ie_len;
[K		< 	} else if (kde.osen) {
[K		< 		eapol_key_ie = kde.osen;
[K		< 		eapol_key_ie_len = kde.osen_len;
[K		< 	} else {
[K		< 		eapol_key_ie = kde.wpa_ie;
[K		< 		eapol_key_ie_len = kde.wpa_ie_len;
[K		< 	}
[K		< 	ft = sm->wpa == WPA_VERSION_WPA2 && wpa_key_mgmt_ft(sm->wpa_key_mgmt);
[K		< 	if (sm->wpa_ie == NULL ||
[K		< 	    wpa_compare_rsn_ie(ft, sm->wpa_ie, sm->wpa_ie_len,
[K		< 			       eapol_key_ie, eapol_key_ie_len)) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_INFO,
[K		< 				"WPA IE from (Re)AssocReq did not match with msg 2/4");
[K		< 		if (sm->wpa_ie) {
[K		< 			wpa_hexdump(MSG_DEBUG, "WPA IE in AssocReq",
[K		< 				    sm->wpa_ie, sm->wpa_ie_len);
[K		< 		}
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA IE in msg 2/4",
[K		< 			    eapol_key_ie, eapol_key_ie_len);
[K		< 		/* MLME-DEAUTHENTICATE.request */
[K		< 		wpa_sta_disconnect(wpa_auth, sm->addr);
[K		< 		return;
[K		< 	}
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (ft && ft_check_msg_2_of_4(wpa_auth, sm, &kde) < 0) {
[K		< 		wpa_sta_disconnect(wpa_auth, sm->addr);
[K		< 		return;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< #ifdef CONFIG_P2P
[K		< 	if (kde.ip_addr_req && kde.ip_addr_req[0] &&
[K		< 	    wpa_auth->ip_pool && WPA_GET_BE32(sm->ip_addr) == 0) {
[K		< 		int idx;
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "P2P: IP address requested in EAPOL-Key exchange");
[K		< 		idx = bitfield_get_first_zero(wpa_auth->ip_pool);
[K		< 		if (idx >= 0) {
[K		< 			u32 start = WPA_GET_BE32(wpa_auth->conf.ip_addr_start);
[K		< 			bitfield_set(wpa_auth->ip_pool, idx);
[K		< 			WPA_PUT_BE32(sm->ip_addr, start + idx);
[K		< 			wpa_printf(MSG_DEBUG,
[K		< 				   "P2P: Assigned IP address %u.%u.%u.%u to "
[K		< 				   MACSTR, sm->ip_addr[0], sm->ip_addr[1],
[K		< 				   sm->ip_addr[2], sm->ip_addr[3],
[K		< 				   MAC2STR(sm->addr));
[K		< 		}
[K		< 	}
[K		< #endif /* CONFIG_P2P */
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (sm->wpa == WPA_VERSION_WPA2 && wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
[K		< 		/*
[K		< 		 * Verify that PMKR1Name from EAPOL-Key message 2/4 matches
[K		< 		 * with the value we derived.
[K		< 		 */
[K		< 		if (os_memcmp_const(sm->sup_pmk_r1_name, sm->pmk_r1_name,
[K		< 				    WPA_PMK_NAME_LEN) != 0) {
[K		< 			wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					"PMKR1Name mismatch in FT 4-way "
[K		< 					"handshake");
[K		< 			wpa_hexdump(MSG_DEBUG, "FT: PMKR1Name from "
[K		< 				    "Supplicant",
[K		< 				    sm->sup_pmk_r1_name, WPA_PMK_NAME_LEN);
[K		< 			wpa_hexdump(MSG_DEBUG, "FT: Derived PMKR1Name",
[K		< 				    sm->pmk_r1_name, WPA_PMK_NAME_LEN);
[K		< 			return;
[K		< 		}
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		<
[K		< 	sm->pending_1_of_4_timeout = 0;
[K		< 	eloop_cancel_timeout(wpa_send_eapol_timeout, sm->wpa_auth, sm);
[K		<
[K		< 	if (wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt)) {
[K		< 		/* PSK may have changed from the previous choice, so update
[K		< 		 * state machine data based on whatever PSK was selected here.
[K		< 		 */
[K		< 		os_memcpy(sm->PMK, pmk, PMK_LEN);
[K		< 		sm->pmk_len = PMK_LEN;
[K		< 	}
[K		<
[K		< 	sm->MICVerified = TRUE;
[K		<
[K		< 	os_memcpy(&sm->PTK, &PTK, sizeof(PTK));
[K		< 	sm->PTK_valid = TRUE;
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, PTKCALCNEGOTIATING2)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, PTKCALCNEGOTIATING2, wpa_ptk);
[K		< 	sm->TimeoutCtr = 0;
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_IEEE80211W
[K		<
[K		< static int ieee80211w_kde_len(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm->mgmt_frame_prot) {
[K		< 		size_t len;
[K		< 		len = wpa_cipher_key_len(sm->wpa_auth->conf.group_mgmt_cipher);
[K		< 		return 2 + RSN_SELECTOR_LEN + WPA_IGTK_KDE_PREFIX_LEN + len;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static u8 * ieee80211w_kde_add(struct wpa_state_machine *sm, u8 *pos)
[K		< {
[K		< 	struct wpa_igtk_kde igtk;
[K		< 	struct wpa_group *gsm = sm->group;
[K		< 	u8 rsc[WPA_KEY_RSC_LEN];
[K		< 	size_t len = wpa_cipher_key_len(sm->wpa_auth->conf.group_mgmt_cipher);
[K		<
[K		< 	if (!sm->mgmt_frame_prot)
[K		< 		return pos;
[K		<
[K		< 	igtk.keyid[0] = gsm->GN_igtk;
[K		< 	igtk.keyid[1] = 0;
[K		< 	if (gsm->wpa_group_state != WPA_GROUP_SETKEYSDONE ||
[K		< 	    wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN_igtk, rsc) < 0)
[K		< 		os_memset(igtk.pn, 0, sizeof(igtk.pn));
[K		< 	else
[K		< 		os_memcpy(igtk.pn, rsc, sizeof(igtk.pn));
[K		< 	os_memcpy(igtk.igtk, gsm->IGTK[gsm->GN_igtk - 4], len);
[K		< 	if (sm->wpa_auth->conf.disable_gtk) {
[K		< 		/*
[K		< 		 * Provide unique random IGTK to each STA to prevent use of
[K		< 		 * IGTK in the BSS.
[K		< 		 */
[K		< 		if (random_get_bytes(igtk.igtk, len) < 0)
[K		< 			return pos;
[K		< 	}
[K		< 	pos = wpa_add_kde(pos, RSN_KEY_DATA_IGTK,
[K		< 			  (const u8 *) &igtk, WPA_IGTK_KDE_PREFIX_LEN + len,
[K		< 			  NULL, 0);
[K		<
[K		< 	return pos;
[K		< }
[K		<
[K		< #else /* CONFIG_IEEE80211W */
[K		<
[K		< static int ieee80211w_kde_len(struct wpa_state_machine *sm)
[K		< {
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static u8 * ieee80211w_kde_add(struct wpa_state_machine *sm, u8 *pos)
[K		< {
[K		< 	return pos;
[K		< }
[K		<
[K		< #endif /* CONFIG_IEEE80211W */
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, PTKINITNEGOTIATING)
[K		< {
[K		< 	u8 rsc[WPA_KEY_RSC_LEN], *_rsc, *gtk, *kde, *pos, dummy_gtk[32];
[K		< 	size_t gtk_len, kde_len;
[K		< 	struct wpa_group *gsm = sm->group;
[K		< 	u8 *wpa_ie;
[K		< 	int wpa_ie_len, secure, keyidx, encr = 0;
[K		<
[K		< 	SM_ENTRY_MA(WPA_PTK, PTKINITNEGOTIATING, wpa_ptk);
[K		< 	sm->TimeoutEvt = FALSE;
[K		<
[K		< 	sm->TimeoutCtr++;
[K		< 	if (sm->TimeoutCtr > sm->wpa_auth->conf.wpa_pairwise_update_count) {
[K		< 		/* No point in sending the EAPOL-Key - we will disconnect
[K		< 		 * immediately following this. */
[K		< 		return;
[K		< 	}
[K		<
[K		< 	/* Send EAPOL(1, 1, 1, Pair, P, RSC, ANonce, MIC(PTK), RSNIE, [MDIE],
[K		< 	   GTK[GN], IGTK, [FTIE], [TIE * 2])
[K		< 	 */
[K		< 	os_memset(rsc, 0, WPA_KEY_RSC_LEN);
[K		< 	wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN, rsc);
[K		< 	/* If FT is used, wpa_auth->wpa_ie includes both RSNIE and MDIE */
[K		< 	wpa_ie = sm->wpa_auth->wpa_ie;
[K		< 	wpa_ie_len = sm->wpa_auth->wpa_ie_len;
[K		< 	if (sm->wpa == WPA_VERSION_WPA &&
[K		< 	    (sm->wpa_auth->conf.wpa & WPA_PROTO_RSN) &&
[K		< 	    wpa_ie_len > wpa_ie[1] + 2 && wpa_ie[0] == WLAN_EID_RSN) {
[K		< 		/* WPA-only STA, remove RSN IE and possible MDIE */
[K		< 		wpa_ie = wpa_ie + wpa_ie[1] + 2;
[K		< 		if (wpa_ie[0] == WLAN_EID_MOBILITY_DOMAIN)
[K		< 			wpa_ie = wpa_ie + wpa_ie[1] + 2;
[K		< 		wpa_ie_len = wpa_ie[1] + 2;
[K		< 	}
[K		< 	wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 			"sending 3/4 msg of 4-Way Handshake");
[K		< 	if (sm->wpa == WPA_VERSION_WPA2) {
[K		< 		/* WPA2 send GTK in the 4-way handshake */
[K		< 		secure = 1;
[K		< 		gtk = gsm->GTK[gsm->GN - 1];
[K		< 		gtk_len = gsm->GTK_len;
[K		< 		if (sm->wpa_auth->conf.disable_gtk) {
[K		< 			/*
[K		< 			 * Provide unique random GTK to each STA to prevent use
[K		< 			 * of GTK in the BSS.
[K		< 			 */
[K		< 			if (random_get_bytes(dummy_gtk, gtk_len) < 0)
[K		< 				return;
[K		< 			gtk = dummy_gtk;
[K		< 		}
[K		< 		keyidx = gsm->GN;
[K		< 		_rsc = rsc;
[K		< 		encr = 1;
[K		< 	} else {
[K		< 		/* WPA does not include GTK in msg 3/4 */
[K		< 		secure = 0;
[K		< 		gtk = NULL;
[K		< 		gtk_len = 0;
[K		< 		keyidx = 0;
[K		< 		_rsc = NULL;
[K		< 		if (sm->rx_eapol_key_secure) {
[K		< 			/*
[K		< 			 * It looks like Windows 7 supplicant tries to use
[K		< 			 * Secure bit in msg 2/4 after having reported Michael
[K		< 			 * MIC failure and it then rejects the 4-way handshake
[K		< 			 * if msg 3/4 does not set Secure bit. Work around this
[K		< 			 * by setting the Secure bit here even in the case of
[K		< 			 * WPA if the supplicant used it first.
[K		< 			 */
[K		< 			wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 					"STA used Secure bit in WPA msg 2/4 - "
[K		< 					"set Secure for 3/4 as workaround");
[K		< 			secure = 1;
[K		< 		}
[K		< 	}
[K		<
[K		< 	kde_len = wpa_ie_len + ieee80211w_kde_len(sm);
[K		< 	if (gtk)
[K		< 		kde_len += 2 + RSN_SELECTOR_LEN + 2 + gtk_len;
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
[K		< 		kde_len += 2 + PMKID_LEN; /* PMKR1Name into RSN IE */
[K		< 		kde_len += 300; /* FTIE + 2 * TIE */
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< #ifdef CONFIG_P2P
[K		< 	if (WPA_GET_BE32(sm->ip_addr) > 0)
[K		< 		kde_len += 2 + RSN_SELECTOR_LEN + 3 * 4;
[K		< #endif /* CONFIG_P2P */
[K		< 	kde = os_malloc(kde_len);
[K		< 	if (kde == NULL)
[K		< 		return;
[K		<
[K		< 	pos = kde;
[K		< 	os_memcpy(pos, wpa_ie, wpa_ie_len);
[K		< 	pos += wpa_ie_len;
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
[K		< 		int res;
[K		< 		size_t elen;
[K		<
[K		< 		elen = pos - kde;
[K		< 		res = wpa_insert_pmkid(kde, &elen, sm->pmk_r1_name);
[K		< 		if (res < 0) {
[K		< 			wpa_printf(MSG_ERROR, "FT: Failed to insert "
[K		< 				   "PMKR1Name into RSN IE in EAPOL-Key data");
[K		< 			os_free(kde);
[K		< 			return;
[K		< 		}
[K		< 		pos -= wpa_ie_len;
[K		< 		pos += elen;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< 	if (gtk) {
[K		< 		u8 hdr[2];
[K		< 		hdr[0] = keyidx & 0x03;
[K		< 		hdr[1] = 0;
[K		< 		pos = wpa_add_kde(pos, RSN_KEY_DATA_GROUPKEY, hdr, 2,
[K		< 				  gtk, gtk_len);
[K		< 	}
[K		< 	pos = ieee80211w_kde_add(sm, pos);
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
[K		< 		int res;
[K		< 		struct wpa_auth_config *conf;
[K		<
[K		< 		conf = &sm->wpa_auth->conf;
[K		< 		if (sm->assoc_resp_ftie &&
[K		< 		    kde + kde_len - pos >= 2 + sm->assoc_resp_ftie[1]) {
[K		< 			os_memcpy(pos, sm->assoc_resp_ftie,
[K		< 				  2 + sm->assoc_resp_ftie[1]);
[K		< 			res = 2 + sm->assoc_resp_ftie[1];
[K		< 		} else {
[K		< 			res = wpa_write_ftie(conf, conf->r0_key_holder,
[K		< 					     conf->r0_key_holder_len,
[K		< 					     NULL, NULL, pos,
[K		< 					     kde + kde_len - pos,
[K		< 					     NULL, 0);
[K		< 		}
[K		< 		if (res < 0) {
[K		< 			wpa_printf(MSG_ERROR, "FT: Failed to insert FTIE "
[K		< 				   "into EAPOL-Key Key Data");
[K		< 			os_free(kde);
[K		< 			return;
[K		< 		}
[K		< 		pos += res;
[K		<
[K		< 		/* TIE[ReassociationDeadline] (TU) */
[K		< 		*pos++ = WLAN_EID_TIMEOUT_INTERVAL;
[K		< 		*pos++ = 5;
[K		< 		*pos++ = WLAN_TIMEOUT_REASSOC_DEADLINE;
[K		< 		WPA_PUT_LE32(pos, conf->reassociation_deadline);
[K		< 		pos += 4;
[K		<
[K		< 		/* TIE[KeyLifetime] (seconds) */
[K		< 		*pos++ = WLAN_EID_TIMEOUT_INTERVAL;
[K		< 		*pos++ = 5;
[K		< 		*pos++ = WLAN_TIMEOUT_KEY_LIFETIME;
[K		< 		WPA_PUT_LE32(pos, conf->r0_key_lifetime * 60);
[K		< 		pos += 4;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< #ifdef CONFIG_P2P
[K		< 	if (WPA_GET_BE32(sm->ip_addr) > 0) {
[K		< 		u8 addr[3 * 4];
[K		< 		os_memcpy(addr, sm->ip_addr, 4);
[K		< 		os_memcpy(addr + 4, sm->wpa_auth->conf.ip_addr_mask, 4);
[K		< 		os_memcpy(addr + 8, sm->wpa_auth->conf.ip_addr_go, 4);
[K		< 		pos = wpa_add_kde(pos, WFA_KEY_DATA_IP_ADDR_ALLOC,
[K		< 				  addr, sizeof(addr), NULL, 0);
[K		< 	}
[K		< #endif /* CONFIG_P2P */
[K		<
[K		< 	wpa_send_eapol(sm->wpa_auth, sm,
[K		< 		       (secure ? WPA_KEY_INFO_SECURE : 0) |
[K		< 		       (wpa_mic_len(sm->wpa_key_mgmt) ? WPA_KEY_INFO_MIC : 0) |
[K		< 		       WPA_KEY_INFO_ACK | WPA_KEY_INFO_INSTALL |
[K		< 		       WPA_KEY_INFO_KEY_TYPE,
[K		< 		       _rsc, sm->ANonce, kde, pos - kde, keyidx, encr);
[K		< 	os_free(kde);
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK, PTKINITDONE)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK, PTKINITDONE, wpa_ptk);
[K		< 	sm->EAPOLKeyReceived = FALSE;
[K		< 	if (sm->Pair) {
[K		< 		enum wpa_alg alg = wpa_cipher_to_alg(sm->pairwise);
[K		< 		int klen = wpa_cipher_key_len(sm->pairwise);
[K		< 		if (wpa_auth_set_key(sm->wpa_auth, 0, alg, sm->addr, 0,
[K		< 				     sm->PTK.tk, klen)) {
[K		< 			wpa_sta_disconnect(sm->wpa_auth, sm->addr);
[K		< 			return;
[K		< 		}
[K		< 		/* FIX: MLME-SetProtection.Request(TA, Tx_Rx) */
[K		< 		sm->pairwise_set = TRUE;
[K		<
[K		< 		if (sm->wpa_auth->conf.wpa_ptk_rekey) {
[K		< 			eloop_cancel_timeout(wpa_rekey_ptk, sm->wpa_auth, sm);
[K		< 			eloop_register_timeout(sm->wpa_auth->conf.
[K		< 					       wpa_ptk_rekey, 0, wpa_rekey_ptk,
[K		< 					       sm->wpa_auth, sm);
[K		< 		}
[K		<
[K		< 		if (wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt)) {
[K		< 			wpa_auth_set_eapol(sm->wpa_auth, sm->addr,
[K		< 					   WPA_EAPOL_authorized, 1);
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (0 /* IBSS == TRUE */) {
[K		< 		sm->keycount++;
[K		< 		if (sm->keycount == 2) {
[K		< 			wpa_auth_set_eapol(sm->wpa_auth, sm->addr,
[K		< 					   WPA_EAPOL_portValid, 1);
[K		< 		}
[K		< 	} else {
[K		< 		wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_portValid,
[K		< 				   1);
[K		< 	}
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_keyAvailable, 0);
[K		< 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_keyDone, 1);
[K		< 	if (sm->wpa == WPA_VERSION_WPA)
[K		< 		sm->PInitAKeys = TRUE;
[K		< 	else
[K		< 		sm->has_GTK = TRUE;
[K		< 	wpa_auth_vlogger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 			 "pairwise key handshake completed (%s)",
[K		< 			 sm->wpa == WPA_VERSION_WPA ? "WPA" : "RSN");
[K		<
[K		< #ifdef CONFIG_IEEE80211R_AP
[K		< 	wpa_ft_push_pmk_r1(sm->wpa_auth, sm->addr);
[K		< #endif /* CONFIG_IEEE80211R_AP */
[K		< }
[K		<
[K		<
[K		< SM_STEP(WPA_PTK)
[K		< {
[K		< 	struct wpa_authenticator *wpa_auth = sm->wpa_auth;
[K		<
[K		< 	if (sm->Init)
[K		< 		SM_ENTER(WPA_PTK, INITIALIZE);
[K		< 	else if (sm->Disconnect
[K		< 		 /* || FIX: dot11RSNAConfigSALifetime timeout */) {
[K		< 		wpa_auth_logger(wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"WPA_PTK: sm->Disconnect");
[K		< 		SM_ENTER(WPA_PTK, DISCONNECT);
[K		< 	}
[K		< 	else if (sm->DeauthenticationRequest)
[K		< 		SM_ENTER(WPA_PTK, DISCONNECTED);
[K		< 	else if (sm->AuthenticationRequest)
[K		< 		SM_ENTER(WPA_PTK, AUTHENTICATION);
[K		< 	else if (sm->ReAuthenticationRequest)
[K		< 		SM_ENTER(WPA_PTK, AUTHENTICATION2);
[K		< 	else if (sm->PTKRequest)
[K		< 		SM_ENTER(WPA_PTK, PTKSTART);
[K		< 	else switch (sm->wpa_ptk_state) {
[K		< 	case WPA_PTK_INITIALIZE:
[K		< 		break;
[K		< 	case WPA_PTK_DISCONNECT:
[K		< 		SM_ENTER(WPA_PTK, DISCONNECTED);
[K		< 		break;
[K		< 	case WPA_PTK_DISCONNECTED:
[K		< 		SM_ENTER(WPA_PTK, INITIALIZE);
[K		< 		break;
[K		< 	case WPA_PTK_AUTHENTICATION:
[K		< 		SM_ENTER(WPA_PTK, AUTHENTICATION2);
[K		< 		break;
[K		< 	case WPA_PTK_AUTHENTICATION2:
[K		< 		if (wpa_key_mgmt_wpa_ieee8021x(sm->wpa_key_mgmt) &&
[K		< 		    wpa_auth_get_eapol(sm->wpa_auth, sm->addr,
[K		< 				       WPA_EAPOL_keyRun) > 0)
[K		< 			SM_ENTER(WPA_PTK, INITPMK);
[K		< 		else if (wpa_key_mgmt_wpa_psk(sm->wpa_key_mgmt)
[K		< 			 /* FIX: && 802.1X::keyRun */)
[K		< 			SM_ENTER(WPA_PTK, INITPSK);
[K		< 		break;
[K		< 	case WPA_PTK_INITPMK:
[K		< 		if (wpa_auth_get_eapol(sm->wpa_auth, sm->addr,
[K		< 				       WPA_EAPOL_keyAvailable) > 0)
[K		< 			SM_ENTER(WPA_PTK, PTKSTART);
[K		< 		else {
[K		< 			wpa_auth->dot11RSNA4WayHandshakeFailures++;
[K		< 			wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"INITPMK - keyAvailable = false");
[K		< 			SM_ENTER(WPA_PTK, DISCONNECT);
[K		< 		}
[K		< 		break;
[K		< 	case WPA_PTK_INITPSK:
[K		< 		if (wpa_auth_get_psk(sm->wpa_auth, sm->addr, sm->p2p_dev_addr,
[K		< 				     NULL))
[K		< 			SM_ENTER(WPA_PTK, PTKSTART);
[K		< 		else {
[K		< 			wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 					"no PSK configured for the STA");
[K		< 			wpa_auth->dot11RSNA4WayHandshakeFailures++;
[K		< 			SM_ENTER(WPA_PTK, DISCONNECT);
[K		< 		}
[K		< 		break;
[K		< 	case WPA_PTK_PTKSTART:
[K		< 		if (sm->EAPOLKeyReceived && !sm->EAPOLKeyRequest &&
[K		< 		    sm->EAPOLKeyPairwise)
[K		< 			SM_ENTER(WPA_PTK, PTKCALCNEGOTIATING);
[K		< 		else if (sm->TimeoutCtr >
[K		< 			 sm->wpa_auth->conf.wpa_pairwise_update_count) {
[K		< 			wpa_auth->dot11RSNA4WayHandshakeFailures++;
[K		< 			wpa_auth_vlogger(
[K		< 				sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"PTKSTART: Retry limit %u reached",
[K		< 				sm->wpa_auth->conf.wpa_pairwise_update_count);
[K		< 			SM_ENTER(WPA_PTK, DISCONNECT);
[K		< 		} else if (sm->TimeoutEvt)
[K		< 			SM_ENTER(WPA_PTK, PTKSTART);
[K		< 		break;
[K		< 	case WPA_PTK_PTKCALCNEGOTIATING:
[K		< 		if (sm->MICVerified)
[K		< 			SM_ENTER(WPA_PTK, PTKCALCNEGOTIATING2);
[K		< 		else if (sm->EAPOLKeyReceived && !sm->EAPOLKeyRequest &&
[K		< 			 sm->EAPOLKeyPairwise)
[K		< 			SM_ENTER(WPA_PTK, PTKCALCNEGOTIATING);
[K		< 		else if (sm->TimeoutEvt)
[K		< 			SM_ENTER(WPA_PTK, PTKSTART);
[K		< 		break;
[K		< 	case WPA_PTK_PTKCALCNEGOTIATING2:
[K		< 		SM_ENTER(WPA_PTK, PTKINITNEGOTIATING);
[K		< 		break;
[K		< 	case WPA_PTK_PTKINITNEGOTIATING:
[K		< 		if (sm->update_snonce)
[K		< 			SM_ENTER(WPA_PTK, PTKCALCNEGOTIATING);
[K		< 		else if (sm->EAPOLKeyReceived && !sm->EAPOLKeyRequest &&
[K		< 			 sm->EAPOLKeyPairwise && sm->MICVerified)
[K		< 			SM_ENTER(WPA_PTK, PTKINITDONE);
[K		< 		else if (sm->TimeoutCtr >
[K		< 			 sm->wpa_auth->conf.wpa_pairwise_update_count) {
[K		< 			wpa_auth->dot11RSNA4WayHandshakeFailures++;
[K		< 			wpa_auth_vlogger(
[K		< 				sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"PTKINITNEGOTIATING: Retry limit %u reached",
[K		< 				sm->wpa_auth->conf.wpa_pairwise_update_count);
[K		< 			SM_ENTER(WPA_PTK, DISCONNECT);
[K		< 		} else if (sm->TimeoutEvt)
[K		< 			SM_ENTER(WPA_PTK, PTKINITNEGOTIATING);
[K		< 		break;
[K		< 	case WPA_PTK_PTKINITDONE:
[K		< 		break;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK_GROUP, IDLE)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK_GROUP, IDLE, wpa_ptk_group);
[K		< 	if (sm->Init) {
[K		< 		/* Init flag is not cleared here, so avoid busy
[K		< 		 * loop by claiming nothing changed. */
[K		< 		sm->changed = FALSE;
[K		< 	}
[K		< 	sm->GTimeoutCtr = 0;
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK_GROUP, REKEYNEGOTIATING)
[K		< {
[K		< 	u8 rsc[WPA_KEY_RSC_LEN];
[K		< 	struct wpa_group *gsm = sm->group;
[K		< 	const u8 *kde;
[K		< 	u8 *kde_buf = NULL, *pos, hdr[2];
[K		< 	size_t kde_len;
[K		< 	u8 *gtk, dummy_gtk[32];
[K		<
[K		< 	SM_ENTRY_MA(WPA_PTK_GROUP, REKEYNEGOTIATING, wpa_ptk_group);
[K		<
[K		< 	sm->GTimeoutCtr++;
[K		< 	if (sm->GTimeoutCtr > sm->wpa_auth->conf.wpa_group_update_count) {
[K		< 		/* No point in sending the EAPOL-Key - we will disconnect
[K		< 		 * immediately following this. */
[K		< 		return;
[K		< 	}
[K		<
[K		< 	if (sm->wpa == WPA_VERSION_WPA)
[K		< 		sm->PInitAKeys = FALSE;
[K		< 	sm->TimeoutEvt = FALSE;
[K		< 	/* Send EAPOL(1, 1, 1, !Pair, G, RSC, GNonce, MIC(PTK), GTK[GN]) */
[K		< 	os_memset(rsc, 0, WPA_KEY_RSC_LEN);
[K		< 	if (gsm->wpa_group_state == WPA_GROUP_SETKEYSDONE)
[K		< 		wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN, rsc);
[K		< 	wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 			"sending 1/2 msg of Group Key Handshake");
[K		<
[K		< 	gtk = gsm->GTK[gsm->GN - 1];
[K		< 	if (sm->wpa_auth->conf.disable_gtk) {
[K		< 		/*
[K		< 		 * Provide unique random GTK to each STA to prevent use
[K		< 		 * of GTK in the BSS.
[K		< 		 */
[K		< 		if (random_get_bytes(dummy_gtk, gsm->GTK_len) < 0)
[K		< 			return;
[K		< 		gtk = dummy_gtk;
[K		< 	}
[K		< 	if (sm->wpa == WPA_VERSION_WPA2) {
[K		< 		kde_len = 2 + RSN_SELECTOR_LEN + 2 + gsm->GTK_len +
[K		< 			ieee80211w_kde_len(sm);
[K		< 		kde_buf = os_malloc(kde_len);
[K		< 		if (kde_buf == NULL)
[K		< 			return;
[K		<
[K		< 		kde = pos = kde_buf;
[K		< 		hdr[0] = gsm->GN & 0x03;
[K		< 		hdr[1] = 0;
[K		< 		pos = wpa_add_kde(pos, RSN_KEY_DATA_GROUPKEY, hdr, 2,
[K		< 				  gtk, gsm->GTK_len);
[K		< 		pos = ieee80211w_kde_add(sm, pos);
[K		< 		kde_len = pos - kde;
[K		< 	} else {
[K		< 		kde = gtk;
[K		< 		kde_len = gsm->GTK_len;
[K		< 	}
[K		<
[K		< 	wpa_send_eapol(sm->wpa_auth, sm,
[K		< 		       WPA_KEY_INFO_SECURE |
[K		< 		       (wpa_mic_len(sm->wpa_key_mgmt) ? WPA_KEY_INFO_MIC : 0) |
[K		< 		       WPA_KEY_INFO_ACK |
[K		< 		       (!sm->Pair ? WPA_KEY_INFO_INSTALL : 0),
[K		< 		       rsc, NULL, kde, kde_len, gsm->GN, 1);
[K		<
[K		< 	os_free(kde_buf);
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK_GROUP, REKEYESTABLISHED)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK_GROUP, REKEYESTABLISHED, wpa_ptk_group);
[K		< 	sm->EAPOLKeyReceived = FALSE;
[K		< 	if (sm->GUpdateStationKeys)
[K		< 		sm->group->GKeyDoneStations--;
[K		< 	sm->GUpdateStationKeys = FALSE;
[K		< 	sm->GTimeoutCtr = 0;
[K		< 	/* FIX: MLME.SetProtection.Request(TA, Tx_Rx) */
[K		< 	wpa_auth_vlogger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 			 "group key handshake completed (%s)",
[K		< 			 sm->wpa == WPA_VERSION_WPA ? "WPA" : "RSN");
[K		< 	sm->has_GTK = TRUE;
[K		< }
[K		<
[K		<
[K		< SM_STATE(WPA_PTK_GROUP, KEYERROR)
[K		< {
[K		< 	SM_ENTRY_MA(WPA_PTK_GROUP, KEYERROR, wpa_ptk_group);
[K		< 	if (sm->GUpdateStationKeys)
[K		< 		sm->group->GKeyDoneStations--;
[K		< 	sm->GUpdateStationKeys = FALSE;
[K		< 	sm->Disconnect = TRUE;
[K		< 	wpa_auth_vlogger(sm->wpa_auth, sm->addr, LOGGER_INFO,
[K		< 			 "group key handshake failed (%s) after %u tries",
[K		< 			 sm->wpa == WPA_VERSION_WPA ? "WPA" : "RSN",
[K		< 			 sm->wpa_auth->conf.wpa_group_update_count);
[K		< }
[K		<
[K		<
[K		< SM_STEP(WPA_PTK_GROUP)
[K		< {
[K		< 	if (sm->Init || sm->PtkGroupInit) {
[K		< 		SM_ENTER(WPA_PTK_GROUP, IDLE);
[K		< 		sm->PtkGroupInit = FALSE;
[K		< 	} else switch (sm->wpa_ptk_group_state) {
[K		< 	case WPA_PTK_GROUP_IDLE:
[K		< 		if (sm->GUpdateStationKeys ||
[K		< 		    (sm->wpa == WPA_VERSION_WPA && sm->PInitAKeys))
[K		< 			SM_ENTER(WPA_PTK_GROUP, REKEYNEGOTIATING);
[K		< 		break;
[K		< 	case WPA_PTK_GROUP_REKEYNEGOTIATING:
[K		< 		if (sm->EAPOLKeyReceived && !sm->EAPOLKeyRequest &&
[K		< 		    !sm->EAPOLKeyPairwise && sm->MICVerified)
[K		< 			SM_ENTER(WPA_PTK_GROUP, REKEYESTABLISHED);
[K		< 		else if (sm->GTimeoutCtr >
[K		< 			 sm->wpa_auth->conf.wpa_group_update_count)
[K		< 			SM_ENTER(WPA_PTK_GROUP, KEYERROR);
[K		< 		else if (sm->TimeoutEvt)
[K		< 			SM_ENTER(WPA_PTK_GROUP, REKEYNEGOTIATING);
[K		< 		break;
[K		< 	case WPA_PTK_GROUP_KEYERROR:
[K		< 		SM_ENTER(WPA_PTK_GROUP, IDLE);
[K		< 		break;
[K		< 	case WPA_PTK_GROUP_REKEYESTABLISHED:
[K		< 		SM_ENTER(WPA_PTK_GROUP, IDLE);
[K		< 		break;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< static int wpa_gtk_update(struct wpa_authenticator *wpa_auth,
[K		< 			  struct wpa_group *group)
[K		< {
[K		< 	int ret = 0;
[K		<
[K		< 	os_memcpy(group->GNonce, group->Counter, WPA_NONCE_LEN);
[K		< 	inc_byte_array(group->Counter, WPA_NONCE_LEN);
[K		< 	if (wpa_gmk_to_gtk(group->GMK, "Group key expansion",
[K		< 			   wpa_auth->addr, group->GNonce,
[K		< 			   group->GTK[group->GN - 1], group->GTK_len) < 0)
[K		< 		ret = -1;
[K		< 	wpa_hexdump_key(MSG_DEBUG, "GTK",
[K		< 			group->GTK[group->GN - 1], group->GTK_len);
[K		<
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (wpa_auth->conf.ieee80211w != NO_MGMT_FRAME_PROTECTION) {
[K		< 		size_t len;
[K		< 		len = wpa_cipher_key_len(wpa_auth->conf.group_mgmt_cipher);
[K		< 		os_memcpy(group->GNonce, group->Counter, WPA_NONCE_LEN);
[K		< 		inc_byte_array(group->Counter, WPA_NONCE_LEN);
[K		< 		if (wpa_gmk_to_gtk(group->GMK, "IGTK key expansion",
[K		< 				   wpa_auth->addr, group->GNonce,
[K		< 				   group->IGTK[group->GN_igtk - 4], len) < 0)
[K		< 			ret = -1;
[K		< 		wpa_hexdump_key(MSG_DEBUG, "IGTK",
[K		< 				group->IGTK[group->GN_igtk - 4], len);
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211W */
[K		<
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< static void wpa_group_gtk_init(struct wpa_authenticator *wpa_auth,
[K		< 			       struct wpa_group *group)
[K		< {
[K		< 	wpa_printf(MSG_DEBUG, "WPA: group state machine entering state "
[K		< 		   "GTK_INIT (VLAN-ID %d)", group->vlan_id);
[K		< 	group->changed = FALSE; /* GInit is not cleared here; avoid loop */
[K		< 	group->wpa_group_state = WPA_GROUP_GTK_INIT;
[K		<
[K		< 	/* GTK[0..N] = 0 */
[K		< 	os_memset(group->GTK, 0, sizeof(group->GTK));
[K		< 	group->GN = 1;
[K		< 	group->GM = 2;
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	group->GN_igtk = 4;
[K		< 	group->GM_igtk = 5;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	/* GTK[GN] = CalcGTK() */
[K		< 	wpa_gtk_update(wpa_auth, group);
[K		< }
[K		<
[K		<
[K		< static int wpa_group_update_sta(struct wpa_state_machine *sm, void *ctx)
[K		< {
[K		< 	if (ctx != NULL && ctx != sm->group)
[K		< 		return 0;
[K		<
[K		< 	if (sm->wpa_ptk_state != WPA_PTK_PTKINITDONE) {
[K		< 		wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"Not in PTKINITDONE; skip Group Key update");
[K		< 		sm->GUpdateStationKeys = FALSE;
[K		< 		return 0;
[K		< 	}
[K		< 	if (sm->GUpdateStationKeys) {
[K		< 		/*
[K		< 		 * This should not really happen, so add a debug log entry.
[K		< 		 * Since we clear the GKeyDoneStations before the loop, the
[K		< 		 * station needs to be counted here anyway.
[K		< 		 */
[K		< 		wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
[K		< 				"GUpdateStationKeys was already set when "
[K		< 				"marking station for GTK rekeying");
[K		< 	}
[K		<
[K		< 	/* Do not rekey GTK/IGTK when STA is in WNM-Sleep Mode */
[K		< 	if (sm->is_wnmsleep)
[K		< 		return 0;
[K		<
[K		< 	sm->group->GKeyDoneStations++;
[K		< 	sm->GUpdateStationKeys = TRUE;
[K		<
[K		< 	wpa_sm_step(sm);
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_WNM
[K		< /* update GTK when exiting WNM-Sleep Mode */
[K		< void wpa_wnmsleep_rekey_gtk(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL || sm->is_wnmsleep)
[K		< 		return;
[K		<
[K		< 	wpa_group_update_sta(sm, NULL);
[K		< }
[K		<
[K		<
[K		< void wpa_set_wnmsleep(struct wpa_state_machine *sm, int flag)
[K		< {
[K		< 	if (sm)
[K		< 		sm->is_wnmsleep = !!flag;
[K		< }
[K		<
[K		<
[K		< int wpa_wnmsleep_gtk_subelem(struct wpa_state_machine *sm, u8 *pos)
[K		< {
[K		< 	struct wpa_group *gsm = sm->group;
[K		< 	u8 *start = pos;
[K		<
[K		< 	/*
[K		< 	 * GTK subelement:
[K		< 	 * Sub-elem ID[1] | Length[1] | Key Info[2] | Key Length[1] | RSC[8] |
[K		< 	 * Key[5..32]
[K		< 	 */
[K		< 	*pos++ = WNM_SLEEP_SUBELEM_GTK;
[K		< 	*pos++ = 11 + gsm->GTK_len;
[K		< 	/* Key ID in B0-B1 of Key Info */
[K		< 	WPA_PUT_LE16(pos, gsm->GN & 0x03);
[K		< 	pos += 2;
[K		< 	*pos++ = gsm->GTK_len;
[K		< 	if (wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN, pos) != 0)
[K		< 		return 0;
[K		< 	pos += 8;
[K		< 	os_memcpy(pos, gsm->GTK[gsm->GN - 1], gsm->GTK_len);
[K		< 	pos += gsm->GTK_len;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WNM: GTK Key ID %u in WNM-Sleep Mode exit",
[K		< 		   gsm->GN);
[K		< 	wpa_hexdump_key(MSG_DEBUG, "WNM: GTK in WNM-Sleep Mode exit",
[K		< 			gsm->GTK[gsm->GN - 1], gsm->GTK_len);
[K		<
[K		< 	return pos - start;
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_IEEE80211W
[K		< int wpa_wnmsleep_igtk_subelem(struct wpa_state_machine *sm, u8 *pos)
[K		< {
[K		< 	struct wpa_group *gsm = sm->group;
[K		< 	u8 *start = pos;
[K		< 	size_t len = wpa_cipher_key_len(sm->wpa_auth->conf.group_mgmt_cipher);
[K		<
[K		< 	/*
[K		< 	 * IGTK subelement:
[K		< 	 * Sub-elem ID[1] | Length[1] | KeyID[2] | PN[6] | Key[16]
[K		< 	 */
[K		< 	*pos++ = WNM_SLEEP_SUBELEM_IGTK;
[K		< 	*pos++ = 2 + 6 + len;
[K		< 	WPA_PUT_LE16(pos, gsm->GN_igtk);
[K		< 	pos += 2;
[K		< 	if (wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN_igtk, pos) != 0)
[K		< 		return 0;
[K		< 	pos += 6;
[K		<
[K		< 	os_memcpy(pos, gsm->IGTK[gsm->GN_igtk - 4], len);
[K		< 	pos += len;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WNM: IGTK Key ID %u in WNM-Sleep Mode exit",
[K		< 		   gsm->GN_igtk);
[K		< 	wpa_hexdump_key(MSG_DEBUG, "WNM: IGTK in WNM-Sleep Mode exit",
[K		< 			gsm->IGTK[gsm->GN_igtk - 4], len);
[K		<
[K		< 	return pos - start;
[K		< }
[K		< #endif /* CONFIG_IEEE80211W */
[K		< #endif /* CONFIG_WNM */
[K		<
[K		<
[K		< static void wpa_group_setkeys(struct wpa_authenticator *wpa_auth,
[K		< 			      struct wpa_group *group)
[K		< {
[K		< 	int tmp;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WPA: group state machine entering state "
[K		< 		   "SETKEYS (VLAN-ID %d)", group->vlan_id);
[K		< 	group->changed = TRUE;
[K		< 	group->wpa_group_state = WPA_GROUP_SETKEYS;
[K		< 	group->GTKReKey = FALSE;
[K		< 	tmp = group->GM;
[K		< 	group->GM = group->GN;
[K		< 	group->GN = tmp;
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	tmp = group->GM_igtk;
[K		< 	group->GM_igtk = group->GN_igtk;
[K		< 	group->GN_igtk = tmp;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	/* "GKeyDoneStations = GNoStations" is done in more robust way by
[K		< 	 * counting the STAs that are marked with GUpdateStationKeys instead of
[K		< 	 * including all STAs that could be in not-yet-completed state. */
[K		< 	wpa_gtk_update(wpa_auth, group);
[K		<
[K		< 	if (group->GKeyDoneStations) {
[K		< 		wpa_printf(MSG_DEBUG, "wpa_group_setkeys: Unexpected "
[K		< 			   "GKeyDoneStations=%d when starting new GTK rekey",
[K		< 			   group->GKeyDoneStations);
[K		< 		group->GKeyDoneStations = 0;
[K		< 	}
[K		< 	wpa_auth_for_each_sta(wpa_auth, wpa_group_update_sta, group);
[K		< 	wpa_printf(MSG_DEBUG, "wpa_group_setkeys: GKeyDoneStations=%d",
[K		< 		   group->GKeyDoneStations);
[K		< }
[K		<
[K		<
[K		< static int wpa_group_config_group_keys(struct wpa_authenticator *wpa_auth,
[K		< 				       struct wpa_group *group)
[K		< {
[K		< 	int ret = 0;
[K		<
[K		< 	if (wpa_auth_set_key(wpa_auth, group->vlan_id,
[K		< 			     wpa_cipher_to_alg(wpa_auth->conf.wpa_group),
[K		< 			     broadcast_ether_addr, group->GN,
[K		< 			     group->GTK[group->GN - 1], group->GTK_len) < 0)
[K		< 		ret = -1;
[K		<
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (wpa_auth->conf.ieee80211w != NO_MGMT_FRAME_PROTECTION) {
[K		< 		enum wpa_alg alg;
[K		< 		size_t len;
[K		<
[K		< 		alg = wpa_cipher_to_alg(wpa_auth->conf.group_mgmt_cipher);
[K		< 		len = wpa_cipher_key_len(wpa_auth->conf.group_mgmt_cipher);
[K		<
[K		< 		if (ret == 0 &&
[K		< 		    wpa_auth_set_key(wpa_auth, group->vlan_id, alg,
[K		< 				     broadcast_ether_addr, group->GN_igtk,
[K		< 				     group->IGTK[group->GN_igtk - 4], len) < 0)
[K		< 			ret = -1;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211W */
[K		<
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< static int wpa_group_disconnect_cb(struct wpa_state_machine *sm, void *ctx)
[K		< {
[K		< 	if (sm->group == ctx) {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Mark STA " MACSTR
[K		< 			   " for discconnection due to fatal failure",
[K		< 			   MAC2STR(sm->addr));
[K		< 		sm->Disconnect = TRUE;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_group_fatal_failure(struct wpa_authenticator *wpa_auth,
[K		< 				    struct wpa_group *group)
[K		< {
[K		< 	wpa_printf(MSG_DEBUG, "WPA: group state machine entering state FATAL_FAILURE");
[K		< 	group->changed = TRUE;
[K		< 	group->wpa_group_state = WPA_GROUP_FATAL_FAILURE;
[K		< 	wpa_auth_for_each_sta(wpa_auth, wpa_group_disconnect_cb, group);
[K		< }
[K		<
[K		<
[K		< static int wpa_group_setkeysdone(struct wpa_authenticator *wpa_auth,
[K		< 				 struct wpa_group *group)
[K		< {
[K		< 	wpa_printf(MSG_DEBUG, "WPA: group state machine entering state "
[K		< 		   "SETKEYSDONE (VLAN-ID %d)", group->vlan_id);
[K		< 	group->changed = TRUE;
[K		< 	group->wpa_group_state = WPA_GROUP_SETKEYSDONE;
[K		<
[K		< 	if (wpa_group_config_group_keys(wpa_auth, group) < 0) {
[K		< 		wpa_group_fatal_failure(wpa_auth, group);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_group_sm_step(struct wpa_authenticator *wpa_auth,
[K		< 			      struct wpa_group *group)
[K		< {
[K		< 	if (group->GInit) {
[K		< 		wpa_group_gtk_init(wpa_auth, group);
[K		< 	} else if (group->wpa_group_state == WPA_GROUP_FATAL_FAILURE) {
[K		< 		/* Do not allow group operations */
[K		< 	} else if (group->wpa_group_state == WPA_GROUP_GTK_INIT &&
[K		< 		   group->GTKAuthenticator) {
[K		< 		wpa_group_setkeysdone(wpa_auth, group);
[K		< 	} else if (group->wpa_group_state == WPA_GROUP_SETKEYSDONE &&
[K		< 		   group->GTKReKey) {
[K		< 		wpa_group_setkeys(wpa_auth, group);
[K		< 	} else if (group->wpa_group_state == WPA_GROUP_SETKEYS) {
[K		< 		if (group->GKeyDoneStations == 0)
[K		< 			wpa_group_setkeysdone(wpa_auth, group);
[K		< 		else if (group->GTKReKey)
[K		< 			wpa_group_setkeys(wpa_auth, group);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< static int wpa_sm_step(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return 0;
[K		<
[K		< 	if (sm->in_step_loop) {
[K		< 		/* This should not happen, but if it does, make sure we do not
[K		< 		 * end up freeing the state machine too early by exiting the
[K		< 		 * recursive call. */
[K		< 		wpa_printf(MSG_ERROR, "WPA: wpa_sm_step() called recursively");
[K		< 		return 0;
[K		< 	}
[K		<
[K		< 	sm->in_step_loop = 1;
[K		< 	do {
[K		< 		if (sm->pending_deinit)
[K		< 			break;
[K		<
[K		< 		sm->changed = FALSE;
[K		< 		sm->wpa_auth->group->changed = FALSE;
[K		<
[K		< 		SM_STEP_RUN(WPA_PTK);
[K		< 		if (sm->pending_deinit)
[K		< 			break;
[K		< 		SM_STEP_RUN(WPA_PTK_GROUP);
[K		< 		if (sm->pending_deinit)
[K		< 			break;
[K		< 		wpa_group_sm_step(sm->wpa_auth, sm->group);
[K		< 	} while (sm->changed || sm->wpa_auth->group->changed);
[K		< 	sm->in_step_loop = 0;
[K		<
[K		< 	if (sm->pending_deinit) {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Completing pending STA state "
[K		< 			   "machine deinit for " MACSTR, MAC2STR(sm->addr));
[K		< 		wpa_free_sta_sm(sm);
[K		< 		return 1;
[K		< 	}
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_sm_call_step(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_state_machine *sm = eloop_ctx;
[K		< 	wpa_sm_step(sm);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_sm_notify(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		< 	eloop_register_timeout(0, 0, wpa_sm_call_step, sm, NULL);
[K		< }
[K		<
[K		<
[K		< void wpa_gtk_rekey(struct wpa_authenticator *wpa_auth)
[K		< {
[K		< 	int tmp, i;
[K		< 	struct wpa_group *group;
[K		<
[K		< 	if (wpa_auth == NULL)
[K		< 		return;
[K		<
[K		< 	group = wpa_auth->group;
[K		<
[K		< 	for (i = 0; i < 2; i++) {
[K		< 		tmp = group->GM;
[K		< 		group->GM = group->GN;
[K		< 		group->GN = tmp;
[K		< #ifdef CONFIG_IEEE80211W
[K		< 		tmp = group->GM_igtk;
[K		< 		group->GM_igtk = group->GN_igtk;
[K		< 		group->GN_igtk = tmp;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 		wpa_gtk_update(wpa_auth, group);
[K		< 		wpa_group_config_group_keys(wpa_auth, group);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< static const char * wpa_bool_txt(int val)
[K		< {
[K		< 	return val ? "TRUE" : "FALSE";
[K		< }
[K		<
[K		<
[K		< #define RSN_SUITE "%02x-%02x-%02x-%d"
[K		< #define RSN_SUITE_ARG(s) \
[K		< ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
[K		<
[K		< int wpa_get_mib(struct wpa_authenticator *wpa_auth, char *buf, size_t buflen)
[K		< {
[K		< 	int len = 0, ret;
[K		< 	char pmkid_txt[PMKID_LEN * 2 + 1];
[K		< #ifdef CONFIG_RSN_PREAUTH
[K		< 	const int preauth = 1;
[K		< #else /* CONFIG_RSN_PREAUTH */
[K		< 	const int preauth = 0;
[K		< #endif /* CONFIG_RSN_PREAUTH */
[K		<
[K		< 	if (wpa_auth == NULL)
[K		< 		return len;
[K		<
[K		< 	ret = os_snprintf(buf + len, buflen - len,
[K		< 			  "dot11RSNAOptionImplemented=TRUE\n"
[K		< 			  "dot11RSNAPreauthenticationImplemented=%s\n"
[K		< 			  "dot11RSNAEnabled=%s\n"
[K		< 			  "dot11RSNAPreauthenticationEnabled=%s\n",
[K		< 			  wpa_bool_txt(preauth),
[K		< 			  wpa_bool_txt(wpa_auth->conf.wpa & WPA_PROTO_RSN),
[K		< 			  wpa_bool_txt(wpa_auth->conf.rsn_preauth));
[K		< 	if (os_snprintf_error(buflen - len, ret))
[K		< 		return len;
[K		< 	len += ret;
[K		<
[K		< 	wpa_snprintf_hex(pmkid_txt, sizeof(pmkid_txt),
[K		< 			 wpa_auth->dot11RSNAPMKIDUsed, PMKID_LEN);
[K		<
[K		< 	ret = os_snprintf(
[K		< 		buf + len, buflen - len,
[K		< 		"dot11RSNAConfigVersion=%u\n"
[K		< 		"dot11RSNAConfigPairwiseKeysSupported=9999\n"
[K		< 		/* FIX: dot11RSNAConfigGroupCipher */
[K		< 		/* FIX: dot11RSNAConfigGroupRekeyMethod */
[K		< 		/* FIX: dot11RSNAConfigGroupRekeyTime */
[K		< 		/* FIX: dot11RSNAConfigGroupRekeyPackets */
[K		< 		"dot11RSNAConfigGroupRekeyStrict=%u\n"
[K		< 		"dot11RSNAConfigGroupUpdateCount=%u\n"
[K		< 		"dot11RSNAConfigPairwiseUpdateCount=%u\n"
[K		< 		"dot11RSNAConfigGroupCipherSize=%u\n"
[K		< 		"dot11RSNAConfigPMKLifetime=%u\n"
[K		< 		"dot11RSNAConfigPMKReauthThreshold=%u\n"
[K		< 		"dot11RSNAConfigNumberOfPTKSAReplayCounters=0\n"
[K		< 		"dot11RSNAConfigSATimeout=%u\n"
[K		< 		"dot11RSNAAuthenticationSuiteSelected=" RSN_SUITE "\n"
[K		< 		"dot11RSNAPairwiseCipherSelected=" RSN_SUITE "\n"
[K		< 		"dot11RSNAGroupCipherSelected=" RSN_SUITE "\n"
[K		< 		"dot11RSNAPMKIDUsed=%s\n"
[K		< 		"dot11RSNAAuthenticationSuiteRequested=" RSN_SUITE "\n"
[K		< 		"dot11RSNAPairwiseCipherRequested=" RSN_SUITE "\n"
[K		< 		"dot11RSNAGroupCipherRequested=" RSN_SUITE "\n"
[K		< 		"dot11RSNATKIPCounterMeasuresInvoked=%u\n"
[K		< 		"dot11RSNA4WayHandshakeFailures=%u\n"
[K		< 		"dot11RSNAConfigNumberOfGTKSAReplayCounters=0\n",
[K		< 		RSN_VERSION,
[K		< 		!!wpa_auth->conf.wpa_strict_rekey,
[K		< 		wpa_auth->conf.wpa_group_update_count,
[K		< 		wpa_auth->conf.wpa_pairwise_update_count,
[K		< 		wpa_cipher_key_len(wpa_auth->conf.wpa_group) * 8,
[K		< 		dot11RSNAConfigPMKLifetime,
[K		< 		dot11RSNAConfigPMKReauthThreshold,
[K		< 		dot11RSNAConfigSATimeout,
[K		< 		RSN_SUITE_ARG(wpa_auth->dot11RSNAAuthenticationSuiteSelected),
[K		< 		RSN_SUITE_ARG(wpa_auth->dot11RSNAPairwiseCipherSelected),
[K		< 		RSN_SUITE_ARG(wpa_auth->dot11RSNAGroupCipherSelected),
[K		< 		pmkid_txt,
[K		< 		RSN_SUITE_ARG(wpa_auth->dot11RSNAAuthenticationSuiteRequested),
[K		< 		RSN_SUITE_ARG(wpa_auth->dot11RSNAPairwiseCipherRequested),
[K		< 		RSN_SUITE_ARG(wpa_auth->dot11RSNAGroupCipherRequested),
[K		< 		wpa_auth->dot11RSNATKIPCounterMeasuresInvoked,
[K		< 		wpa_auth->dot11RSNA4WayHandshakeFailures);
[K		< 	if (os_snprintf_error(buflen - len, ret))
[K		< 		return len;
[K		< 	len += ret;
[K		<
[K		< 	/* TODO: dot11RSNAConfigPairwiseCiphersTable */
[K		< 	/* TODO: dot11RSNAConfigAuthenticationSuitesTable */
[K		<
[K		< 	/* Private MIB */
[K		< 	ret = os_snprintf(buf + len, buflen - len, "hostapdWPAGroupState=%d\n",
[K		< 			  wpa_auth->group->wpa_group_state);
[K		< 	if (os_snprintf_error(buflen - len, ret))
[K		< 		return len;
[K		< 	len += ret;
[K		<
[K		< 	return len;
[K		< }
[K		<
[K		<
[K		< int wpa_get_mib_sta(struct wpa_state_machine *sm, char *buf, size_t buflen)
[K		< {
[K		< 	int len = 0, ret;
[K		< 	u32 pairwise = 0;
[K		<
[K		< 	if (sm == NULL)
[K		< 		return 0;
[K		<
[K		< 	/* TODO: FF-FF-FF-FF-FF-FF entry for broadcast/multicast stats */
[K		<
[K		< 	/* dot11RSNAStatsEntry */
[K		<
[K		< 	pairwise = wpa_cipher_to_suite(sm->wpa == WPA_VERSION_WPA2 ?
[K		< 				       WPA_PROTO_RSN : WPA_PROTO_WPA,
[K		< 				       sm->pairwise);
[K		< 	if (pairwise == 0)
[K		< 		return 0;
[K		<
[K		< 	ret = os_snprintf(
[K		< 		buf + len, buflen - len,
[K		< 		/* TODO: dot11RSNAStatsIndex */
[K		< 		"dot11RSNAStatsSTAAddress=" MACSTR "\n"
[K		< 		"dot11RSNAStatsVersion=1\n"
[K		< 		"dot11RSNAStatsSelectedPairwiseCipher=" RSN_SUITE "\n"
[K		< 		/* TODO: dot11RSNAStatsTKIPICVErrors */
[K		< 		"dot11RSNAStatsTKIPLocalMICFailures=%u\n"
[K		< 		"dot11RSNAStatsTKIPRemoteMICFailures=%u\n"
[K		< 		/* TODO: dot11RSNAStatsCCMPReplays */
[K		< 		/* TODO: dot11RSNAStatsCCMPDecryptErrors */
[K		< 		/* TODO: dot11RSNAStatsTKIPReplays */,
[K		< 		MAC2STR(sm->addr),
[K		< 		RSN_SUITE_ARG(pairwise),
[K		< 		sm->dot11RSNAStatsTKIPLocalMICFailures,
[K		< 		sm->dot11RSNAStatsTKIPRemoteMICFailures);
[K		< 	if (os_snprintf_error(buflen - len, ret))
[K		< 		return len;
[K		< 	len += ret;
[K		<
[K		< 	/* Private MIB */
[K		< 	ret = os_snprintf(buf + len, buflen - len,
[K		< 			  "hostapdWPAPTKState=%d\n"
[K		< 			  "hostapdWPAPTKGroupState=%d\n",
[K		< 			  sm->wpa_ptk_state,
[K		< 			  sm->wpa_ptk_group_state);
[K		< 	if (os_snprintf_error(buflen - len, ret))
[K		< 		return len;
[K		< 	len += ret;
[K		<
[K		< 	return len;
[K		< }
[K		<
[K		<
[K		< void wpa_auth_countermeasures_start(struct wpa_authenticator *wpa_auth)
[K		< {
[K		< 	if (wpa_auth)
[K		< 		wpa_auth->dot11RSNATKIPCounterMeasuresInvoked++;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_pairwise_set(struct wpa_state_machine *sm)
[K		< {
[K		< 	return sm && sm->pairwise_set;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_get_pairwise(struct wpa_state_machine *sm)
[K		< {
[K		< 	return sm->pairwise;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_sta_key_mgmt(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		< 	return sm->wpa_key_mgmt;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_sta_wpa_version(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return 0;
[K		< 	return sm->wpa;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_sta_clear_pmksa(struct wpa_state_machine *sm,
[K		< 			     struct rsn_pmksa_cache_entry *entry)
[K		< {
[K		< 	if (sm == NULL || sm->pmksa != entry)
[K		< 		return -1;
[K		< 	sm->pmksa = NULL;
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< struct rsn_pmksa_cache_entry *
[K		< wpa_auth_sta_get_pmksa(struct wpa_state_machine *sm)
[K		< {
[K		< 	return sm ? sm->pmksa : NULL;
[K		< }
[K		<
[K		<
[K		< void wpa_auth_sta_local_mic_failure_report(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm)
[K		< 		sm->dot11RSNAStatsTKIPLocalMICFailures++;
[K		< }
[K		<
[K		<
[K		< const u8 * wpa_auth_get_wpa_ie(struct wpa_authenticator *wpa_auth, size_t *len)
[K		< {
[K		< 	if (wpa_auth == NULL)
[K		< 		return NULL;
[K		< 	*len = wpa_auth->wpa_ie_len;
[K		< 	return wpa_auth->wpa_ie;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_pmksa_add(struct wpa_state_machine *sm, const u8 *pmk,
[K		< 		       unsigned int pmk_len,
[K		< 		       int session_timeout, struct eapol_state_machine *eapol)
[K		< {
[K		< 	if (sm == NULL || sm->wpa != WPA_VERSION_WPA2 ||
[K		< 	    sm->wpa_auth->conf.disable_pmksa_caching)
[K		< 		return -1;
[K		<
[K		< 	if (wpa_key_mgmt_sha384(sm->wpa_key_mgmt)) {
[K		< 		if (pmk_len > PMK_LEN_SUITE_B_192)
[K		< 			pmk_len = PMK_LEN_SUITE_B_192;
[K		< 	} else if (pmk_len > PMK_LEN) {
[K		< 		pmk_len = PMK_LEN;
[K		< 	}
[K		<
[K		< 	if (pmksa_cache_auth_add(sm->wpa_auth->pmksa, pmk, pmk_len, NULL,
[K		< 				 sm->PTK.kck, sm->PTK.kck_len,
[K		< 				 sm->wpa_auth->addr, sm->addr, session_timeout,
[K		< 				 eapol, sm->wpa_key_mgmt))
[K		< 		return 0;
[K		<
[K		< 	return -1;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_pmksa_add_preauth(struct wpa_authenticator *wpa_auth,
[K		< 			       const u8 *pmk, size_t len, const u8 *sta_addr,
[K		< 			       int session_timeout,
[K		< 			       struct eapol_state_machine *eapol)
[K		< {
[K		< 	if (wpa_auth == NULL)
[K		< 		return -1;
[K		<
[K		< 	if (pmksa_cache_auth_add(wpa_auth->pmksa, pmk, len, NULL,
[K		< 				 NULL, 0,
[K		< 				 wpa_auth->addr,
[K		< 				 sta_addr, session_timeout, eapol,
[K		< 				 WPA_KEY_MGMT_IEEE8021X))
[K		< 		return 0;
[K		<
[K		< 	return -1;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_pmksa_add_sae(struct wpa_authenticator *wpa_auth, const u8 *addr,
[K		< 			   const u8 *pmk, const u8 *pmkid)
[K		< {
[K		< 	if (wpa_auth->conf.disable_pmksa_caching)
[K		< 		return -1;
[K		<
[K		< 	if (pmksa_cache_auth_add(wpa_auth->pmksa, pmk, PMK_LEN, pmkid,
[K		< 				 NULL, 0,
[K		< 				 wpa_auth->addr, addr, 0, NULL,
[K		< 				 WPA_KEY_MGMT_SAE))
[K		< 		return 0;
[K		<
[K		< 	return -1;
[K		< }
[K		<
[K		<
[K		< void wpa_auth_pmksa_remove(struct wpa_authenticator *wpa_auth,
[K		< 			   const u8 *sta_addr)
[K		< {
[K		< 	struct rsn_pmksa_cache_entry *pmksa;
[K		<
[K		< 	if (wpa_auth == NULL || wpa_auth->pmksa == NULL)
[K		< 		return;
[K		< 	pmksa = pmksa_cache_auth_get(wpa_auth->pmksa, sta_addr, NULL);
[K		< 	if (pmksa) {
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Remove PMKSA cache entry for "
[K		< 			   MACSTR " based on request", MAC2STR(sta_addr));
[K		< 		pmksa_cache_free_entry(wpa_auth->pmksa, pmksa);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< int wpa_auth_pmksa_list(struct wpa_authenticator *wpa_auth, char *buf,
[K		< 			size_t len)
[K		< {
[K		< 	if (!wpa_auth || !wpa_auth->pmksa)
[K		< 		return 0;
[K		< 	return pmksa_cache_auth_list(wpa_auth->pmksa, buf, len);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_pmksa_flush(struct wpa_authenticator *wpa_auth)
[K		< {
[K		< 	if (wpa_auth && wpa_auth->pmksa)
[K		< 		pmksa_cache_auth_flush(wpa_auth->pmksa);
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_PMKSA_CACHE_EXTERNAL
[K		< #ifdef CONFIG_MESH
[K		<
[K		< int wpa_auth_pmksa_list_mesh(struct wpa_authenticator *wpa_auth, const u8 *addr,
[K		< 			     char *buf, size_t len)
[K		< {
[K		< 	if (!wpa_auth || !wpa_auth->pmksa)
[K		< 		return 0;
[K		<
[K		< 	return pmksa_cache_auth_list_mesh(wpa_auth->pmksa, addr, buf, len);
[K		< }
[K		<
[K		<
[K		< struct rsn_pmksa_cache_entry *
[K		< wpa_auth_pmksa_create_entry(const u8 *aa, const u8 *spa, const u8 *pmk,
[K		< 			    const u8 *pmkid, int expiration)
[K		< {
[K		< 	struct rsn_pmksa_cache_entry *entry;
[K		< 	struct os_reltime now;
[K		<
[K		< 	entry = pmksa_cache_auth_create_entry(pmk, PMK_LEN, pmkid, NULL, 0, aa,
[K		< 					      spa, 0, NULL, WPA_KEY_MGMT_SAE);
[K		< 	if (!entry)
[K		< 		return NULL;
[K		<
[K		< 	os_get_reltime(&now);
[K		< 	entry->expiration = now.sec + expiration;
[K		< 	return entry;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_pmksa_add_entry(struct wpa_authenticator *wpa_auth,
[K		< 			     struct rsn_pmksa_cache_entry *entry)
[K		< {
[K		< 	int ret;
[K		<
[K		< 	if (!wpa_auth || !wpa_auth->pmksa)
[K		< 		return -1;
[K		<
[K		< 	ret = pmksa_cache_auth_add_entry(wpa_auth->pmksa, entry);
[K		< 	if (ret < 0)
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "RSN: Failed to store external PMKSA cache for "
[K		< 			   MACSTR, MAC2STR(entry->spa));
[K		<
[K		< 	return ret;
[K		< }
[K		<
[K		< #endif /* CONFIG_MESH */
[K		< #endif /* CONFIG_PMKSA_CACHE_EXTERNAL */
[K		<
[K		<
[K		< struct rsn_pmksa_cache_entry *
[K		< wpa_auth_pmksa_get(struct wpa_authenticator *wpa_auth, const u8 *sta_addr,
[K		< 		   const u8 *pmkid)
[K		< {
[K		< 	if (!wpa_auth || !wpa_auth->pmksa)
[K		< 		return NULL;
[K		< 	return pmksa_cache_auth_get(wpa_auth->pmksa, sta_addr, pmkid);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_pmksa_set_to_sm(struct rsn_pmksa_cache_entry *pmksa,
[K		< 			      struct wpa_state_machine *sm,
[K		< 			      struct wpa_authenticator *wpa_auth,
[K		< 			      u8 *pmkid, u8 *pmk)
[K		< {
[K		< 	if (!sm)
[K		< 		return;
[K		<
[K		< 	sm->pmksa = pmksa;
[K		< 	os_memcpy(pmk, pmksa->pmk, PMK_LEN);
[K		< 	os_memcpy(pmkid, pmksa->pmkid, PMKID_LEN);
[K		< 	os_memcpy(wpa_auth->dot11RSNAPMKIDUsed, pmksa->pmkid, PMKID_LEN);
[K		< }
[K		<
[K		<
[K		< /*
[K		<  * Remove and free the group from wpa_authenticator. This is triggered by a
[K		<  * callback to make sure nobody is currently iterating the group list while it
[K		<  * gets modified.
[K		<  */
[K		< static void wpa_group_free(struct wpa_authenticator *wpa_auth,
[K		< 			   struct wpa_group *group)
[K		< {
[K		< 	struct wpa_group *prev = wpa_auth->group;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Remove group state machine for VLAN-ID %d",
[K		< 		   group->vlan_id);
[K		<
[K		< 	while (prev) {
[K		< 		if (prev->next == group) {
[K		< 			/* This never frees the special first group as needed */
[K		< 			prev->next = group->next;
[K		< 			os_free(group);
[K		< 			break;
[K		< 		}
[K		< 		prev = prev->next;
[K		< 	}
[K		<
[K		< }
[K		<
[K		<
[K		< /* Increase the reference counter for group */
[K		< static void wpa_group_get(struct wpa_authenticator *wpa_auth,
[K		< 			  struct wpa_group *group)
[K		< {
[K		< 	/* Skip the special first group */
[K		< 	if (wpa_auth->group == group)
[K		< 		return;
[K		<
[K		< 	group->references++;
[K		< }
[K		<
[K		<
[K		< /* Decrease the reference counter and maybe free the group */
[K		< static void wpa_group_put(struct wpa_authenticator *wpa_auth,
[K		< 			  struct wpa_group *group)
[K		< {
[K		< 	/* Skip the special first group */
[K		< 	if (wpa_auth->group == group)
[K		< 		return;
[K		<
[K		< 	group->references--;
[K		< 	if (group->references)
[K		< 		return;
[K		< 	wpa_group_free(wpa_auth, group);
[K		< }
[K		<
[K		<
[K		< /*
[K		<  * Add a group that has its references counter set to zero. Caller needs to
[K		<  * call wpa_group_get() on the return value to mark the entry in use.
[K		<  */
[K		< static struct wpa_group *
[K		< wpa_auth_add_group(struct wpa_authenticator *wpa_auth, int vlan_id)
[K		< {
[K		< 	struct wpa_group *group;
[K		<
[K		< 	if (wpa_auth == NULL || wpa_auth->group == NULL)
[K		< 		return NULL;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Add group state machine for VLAN-ID %d",
[K		< 		   vlan_id);
[K		< 	group = wpa_group_init(wpa_auth, vlan_id, 0);
[K		< 	if (group == NULL)
[K		< 		return NULL;
[K		<
[K		< 	group->next = wpa_auth->group->next;
[K		< 	wpa_auth->group->next = group;
[K		<
[K		< 	return group;
[K		< }
[K		<
[K		<
[K		< /*
[K		<  * Enforce that the group state machine for the VLAN is running, increase
[K		<  * reference counter as interface is up. References might have been increased
[K		<  * even if a negative value is returned.
[K		<  * Returns: -1 on error (group missing, group already failed); otherwise, 0
[K		<  */
[K		< int wpa_auth_ensure_group(struct wpa_authenticator *wpa_auth, int vlan_id)
[K		< {
[K		< 	struct wpa_group *group;
[K		<
[K		< 	if (wpa_auth == NULL)
[K		< 		return 0;
[K		<
[K		< 	group = wpa_auth->group;
[K		< 	while (group) {
[K		< 		if (group->vlan_id == vlan_id)
[K		< 			break;
[K		< 		group = group->next;
[K		< 	}
[K		<
[K		< 	if (group == NULL) {
[K		< 		group = wpa_auth_add_group(wpa_auth, vlan_id);
[K		< 		if (group == NULL)
[K		< 			return -1;
[K		< 	}
[K		<
[K		< 	wpa_printf(MSG_DEBUG,
[K		< 		   "WPA: Ensure group state machine running for VLAN ID %d",
[K		< 		   vlan_id);
[K		<
[K		< 	wpa_group_get(wpa_auth, group);
[K		< 	group->num_setup_iface++;
[K		<
[K		< 	if (group->wpa_group_state == WPA_GROUP_FATAL_FAILURE)
[K		< 		return -1;
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /*
[K		<  * Decrease reference counter, expected to be zero afterwards.
[K		<  * returns: -1 on error (group not found, group in fail state)
[K		<  *          -2 if wpa_group is still referenced
[K		<  *           0 else
[K		<  */
[K		< int wpa_auth_release_group(struct wpa_authenticator *wpa_auth, int vlan_id)
[K		< {
[K		< 	struct wpa_group *group;
[K		< 	int ret = 0;
[K		<
[K		< 	if (wpa_auth == NULL)
[K		< 		return 0;
[K		<
[K		< 	group = wpa_auth->group;
[K		< 	while (group) {
[K		< 		if (group->vlan_id == vlan_id)
[K		< 			break;
[K		< 		group = group->next;
[K		< 	}
[K		<
[K		< 	if (group == NULL)
[K		< 		return -1;
[K		<
[K		< 	wpa_printf(MSG_DEBUG,
[K		< 		   "WPA: Try stopping group state machine for VLAN ID %d",
[K		< 		   vlan_id);
[K		<
[K		< 	if (group->num_setup_iface <= 0) {
[K		< 		wpa_printf(MSG_ERROR,
[K		< 			   "WPA: wpa_auth_release_group called more often than wpa_auth_ensure_group for VLAN ID %d, skipping.",
[K		< 			   vlan_id);
[K		< 		return -1;
[K		< 	}
[K		< 	group->num_setup_iface--;
[K		<
[K		< 	if (group->wpa_group_state == WPA_GROUP_FATAL_FAILURE)
[K		< 		ret = -1;
[K		<
[K		< 	if (group->references > 1) {
[K		< 		wpa_printf(MSG_DEBUG,
[K		< 			   "WPA: Cannot stop group state machine for VLAN ID %d as references are still hold",
[K		< 			   vlan_id);
[K		< 		ret = -2;
[K		< 	}
[K		<
[K		< 	wpa_group_put(wpa_auth, group);
[K		<
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< int wpa_auth_sta_set_vlan(struct wpa_state_machine *sm, int vlan_id)
[K		< {
[K		< 	struct wpa_group *group;
[K		<
[K		< 	if (sm == NULL || sm->wpa_auth == NULL)
[K		< 		return 0;
[K		<
[K		< 	group = sm->wpa_auth->group;
[K		< 	while (group) {
[K		< 		if (group->vlan_id == vlan_id)
[K		< 			break;
[K		< 		group = group->next;
[K		< 	}
[K		<
[K		< 	if (group == NULL) {
[K		< 		group = wpa_auth_add_group(sm->wpa_auth, vlan_id);
[K		< 		if (group == NULL)
[K		< 			return -1;
[K		< 	}
[K		<
[K		< 	if (sm->group == group)
[K		< 		return 0;
[K		<
[K		< 	if (group->wpa_group_state == WPA_GROUP_FATAL_FAILURE)
[K		< 		return -1;
[K		<
[K		< 	wpa_printf(MSG_DEBUG, "WPA: Moving STA " MACSTR " to use group state "
[K		< 		   "machine for VLAN ID %d", MAC2STR(sm->addr), vlan_id);
[K		<
[K		< 	wpa_group_get(sm->wpa_auth, group);
[K		< 	wpa_group_put(sm->wpa_auth, sm->group);
[K		< 	sm->group = group;
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< void wpa_auth_eapol_key_tx_status(struct wpa_authenticator *wpa_auth,
[K		< 				  struct wpa_state_machine *sm, int ack)
[K		< {
[K		< 	if (wpa_auth == NULL || sm == NULL)
[K		< 		return;
[K		< 	wpa_printf(MSG_DEBUG, "WPA: EAPOL-Key TX status for STA " MACSTR
[K		< 		   " ack=%d", MAC2STR(sm->addr), ack);
[K		< 	if (sm->pending_1_of_4_timeout && ack) {
[K		< 		/*
[K		< 		 * Some deployed supplicant implementations update their SNonce
[K		< 		 * for each EAPOL-Key 2/4 message even within the same 4-way
[K		< 		 * handshake and then fail to use the first SNonce when
[K		< 		 * deriving the PTK. This results in unsuccessful 4-way
[K		< 		 * handshake whenever the relatively short initial timeout is
[K		< 		 * reached and EAPOL-Key 1/4 is retransmitted. Try to work
[K		< 		 * around this by increasing the timeout now that we know that
[K		< 		 * the station has received the frame.
[K		< 		 */
[K		< 		int timeout_ms = eapol_key_timeout_subseq;
[K		< 		wpa_printf(MSG_DEBUG, "WPA: Increase initial EAPOL-Key 1/4 "
[K		< 			   "timeout by %u ms because of acknowledged frame",
[K		< 			   timeout_ms);
[K		< 		eloop_cancel_timeout(wpa_send_eapol_timeout, wpa_auth, sm);
[K		< 		eloop_register_timeout(timeout_ms / 1000,
[K		< 				       (timeout_ms % 1000) * 1000,
[K		< 				       wpa_send_eapol_timeout, wpa_auth, sm);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< int wpa_auth_uses_sae(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return 0;
[K		< 	return wpa_key_mgmt_sae(sm->wpa_key_mgmt);
[K		< }
[K		<
[K		<
[K		< int wpa_auth_uses_ft_sae(struct wpa_state_machine *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return 0;
[K		< 	return sm->wpa_key_mgmt == WPA_KEY_MGMT_FT_SAE;
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_P2P
[K		< int wpa_auth_get_ip_addr(struct wpa_state_machine *sm, u8 *addr)
[K		< {
[K		< 	if (sm == NULL || WPA_GET_BE32(sm->ip_addr) == 0)
[K		< 		return -1;
[K		< 	os_memcpy(addr, sm->ip_addr, 4);
[K		< 	return 0;
[K		< }
[K		< #endif /* CONFIG_P2P */
[K		<
[K		<
[K		< int wpa_auth_radius_das_disconnect_pmksa(struct wpa_authenticator *wpa_auth,
[K		< 					 struct radius_das_attrs *attr)
[K		< {
[K		< 	return pmksa_cache_auth_radius_das_disconnect(wpa_auth->pmksa, attr);
[K		< }
[K		<
[K		<
[K		< void wpa_auth_reconfig_group_keys(struct wpa_authenticator *wpa_auth)
[K		< {
[K		< 	struct wpa_group *group;
[K		<
[K		< 	if (!wpa_auth)
[K		< 		return;
[K		< 	for (group = wpa_auth->group; group; group = group->next)
[K		< 		wpa_group_config_group_keys(wpa_auth, group);
[K		< }
[K
	Successful transformation
[K
		/hostap/CVE-2017-13077_Android/Android/src/ap/ieee802_11.c
		------------------------------------------------------------------------------------------

[K	Original AST script
[K			AST Script:
[K				 Insert EnumConstantDecl(21538) EnumDecl(21528) 9
[K				 Insert FunctionDecl(21629) TranslationUnitDecl(0) 1159
[K				 Insert TypeLoc(21630) FunctionDecl(21629) 0
[K				 Insert TypeLoc(21631) TypeLoc(21630) 0
[K				 Insert ParmVarDecl(21632) TypeLoc(21630) 1
[K				 Insert TypeLoc(21633) ParmVarDecl(21632) 0
[K				 Insert TypeLoc(21634) TypeLoc(21633) 0
[K				 Insert TypeLoc(21635) TypeLoc(21634) 0
[K				 Insert DeclStmt(29104) CompoundStmt(29095) 2
[K				 Insert VarDecl(29105) DeclStmt(29104) 0
[K				 Insert TypeLoc(29106) VarDecl(29105) 0
[K				 Insert IntegerLiteral(29107) VarDecl(29105) 1
[K				 Insert BinaryOperator(29109) IfStmt(29108) 0
[K				 Move UnaryOperator(29110) BinaryOperator(29109) 0
[K				 Insert ParenExpr(29113) BinaryOperator(29109) 1
[K				 Insert BinaryOperator(29114) ParenExpr(29113) 0
[K				 Insert UnaryOperator(29115) BinaryOperator(29114) 0
[K				 Insert ParenExpr(29116) UnaryOperator(29115) 0
[K				 Insert BinaryOperator(29117) ParenExpr(29116) 0
[K				 Insert MemberExpr(29118) BinaryOperator(29117) 0
[K				 Insert DeclRefExpr(29119) MemberExpr(29118) 0
[K				 Insert Macro(29120) BinaryOperator(29117) 1
[K				 Insert UnaryOperator(29121) BinaryOperator(29114) 1
[K				 Insert CallExpr(29122) UnaryOperator(29121) 0
[K				 Insert DeclRefExpr(29123) CallExpr(29122) 0
[K				 Insert MemberExpr(29124) CallExpr(29122) 1
[K				 Insert DeclRefExpr(29125) MemberExpr(29124) 0
[K				 Insert CompoundStmt(29126) IfStmt(29108) 1
[K				 Move CallExpr(29127) CompoundStmt(29126) 0
[K				 Insert CallExpr(29132) CompoundStmt(29126) 1
[K				 Insert DeclRefExpr(29133) CallExpr(29132) 0
[K				 Insert MemberExpr(29134) CallExpr(29132) 1
[K				 Insert DeclRefExpr(29135) MemberExpr(29134) 0
[K				 Insert DeclRefExpr(29136) CallExpr(29132) 2
[K				 Insert BinaryOperator(29137) CompoundStmt(29126) 2
[K				 Insert DeclRefExpr(29138) BinaryOperator(29137) 0
[K				 Insert IntegerLiteral(29139) BinaryOperator(29137) 1
[K				 Update DeclRefExpr(29151) DeclRefExpr(29185)
[K				 Update DeclRefExpr(29163) DeclRefExpr(29196)
[K				 Delete MemberExpr(29150)
[K				 Delete MemberExpr(29162)
[K	Generated AST script
[K			AST Script:
[K				 Delete MemberExpr(28138)
[K				 Delete MemberExpr(28126)
[K				 Delete CallExpr(28076)
[K				 Delete UnaryOperator(28073)
[K				 Insert EnumConstantDecl(21538) into EnumDecl(21043) at 9
[K				 Insert FunctionDecl(21629) into TranslationUnitDecl(0) at 1133
[K				 Insert DeclStmt(29104) into CompoundStmt(28063) at 2
[K				 Insert BinaryOperator(29109) into IfStmt(28072) at 0
[K				 Insert CompoundStmt(29126) into IfStmt(28072) at 1
[K				 Update DeclRefExpr(28127) to DeclRefExpr(29185)
[K				 Update DeclRefExpr(28139) to DeclRefExpr(29196)
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/ieee802_11.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/ieee802_11.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/ieee802_11.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/ieee802_11.c
[K					extracting macro definitions
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/ieee802_11.c
[K	Original Patch
[K		2632a2633
[K		> 	int set = 1;
[K		2639a2641,2644
[K		> 	 *
[K		> 	 * Skip this if the STA has already completed FT reassociation and the
[K		> 	 * TK has been configured since the TX/RX PN must not be reset to 0 for
[K		> 	 * the same key.
[K		2641c2646,2648
[K		< 	if (!sta->added_unassoc)
[K		---
[K		> 	if (!sta->added_unassoc &&
[K		> 	    (!(sta->flags & WLAN_STA_AUTHORIZED) ||
[K		> 	     !wpa_auth_sta_ft_tk_already_set(sta->wpa_sm))) {
[K		2642a2650,2652
[K		> 		wpa_auth_sm_event(sta->wpa_sm, WPA_DRV_STA_REMOVED);
[K		> 		set = 0;
[K		> 	}
[K		2665c2675
[K		< 			    sta->added_unassoc)) {
[K		---
[K		> 			    set)) {
[K		2669c2679
[K		< 			       sta->added_unassoc ? "set" : "add");
[K		---
[K		> 			       set ? "set" : "add");
[K	Generated Patch
[K		2211a2212,2213
[K		>  int set = 1;
[K		>
[K		2220c2222,2224
[K		< 	if (!sta->added_unassoc)
[K		---
[K		> 	if ( !sta->added_unassoc &&
[K		> 	    (!(sta->flags & WLAN_STA_AUTHORIZED) ||
[K		> 	     !wpa_auth_sta_ft_tk_already_set(sta->wpa_sm))  {
[K		2221a2226,2229
[K		> 		wpa_auth_sm_event(sta->wpa_sm, WPA_DRV_STA_REMOVED);
[K		> 		set = 0;
[K		> 	}
[K		> 		;
[K		2243,2244c2251
[K		< 			    sta->vht_opmode, sta->p2p_ie ? 1 : 0,
[K		< 			    sta->added_unassoc)) {
[K		---
[K		> 			    sta->vht_opmode, sset>p2p_ie ? 1 : 0)) {
[K		2248c2255
[K		< 			       sta->added_unassoc ? "set" : "add");
[K		---
[K		> 			       set->added_unassoc ? "set" : "add");
[K
	Successful transformation
[K
		/hostap/CVE-2017-13077_Android/Android/src/ap/wpa_auth_ft.c
		------------------------------------------------------------------------------------------

[K	Original AST script
[K			AST Script:
[K				 Insert EnumConstantDecl(11449) EnumDecl(11439) 9
[K				 Insert FunctionDecl(11540) TranslationUnitDecl(0) 696
[K				 Insert TypeLoc(11541) FunctionDecl(11540) 0
[K				 Insert TypeLoc(11542) TypeLoc(11541) 0
[K				 Insert ParmVarDecl(11543) TypeLoc(11541) 1
[K				 Insert TypeLoc(11544) ParmVarDecl(11543) 0
[K				 Insert TypeLoc(11545) TypeLoc(11544) 0
[K				 Insert TypeLoc(11546) TypeLoc(11545) 0
[K				 Insert FieldDecl(12326) RecordDecl(12225) 31
[K				 Insert TypeLoc(12327) FieldDecl(12326) 0
[K				 Insert IfStmt(18913) CompoundStmt(18879) 5
[K				 Insert MemberExpr(18914) IfStmt(18913) 0
[K				 Insert DeclRefExpr(18915) MemberExpr(18914) 0
[K				 Insert CompoundStmt(18916) IfStmt(18913) 1
[K				 Insert CallExpr(18917) CompoundStmt(18916) 0
[K				 Insert DeclRefExpr(18918) CallExpr(18917) 0
[K				 Insert DeclRefExpr(18919) CallExpr(18917) 1
[K				 Insert StringLiteral(18920) CallExpr(18917) 2
[K				 Insert ReturnStmt(18921) CompoundStmt(18916) 1
[K				 Insert BinaryOperator(18941) CompoundStmt(18879) 8
[K				 Insert MemberExpr(18942) BinaryOperator(18941) 0
[K				 Insert DeclRefExpr(18943) MemberExpr(18942) 0
[K				 Insert DeclRefExpr(18944) BinaryOperator(18941) 1
[K				 Insert BinaryOperator(19582) CompoundStmt(19226) 40
[K				 Insert MemberExpr(19583) BinaryOperator(19582) 0
[K				 Insert DeclRefExpr(19584) MemberExpr(19583) 0
[K				 Insert DeclRefExpr(19585) BinaryOperator(19582) 1
[K	Generated AST script
[K			AST Script:
[K				 Insert EnumConstantDecl(11449) into EnumDecl(11250) at 9
[K				 Insert FunctionDecl(11540) into TranslationUnitDecl(0) at 683
[K				 Insert FieldDecl(12326) into RecordDecl(11848) at 30
[K				 Insert IfStmt(18913) into CompoundStmt(14944) at 5
[K				 Insert BinaryOperator(18941) into CompoundStmt(14944) at 7
[K				 Insert BinaryOperator(19582) into CompoundStmt(15278) at 40
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth_ft.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth_ft.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth_ft.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth_ft.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth_ft.c
[K				identifying missing function calls
[K				identifying missing macros
[K		extracting macro definitions from
		/hostap/CVE-2017-13077_Android/Android/src-patch/ap/wpa_auth_ft.c
[K	Original Patch
[K		1939a1940,1947
[K		> 	if (sm->tk_already_set) {
[K		> 		/* Must avoid TK reconfiguration to prevent clearing of TX/RX
[K		> 		 * PN in the driver */
[K		> 		wpa_printf(MSG_DEBUG,
[K		> 			   "FT: Do not re-install same PTK to the driver");
[K		> 		return;
[K		> 	}
[K		>
[K		1951a1960
[K		> 	sm->tk_already_set = TRUE;
[K		2154a2164
[K		> 	sm->tk_already_set = FALSE;
[K	Generated Patch
[K		798a799,806
[K		>  if (sm->keycount) {
[K		> 		/* Must avoid TK reconfiguration to prevent clearing of TX/RX
[K		> 		 * PN in the driver */
[K		> 		wpa_printf(MSG_DEBUG,
[K		> 			   "FT: Do not re-install same PTK to the driver");
[K		> 		return;
[K		> 	}
[K		>
[K		811a820,821
[K		>  sm->keycount = TRUE;
[K		>
[K		1008a1019,1020
[K		>  sm->keycount = FALSE;
[K		>
[K
	Successful transformation
[K
	Successful transplanting code, after 34.42632508277893 seconds.
[K
	Starting transplanting functions...
	__________________________________________________________________________________________

[K		-none-
[K
	Successful transplanting functions, after 0.00043845176696777344 seconds.
[K
	Starting transplanting data structures...
	__________________________________________________________________________________________

[K		-none-
[K
	Successful transplanting data structures, after 0.00020956993103027344 seconds.
[K
	Starting transplanting macros...
	__________________________________________________________________________________________

[K		-none-
[K
	Successful transplanting macros, after 0.00021600723266601562 seconds.
[K
	Starting transplanting header files...
	__________________________________________________________________________________________

[K		-none-
[K
	Successful transplanting header files, after 0.000217437744140625 seconds.
[K
	Starting correcting syntax errors...
	__________________________________________________________________________________________

[K
		computing syntax errors
		------------------------------------------------------------------------------------------

[K
	Successful correcting syntax errors, after 0.00028061866760253906 seconds.
[K
====================================================================================================

	Patch Verification
====================================================================================================

[K
	verifying compilation...
	__________________________________________________________________________________________

[K
		building projects
		------------------------------------------------------------------------------------------

[K			/hostap/CVE-2017-13077_Android/Android/src-patch/
[K
	Successful verifying compilation, after 23.35572385787964 seconds.
[K	
Run time statistics:
-----------------------

[K	Initialization: 0.04170417785644531 seconds
[K	Build Analysis: 42.62360119819641 seconds
[K	Diff Analysis: 58.061787366867065 seconds
[K	Clone Analysis: 14.050602674484253 seconds
[K	AST Analysis: 14.050602674484253 seconds
[K	Map Generation: 24.49613642692566 seconds
[K	Translation: 7.7833168506622314 seconds
[K	Transplantation: 34.84137439727783 seconds
[K	Verification: 23.356287717819214 seconds
[K
Crochet finished successfully after 689.5416522026062 seconds

