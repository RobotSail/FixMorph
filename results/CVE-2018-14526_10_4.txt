[K	

####################################################################################################

	Crochet - Horizontal Code Edit Transfer
	Test conducted on: 17-Jan-2020 (15:14:13.429371)

####################################################################################################
[K
====================================================================================================

	Initializing project for Transfer
====================================================================================================

[K
	loading configuration
	__________________________________________________________________________________________

[K		reading configuration values
[K
	set environment
	__________________________________________________________________________________________

[K		setting environment values
[K
====================================================================================================

	Building Projects
====================================================================================================

[K
	building binaries
	__________________________________________________________________________________________

[K
		restoring projects
		------------------------------------------------------------------------------------------

[K		/hostap/CVE-2018-14526_10_4/hostap-2017/src/
[K		/hostap/CVE-2018-14526_10_4/hostap-2018/src/
[K		/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/
[K		/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src-patch/
[K
		cleaning projects
		------------------------------------------------------------------------------------------

[K		/hostap/CVE-2018-14526_10_4/hostap-2017/src/
[K		/hostap/CVE-2018-14526_10_4/hostap-2018/src/
[K		/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/
[K		/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src-patch/
[K
		configuring projects
		------------------------------------------------------------------------------------------

[K		/hostap/CVE-2018-14526_10_4/hostap-2017/src/
[K		/hostap/CVE-2018-14526_10_4/hostap-2018/src/
[K		/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/
[K		/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src-patch/
[K
		building projects
		------------------------------------------------------------------------------------------

[K		/hostap/CVE-2018-14526_10_4/hostap-2017/src/
[K		/hostap/CVE-2018-14526_10_4/hostap-2018/src/
[K		/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/
[K		/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src-patch/
[K
	Successful building binaries, after 44.36020755767822 seconds.
[K
====================================================================================================

	Analysing Changes
====================================================================================================

[K
	analysing source diff
	__________________________________________________________________________________________

[K		finding changed files...
[K
		analysing header files
		------------------------------------------------------------------------------------------

[K			extracting changed header files...
[K			header files:
[K				-none-
[K
		analysing C/CPP source files
		------------------------------------------------------------------------------------------

[K			extracting changed c/cpp files...
[K			source files:
[K				/hostap/CVE-2018-14526_10_4/hostap-2017/src/rsn_supp/wpa.c
[K
		analysing changed code segments
		------------------------------------------------------------------------------------------

[K			collecting diff info...
[K			/hostap/CVE-2018-14526_10_4/hostap-2017/src/:
[K				wpa_sm_rx_eapol in Pa/rsn_supp/wpa.c
[K				wpa_sm_rx_eapol 2013-2261[K[K			/hostap/CVE-2018-14526_10_4/hostap-2018/src/:
[K				wpa_sm_rx_eapol in Pb/rsn_supp/wpa.c
[K				wpa_sm_rx_eapol 2013-2272[K[K
	Successful analysing source diff, after 1.913931131362915 seconds.
[K
	analysing ast diff
	__________________________________________________________________________________________

[K
		/hostap/CVE-2018-14526_10_4/hostap-2017/src/rsn_supp/wpa.c
		------------------------------------------------------------------------------------------

[K		generating AST script
[K		line number:2217
[K			filtering AST script by merging and grouping
[K			merging AST script
[K
	Successful analysing ast diff, after 3.2862205505371094 seconds.
[K
====================================================================================================

	Clone Detection
====================================================================================================

[K
	generating vectors for target
	__________________________________________________________________________________________

[K
		Generating vector files for all functions in Target
		------------------------------------------------------------------------------------------

[K			generating vectors for *\.c files in Pc...
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/common/wpa_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/common/ieee802_11_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/common/wpa_ctrl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/wps/wps_registrar.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/wps/wps_upnp_web.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/wps/wps_upnp_ap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/wps/wps_upnp_ssdp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/wps/wps_upnp_event.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/wps/wps_validate.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/wps/wps_upnp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/wpa_auth_glue.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/ieee802_11.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/ctrl_iface_ap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/ieee802_11_shared.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/preauth_auth.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/wmm.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/ieee802_11_ht.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/pmksa_cache_auth.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/hw_features.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/vlan_util.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/wpa_auth_ft.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/p2p_hostapd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/wnm_ap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/vlan_init.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/wpa_auth.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/sta_info.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/ieee802_1x.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/ieee802_11_auth.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/wpa_auth_ie.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/eap_user_db.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/hs20.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/hostapd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/gas_serv.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/drv_callbacks.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/tkip_countermeasures.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/iapp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/peerkey_auth.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/ieee802_11_vht.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/utils.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/ap/wps_hostapd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/l2_packet/l2_packet_freebsd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/l2_packet/l2_packet_privsep.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/l2_packet/l2_packet_ndis.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/l2_packet/l2_packet_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_otp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_sim.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_md5.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_pax.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_ikev2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_tnc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_gpsk.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_aka.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_fast_pac.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_pwd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_mschapv2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_psk.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_tls_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_fast.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/tncc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/ikev2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_ttls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_leap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_sake.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_gtc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_peap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_wsc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/eap_tls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_peer/mschapv2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/tls_openssl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/tls_schannel.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/sha256-internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/fips_prf_cryptoapi.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/crypto_internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/crypto_internal-cipher.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/tls_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/crypto_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/fips_prf_openssl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/fips_prf_internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/crypto_gnutls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/sha256.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/crypto_internal-modexp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/tls_gnutls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/sha256-tlsprf.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/md5-internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/sha1.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/md5.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/fips_prf_gnutls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/des-internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/md4-internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/sha256-prf.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/crypto_openssl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/dh_group5.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/crypto_libtomcrypt.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/aes-unwrap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/tls_nss.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/dh_groups.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/sha1-internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/fips_prf_nss.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/ms_funcs.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/random.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/crypto_nss.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/crypto_internal-rsa.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/sha1-pbkdf2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/sha1-tlsprf.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/milenage.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/tls_internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/sha1-prf.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/crypto_cryptoapi.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/sha1-tprf.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/rc4.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/crypto/aes-wrap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/tls/x509v3.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/tls/tlsv1_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/tls/libtommath.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/tls/tlsv1_record.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/tls/tlsv1_server_read.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/tls/tlsv1_server.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/tls/tlsv1_cred.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/tls/tlsv1_server_write.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_common/eap_pwd_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_common/eap_ikev2_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_common/eap_peap_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_common/eap_pax_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_common/eap_sake_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_common/eap_sim_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_common/eap_gpsk_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_common/eap_wsc_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_common/ikev2_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_common/eap_fast_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/eap_common/eap_psk_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/os_win32.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/ext_password.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/os_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/eloop_win.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/wpabuf.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/edit_simple.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/pcsc_funcs.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/os_internal.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/eloop_none.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/os_unix.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/uuid.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/edit_readline.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/edit.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/eloop.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/trace.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/ip_addr.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/wpa_debug.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/utils/radiotap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/rsn_supp/peerkey.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/drivers/driver_privsep.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/drivers/driver_ndis.c
[K				Failed parsing AST for file:
			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/drivers/driv/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_monitor.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_android.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_event.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_hostap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_privsep.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/linux_ioctl.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_wext.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_ndis.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_bsd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/drivers.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_wired.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_atheros.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/ndis_events.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/netlink.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_nl80211.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_openbsd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_roboswitch.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_macsec_qca.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_capa.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/rfkill.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_nl80211_scan.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/drivers/driver_ndis_.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_wsc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_gpsk.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_gtc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_eke.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_mschapv2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_tls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_pax.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_tls_common.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_md5.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_ikev2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_fast.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_peap.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_sake.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_ttls.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_sim.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_tnc.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_aka.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_psk.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/tncs.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/ikev2.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_sim_db.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/eap_server/eap_server_pwd.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/pae/ieee802_1x_cp.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/pae/ieee802_1x_kay.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/pae/ieee802_1x_key.c
[K				Failed parsing AST for file:
			/hostap/CVE-2017-13077_11_1/FreeBSD-11.1/src/pae/ieee802_1x_secy_ops.c
[K
	Successful generating vectors for target, after 163.44727635383606 seconds.
[K
	finding clones in target
	__________________________________________________________________________________________

[K
		Finding clone functions in Target
		------------------------------------------------------------------------------------------

[K		checking vectors for C files in Pa...
[K		checking vectors for C files in Pc...
[K		finding clones for edited functions:

[K			Finding match for wpa_sm_rx_eapol in $Pa/rsn_supp/wpa.c:
[K			Function: wpa_sm_rx_eapol in $Pc/rsn_supp/wpa.c
[K			Distance: 0.0006022436733177349

[K
	Successful finding clones in target, after 13.418797254562378 seconds.
[K
====================================================================================================

	Generating GumTree script for patch
====================================================================================================

[K
	Starting generating script for C files...
	__________________________________________________________________________________________

[K	Generating edit script: wpa.c to wpa.c...
[K
	Successful generating script for C files, after 1.8354296684265137 seconds.
[K
====================================================================================================

	Variable Mapping
====================================================================================================

[K
	Variable mapping for C files
	__________________________________________________________________________________________

[K	Generating mapping: wpa.c to wpa.c...
[K
====================================================================================================

	Translate GumTree Script
====================================================================================================

[K
	Translating scripts for C files
	__________________________________________________________________________________________

[K	Generating JSON temp files for each pertinent file...
[K			Clang AST parse /hostap/CVE-2018-14526_10_4/hostap-2017/src/rsn_supp/wpa.c in Pa...
[K			Clang AST parse /hostap/CVE-2018-14526_10_4/hostap-2018/src/rsn_supp/wpa.c in Pb...
[K			Clang AST parse /hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/rsn_supp/wpa.c in Pc...
[K
====================================================================================================

	Applying transformation
====================================================================================================

[K
	Starting transplanting code...
	__________________________________________________________________________________________

[K
		/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src/rsn_supp/wpa.c
		------------------------------------------------------------------------------------------

[K	Original AST script
[K			AST Script:
[K				 Insert IfStmt(17148) CompoundStmt(17147) 0
[K				 Insert UnaryOperator(17149) IfStmt(17148) 0
[K				 Insert ParenExpr(17150) UnaryOperator(17149) 0
[K				 Insert BinaryOperator(17151) ParenExpr(17150) 0
[K				 Insert DeclRefExpr(17152) BinaryOperator(17151) 0
[K				 Insert Macro(17153) BinaryOperator(17151) 1
[K				 Insert CompoundStmt(17154) IfStmt(17148) 1
[K				 Insert CallExpr(17155) CompoundStmt(17154) 0
[K				 Insert DeclRefExpr(17156) CallExpr(17155) 0
[K				 Insert MemberExpr(17157) CallExpr(17155) 1
[K				 Insert MemberExpr(17158) MemberExpr(17157) 0
[K				 Insert DeclRefExpr(17159) MemberExpr(17158) 0
[K				 Insert DeclRefExpr(17160) CallExpr(17155) 2
[K				 Insert StringLiteral(17161) CallExpr(17155) 3
[K				 Insert GotoStmt(17162) CompoundStmt(17154) 1
[K	Generated AST script
[K			AST Script:
[K	Original Patch
[K		2217a2218,2228
[K		> 		/*
[K		> 		 * Only decrypt the Key Data field if the frame's authenticity
[K		> 		 * was verified. When using AES-SIV (FILS), the MIC flag is not
[K		> 		 * set, so this check should only be performed if mic_len != 0
[K		> 		 * which is the case in this code branch.
[K		> 		 */
[K		> 		if (!(key_info & WPA_KEY_INFO_MIC)) {
[K		> 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		> 				"WPA: Ignore EAPOL-Key with encrypted but unauthenticated data");
[K		> 			goto out;
[K		> 		}
[K	Generated Patch
[K		1,2771d0
[K		< /*
[K		<  * WPA Supplicant - WPA state machine and EAPOL-Key processing
[K		<  * Copyright (c) 2003-2012, Jouni Malinen <j@w1.fi>
[K		<  *
[K		<  * This software may be distributed under the terms of the BSD license.
[K		<  * See README for more details.
[K		<  */
[K		<
[K		< #include "includes.h"
[K		<
[K		< #include "common.h"
[K		< #include "crypto/aes_wrap.h"
[K		< #include "crypto/crypto.h"
[K		< #include "crypto/random.h"
[K		< #include "common/ieee802_11_defs.h"
[K		< #include "eapol_supp/eapol_supp_sm.h"
[K		< #include "wpa.h"
[K		< #include "eloop.h"
[K		< #include "preauth.h"
[K		< #include "pmksa_cache.h"
[K		< #include "wpa_i.h"
[K		< #include "wpa_ie.h"
[K		< #include "peerkey.h"
[K		<
[K		<
[K		< /**
[K		<  * wpa_eapol_key_send - Send WPA/RSN EAPOL-Key message
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @kck: Key Confirmation Key (KCK, part of PTK)
[K		<  * @ver: Version field from Key Info
[K		<  * @dest: Destination address for the frame
[K		<  * @proto: Ethertype (usually ETH_P_EAPOL)
[K		<  * @msg: EAPOL-Key message
[K		<  * @msg_len: Length of message
[K		<  * @key_mic: Pointer to the buffer to which the EAPOL-Key MIC is written
[K		<  */
[K		< void wpa_eapol_key_send(struct wpa_sm *sm, const u8 *kck,
[K		< 			int ver, const u8 *dest, u16 proto,
[K		< 			u8 *msg, size_t msg_len, u8 *key_mic)
[K		< {
[K		< 	if (is_zero_ether_addr(dest) && is_zero_ether_addr(sm->bssid)) {
[K		< 		/*
[K		< 		 * Association event was not yet received; try to fetch
[K		< 		 * BSSID from the driver.
[K		< 		 */
[K		< 		if (wpa_sm_get_bssid(sm, sm->bssid) < 0) {
[K		< 			wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 				"WPA: Failed to read BSSID for "
[K		< 				"EAPOL-Key destination address");
[K		< 		} else {
[K		< 			dest = sm->bssid;
[K		< 			wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 				"WPA: Use BSSID (" MACSTR
[K		< 				") as the destination for EAPOL-Key",
[K		< 				MAC2STR(dest));
[K		< 		}
[K		< 	}
[K		< 	if (key_mic &&
[K		< 	    wpa_eapol_key_mic(kck, ver, msg, msg_len, key_mic)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_ERROR,
[K		< 			"WPA: Failed to generate EAPOL-Key "
[K		< 			"version %d MIC", ver);
[K		< 		goto out;
[K		< 	}
[K		< 	wpa_hexdump_key(MSG_DEBUG, "WPA: KCK", kck, 16);
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: Derived Key MIC", key_mic, 16);
[K		< 	wpa_hexdump(MSG_MSGDUMP, "WPA: TX EAPOL-Key", msg, msg_len);
[K		< 	wpa_sm_ether_send(sm, dest, proto, msg, msg_len);
[K		< 	eapol_sm_notify_tx_eapol_key(sm->eapol);
[K		< out:
[K		< 	os_free(msg);
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_key_request - Send EAPOL-Key Request
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @error: Indicate whether this is an Michael MIC error report
[K		<  * @pairwise: 1 = error report for pairwise packet, 0 = for group packet
[K		<  *
[K		<  * Send an EAPOL-Key Request to the current authenticator. This function is
[K		<  * used to request rekeying and it is usually called when a local Michael MIC
[K		<  * failure is detected.
[K		<  */
[K		< void wpa_sm_key_request(struct wpa_sm *sm, int error, int pairwise)
[K		< {
[K		< 	size_t rlen;
[K		< 	struct wpa_eapol_key *reply;
[K		< 	int key_info, ver;
[K		< 	u8 bssid[ETH_ALEN], *rbuf;
[K		<
[K		< 	if (wpa_key_mgmt_ft(sm->key_mgmt) || wpa_key_mgmt_sha256(sm->key_mgmt))
[K		< 		ver = WPA_KEY_INFO_TYPE_AES_128_CMAC;
[K		< 	else if (sm->pairwise_cipher != WPA_CIPHER_TKIP)
[K		< 		ver = WPA_KEY_INFO_TYPE_HMAC_SHA1_AES;
[K		< 	else
[K		< 		ver = WPA_KEY_INFO_TYPE_HMAC_MD5_RC4;
[K		<
[K		< 	if (wpa_sm_get_bssid(sm, bssid) < 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"Failed to read BSSID for EAPOL-Key request");
[K		< 		return;
[K		< 	}
[K		<
[K		< 	rbuf = wpa_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAPOL_KEY, NULL,
[K		< 				  sizeof(*reply), &rlen, (void *) &reply);
[K		< 	if (rbuf == NULL)
[K		< 		return;
[K		<
[K		< 	reply->type = sm->proto == WPA_PROTO_RSN ?
[K		< 		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
[K		< 	key_info = WPA_KEY_INFO_REQUEST | ver;
[K		< 	if (sm->ptk_set)
[K		< 		key_info |= WPA_KEY_INFO_MIC;
[K		< 	if (error)
[K		< 		key_info |= WPA_KEY_INFO_ERROR;
[K		< 	if (pairwise)
[K		< 		key_info |= WPA_KEY_INFO_KEY_TYPE;
[K		< 	WPA_PUT_BE16(reply->key_info, key_info);
[K		< 	WPA_PUT_BE16(reply->key_length, 0);
[K		< 	os_memcpy(reply->replay_counter, sm->request_counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		< 	inc_byte_array(sm->request_counter, WPA_REPLAY_COUNTER_LEN);
[K		<
[K		< 	WPA_PUT_BE16(reply->key_data_length, 0);
[K		<
[K		< 	wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 		"WPA: Sending EAPOL-Key Request (error=%d "
[K		< 		"pairwise=%d ptk_set=%d len=%lu)",
[K		< 		error, pairwise, sm->ptk_set, (unsigned long) rlen);
[K		< 	wpa_eapol_key_send(sm, sm->ptk.kck, ver, bssid, ETH_P_EAPOL,
[K		< 			   rbuf, rlen, key_info & WPA_KEY_INFO_MIC ?
[K		< 			   reply->key_mic : NULL);
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_get_pmk(struct wpa_sm *sm,
[K		< 				  const unsigned char *src_addr,
[K		< 				  const u8 *pmkid)
[K		< {
[K		< 	int abort_cached = 0;
[K		<
[K		< 	if (pmkid && !sm->cur_pmksa) {
[K		< 		/* When using drivers that generate RSN IE, wpa_supplicant may
[K		< 		 * not have enough time to get the association information
[K		< 		 * event before receiving this 1/4 message, so try to find a
[K		< 		 * matching PMKSA cache entry here. */
[K		< 		sm->cur_pmksa = pmksa_cache_get(sm->pmksa, src_addr, pmkid,
[K		< 						NULL);
[K		< 		if (sm->cur_pmksa) {
[K		< 			wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 				"RSN: found matching PMKID from PMKSA cache");
[K		< 		} else {
[K		< 			wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 				"RSN: no matching PMKID found");
[K		< 			abort_cached = 1;
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (pmkid && sm->cur_pmksa &&
[K		< 	    os_memcmp(pmkid, sm->cur_pmksa->pmkid, PMKID_LEN) == 0) {
[K		< 		wpa_hexdump(MSG_DEBUG, "RSN: matched PMKID", pmkid, PMKID_LEN);
[K		< 		wpa_sm_set_pmk_from_pmksa(sm);
[K		< 		wpa_hexdump_key(MSG_DEBUG, "RSN: PMK from PMKSA cache",
[K		< 				sm->pmk, sm->pmk_len);
[K		< 		eapol_sm_notify_cached(sm->eapol);
[K		< #ifdef CONFIG_IEEE80211R
[K		< 		sm->xxkey_len = 0;
[K		< #endif /* CONFIG_IEEE80211R */
[K		< 	} else if (wpa_key_mgmt_wpa_ieee8021x(sm->key_mgmt) && sm->eapol) {
[K		< 		int res, pmk_len;
[K		< 		pmk_len = PMK_LEN;
[K		< 		res = eapol_sm_get_key(sm->eapol, sm->pmk, PMK_LEN);
[K		< 		if (res) {
[K		< 			/*
[K		< 			 * EAP-LEAP is an exception from other EAP methods: it
[K		< 			 * uses only 16-byte PMK.
[K		< 			 */
[K		< 			res = eapol_sm_get_key(sm->eapol, sm->pmk, 16);
[K		< 			pmk_len = 16;
[K		< 		} else {
[K		< #ifdef CONFIG_IEEE80211R
[K		< 			u8 buf[2 * PMK_LEN];
[K		< 			if (eapol_sm_get_key(sm->eapol, buf, 2 * PMK_LEN) == 0)
[K		< 			{
[K		< 				os_memcpy(sm->xxkey, buf + PMK_LEN, PMK_LEN);
[K		< 				sm->xxkey_len = PMK_LEN;
[K		< 				os_memset(buf, 0, sizeof(buf));
[K		< 			}
[K		< #endif /* CONFIG_IEEE80211R */
[K		< 		}
[K		< 		if (res == 0) {
[K		< 			struct rsn_pmksa_cache_entry *sa = NULL;
[K		< 			wpa_hexdump_key(MSG_DEBUG, "WPA: PMK from EAPOL state "
[K		< 					"machines", sm->pmk, pmk_len);
[K		< 			sm->pmk_len = pmk_len;
[K		< 			if (sm->proto == WPA_PROTO_RSN &&
[K		< 			    !wpa_key_mgmt_ft(sm->key_mgmt)) {
[K		< 				sa = pmksa_cache_add(sm->pmksa,
[K		< 						     sm->pmk, pmk_len,
[K		< 						     src_addr, sm->own_addr,
[K		< 						     sm->network_ctx,
[K		< 						     sm->key_mgmt);
[K		< 			}
[K		< 			if (!sm->cur_pmksa && pmkid &&
[K		< 			    pmksa_cache_get(sm->pmksa, src_addr, pmkid, NULL))
[K		< 			{
[K		< 				wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 					"RSN: the new PMK matches with the "
[K		< 					"PMKID");
[K		< 				abort_cached = 0;
[K		< 			}
[K		<
[K		< 			if (!sm->cur_pmksa)
[K		< 				sm->cur_pmksa = sa;
[K		< 		} else {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Failed to get master session key from "
[K		< 				"EAPOL state machines - key handshake "
[K		< 				"aborted");
[K		< 			if (sm->cur_pmksa) {
[K		< 				wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 					"RSN: Cancelled PMKSA caching "
[K		< 					"attempt");
[K		< 				sm->cur_pmksa = NULL;
[K		< 				abort_cached = 1;
[K		< 			} else if (!abort_cached) {
[K		< 				return -1;
[K		< 			}
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (abort_cached && wpa_key_mgmt_wpa_ieee8021x(sm->key_mgmt) &&
[K		< 	    !wpa_key_mgmt_ft(sm->key_mgmt)) {
[K		< 		/* Send EAPOL-Start to trigger full EAP authentication. */
[K		< 		u8 *buf;
[K		< 		size_t buflen;
[K		<
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"RSN: no PMKSA entry found - trigger "
[K		< 			"full EAP authentication");
[K		< 		buf = wpa_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAPOL_START,
[K		< 					 NULL, 0, &buflen, NULL);
[K		< 		if (buf) {
[K		< 			wpa_sm_ether_send(sm, sm->bssid, ETH_P_EAPOL,
[K		< 					  buf, buflen);
[K		< 			os_free(buf);
[K		< 			return -2;
[K		< 		}
[K		<
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_supplicant_send_2_of_4 - Send message 2 of WPA/RSN 4-Way Handshake
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @dst: Destination address for the frame
[K		<  * @key: Pointer to the EAPOL-Key frame header
[K		<  * @ver: Version bits from EAPOL-Key Key Info
[K		<  * @nonce: Nonce value for the EAPOL-Key frame
[K		<  * @wpa_ie: WPA/RSN IE
[K		<  * @wpa_ie_len: Length of the WPA/RSN IE
[K		<  * @ptk: PTK to use for keyed hash and encryption
[K		<  * Returns: 0 on success, -1 on failure
[K		<  */
[K		< int wpa_supplicant_send_2_of_4(struct wpa_sm *sm, const unsigned char *dst,
[K		< 			       const struct wpa_eapol_key *key,
[K		< 			       int ver, const u8 *nonce,
[K		< 			       const u8 *wpa_ie, size_t wpa_ie_len,
[K		< 			       struct wpa_ptk *ptk)
[K		< {
[K		< 	size_t rlen;
[K		< 	struct wpa_eapol_key *reply;
[K		< 	u8 *rbuf;
[K		< 	u8 *rsn_ie_buf = NULL;
[K		<
[K		< 	if (wpa_ie == NULL) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING, "WPA: No wpa_ie set - "
[K		< 			"cannot generate msg 2/4");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	if (wpa_key_mgmt_ft(sm->key_mgmt)) {
[K		< 		int res;
[K		<
[K		< 		/*
[K		< 		 * Add PMKR1Name into RSN IE (PMKID-List) and add MDIE and
[K		< 		 * FTIE from (Re)Association Response.
[K		< 		 */
[K		< 		rsn_ie_buf = os_malloc(wpa_ie_len + 2 + 2 + PMKID_LEN +
[K		< 				       sm->assoc_resp_ies_len);
[K		< 		if (rsn_ie_buf == NULL)
[K		< 			return -1;
[K		< 		os_memcpy(rsn_ie_buf, wpa_ie, wpa_ie_len);
[K		< 		res = wpa_insert_pmkid(rsn_ie_buf, wpa_ie_len,
[K		< 				       sm->pmk_r1_name);
[K		< 		if (res < 0) {
[K		< 			os_free(rsn_ie_buf);
[K		< 			return -1;
[K		< 		}
[K		< 		wpa_ie_len += res;
[K		<
[K		< 		if (sm->assoc_resp_ies) {
[K		< 			os_memcpy(rsn_ie_buf + wpa_ie_len, sm->assoc_resp_ies,
[K		< 				  sm->assoc_resp_ies_len);
[K		< 			wpa_ie_len += sm->assoc_resp_ies_len;
[K		< 		}
[K		<
[K		< 		wpa_ie = rsn_ie_buf;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R */
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: WPA IE for msg 2/4", wpa_ie, wpa_ie_len);
[K		<
[K		< 	rbuf = wpa_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAPOL_KEY,
[K		< 				  NULL, sizeof(*reply) + wpa_ie_len,
[K		< 				  &rlen, (void *) &reply);
[K		< 	if (rbuf == NULL) {
[K		< 		os_free(rsn_ie_buf);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	reply->type = sm->proto == WPA_PROTO_RSN ?
[K		< 		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
[K		< 	WPA_PUT_BE16(reply->key_info,
[K		< 		     ver | WPA_KEY_INFO_KEY_TYPE | WPA_KEY_INFO_MIC);
[K		< 	if (sm->proto == WPA_PROTO_RSN)
[K		< 		WPA_PUT_BE16(reply->key_length, 0);
[K		< 	else
[K		< 		os_memcpy(reply->key_length, key->key_length, 2);
[K		< 	os_memcpy(reply->replay_counter, key->replay_counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: Replay Counter", reply->replay_counter,
[K		< 		    WPA_REPLAY_COUNTER_LEN);
[K		<
[K		< 	WPA_PUT_BE16(reply->key_data_length, wpa_ie_len);
[K		< 	os_memcpy(reply + 1, wpa_ie, wpa_ie_len);
[K		< 	os_free(rsn_ie_buf);
[K		<
[K		< 	os_memcpy(reply->key_nonce, nonce, WPA_NONCE_LEN);
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Sending EAPOL-Key 2/4");
[K		< 	wpa_eapol_key_send(sm, ptk->kck, ver, dst, ETH_P_EAPOL,
[K		< 			   rbuf, rlen, reply->key_mic);
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_derive_ptk(struct wpa_sm *sm, const unsigned char *src_addr,
[K		< 			  const struct wpa_eapol_key *key,
[K		< 			  struct wpa_ptk *ptk)
[K		< {
[K		< 	size_t ptk_len = sm->pairwise_cipher != WPA_CIPHER_TKIP ? 48 : 64;
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	if (wpa_key_mgmt_ft(sm->key_mgmt))
[K		< 		return wpa_derive_ptk_ft(sm, src_addr, key, ptk, ptk_len);
[K		< #endif /* CONFIG_IEEE80211R */
[K		<
[K		< 	wpa_pmk_to_ptk(sm->pmk, sm->pmk_len, "Pairwise key expansion",
[K		< 		       sm->own_addr, sm->bssid, sm->snonce, key->key_nonce,
[K		< 		       (u8 *) ptk, ptk_len,
[K		< 		       wpa_key_mgmt_sha256(sm->key_mgmt));
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_supplicant_process_1_of_4(struct wpa_sm *sm,
[K		< 					  const unsigned char *src_addr,
[K		< 					  const struct wpa_eapol_key *key,
[K		< 					  u16 ver)
[K		< {
[K		< 	struct wpa_eapol_ie_parse ie;
[K		< 	struct wpa_ptk *ptk;
[K		< 	u8 buf[8];
[K		< 	int res;
[K		<
[K		< 	if (wpa_sm_get_network_ctx(sm) == NULL) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING, "WPA: No SSID info "
[K		< 			"found (msg 1 of 4)");
[K		< 		return;
[K		< 	}
[K		<
[K		< 	wpa_sm_set_state(sm, WPA_4WAY_HANDSHAKE);
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: RX message 1 of 4-Way "
[K		< 		"Handshake from " MACSTR " (ver=%d)", MAC2STR(src_addr), ver);
[K		<
[K		< 	os_memset(&ie, 0, sizeof(ie));
[K		<
[K		< #ifndef CONFIG_NO_WPA2
[K		< 	if (sm->proto == WPA_PROTO_RSN) {
[K		< 		/* RSN: msg 1/4 should contain PMKID for the selected PMK */
[K		< 		const u8 *_buf = (const u8 *) (key + 1);
[K		< 		size_t len = WPA_GET_BE16(key->key_data_length);
[K		< 		wpa_hexdump(MSG_DEBUG, "RSN: msg 1/4 key data", _buf, len);
[K		< 		if (wpa_supplicant_parse_ies(_buf, len, &ie) < 0)
[K		< 			goto failed;
[K		< 		if (ie.pmkid) {
[K		< 			wpa_hexdump(MSG_DEBUG, "RSN: PMKID from "
[K		< 				    "Authenticator", ie.pmkid, PMKID_LEN);
[K		< 		}
[K		< 	}
[K		< #endif /* CONFIG_NO_WPA2 */
[K		<
[K		< 	res = wpa_supplicant_get_pmk(sm, src_addr, ie.pmkid);
[K		< 	if (res == -2) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "RSN: Do not reply to "
[K		< 			"msg 1/4 - requesting full EAP authentication");
[K		< 		return;
[K		< 	}
[K		< 	if (res)
[K		< 		goto failed;
[K		<
[K		< 	if (sm->renew_snonce) {
[K		< 		if (random_get_bytes(sm->snonce, WPA_NONCE_LEN)) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Failed to get random data for SNonce");
[K		< 			goto failed;
[K		< 		}
[K		< 		sm->renew_snonce = 0;
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: Renewed SNonce",
[K		< 			    sm->snonce, WPA_NONCE_LEN);
[K		< 	}
[K		<
[K		< 	/* Calculate PTK which will be stored as a temporary PTK until it has
[K		< 	 * been verified when processing message 3/4. */
[K		< 	ptk = &sm->tptk;
[K		< 	wpa_derive_ptk(sm, src_addr, key, ptk);
[K		< 	/* Supplicant: swap tx/rx Mic keys */
[K		< 	os_memcpy(buf, ptk->u.auth.tx_mic_key, 8);
[K		< 	os_memcpy(ptk->u.auth.tx_mic_key, ptk->u.auth.rx_mic_key, 8);
[K		< 	os_memcpy(ptk->u.auth.rx_mic_key, buf, 8);
[K		< 	sm->tptk_set = 1;
[K		<
[K		< 	if (wpa_supplicant_send_2_of_4(sm, sm->bssid, key, ver, sm->snonce,
[K		< 				       sm->assoc_wpa_ie, sm->assoc_wpa_ie_len,
[K		< 				       ptk))
[K		< 		goto failed;
[K		<
[K		< 	os_memcpy(sm->anonce, key->key_nonce, WPA_NONCE_LEN);
[K		< 	return;
[K		<
[K		< failed:
[K		< 	wpa_sm_deauthenticate(sm, WLAN_REASON_UNSPECIFIED);
[K		< }
[K		<
[K		<
[K		< static void wpa_sm_start_preauth(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_sm *sm = eloop_ctx;
[K		< 	rsn_preauth_candidate_process(sm);
[K		< }
[K		<
[K		<
[K		< static void wpa_supplicant_key_neg_complete(struct wpa_sm *sm,
[K		< 					    const u8 *addr, int secure)
[K		< {
[K		< 	wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 		"WPA: Key negotiation completed with "
[K		< 		MACSTR " [PTK=%s GTK=%s]", MAC2STR(addr),
[K		< 		wpa_cipher_txt(sm->pairwise_cipher),
[K		< 		wpa_cipher_txt(sm->group_cipher));
[K		< 	wpa_sm_cancel_auth_timeout(sm);
[K		< 	wpa_sm_set_state(sm, WPA_COMPLETED);
[K		<
[K		< 	if (secure) {
[K		< 		wpa_sm_mlme_setprotection(
[K		< 			sm, addr, MLME_SETPROTECTION_PROTECT_TYPE_RX_TX,
[K		< 			MLME_SETPROTECTION_KEY_TYPE_PAIRWISE);
[K		< 		eapol_sm_notify_portValid(sm->eapol, TRUE);
[K		< 		if (wpa_key_mgmt_wpa_psk(sm->key_mgmt))
[K		< 			eapol_sm_notify_eap_success(sm->eapol, TRUE);
[K		< 		/*
[K		< 		 * Start preauthentication after a short wait to avoid a
[K		< 		 * possible race condition between the data receive and key
[K		< 		 * configuration after the 4-Way Handshake. This increases the
[K		< 		 * likelihood of the first preauth EAPOL-Start frame getting to
[K		< 		 * the target AP.
[K		< 		 */
[K		< 		eloop_register_timeout(1, 0, wpa_sm_start_preauth, sm, NULL);
[K		< 	}
[K		<
[K		< 	if (sm->cur_pmksa && sm->cur_pmksa->opportunistic) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"RSN: Authenticator accepted "
[K		< 			"opportunistic PMKSA entry - marking it valid");
[K		< 		sm->cur_pmksa->opportunistic = 0;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	if (wpa_key_mgmt_ft(sm->key_mgmt)) {
[K		< 		/* Prepare for the next transition */
[K		< 		wpa_ft_prepare_auth_request(sm, NULL);
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R */
[K		< }
[K		<
[K		<
[K		< static void wpa_sm_rekey_ptk(void *eloop_ctx, void *timeout_ctx)
[K		< {
[K		< 	struct wpa_sm *sm = eloop_ctx;
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Request PTK rekeying");
[K		< 	wpa_sm_key_request(sm, 0, 1);
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_install_ptk(struct wpa_sm *sm,
[K		< 				      const struct wpa_eapol_key *key)
[K		< {
[K		< 	int keylen, rsclen;
[K		< 	enum wpa_alg alg;
[K		< 	const u8 *key_rsc;
[K		< 	u8 null_rsc[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
[K		<
[K		< 	if (sm->ptk_installed) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: Do not re-install same PTK to the driver");
[K		< 		return 0;
[K		< 	}
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 		"WPA: Installing PTK to the driver");
[K		<
[K		< 	if (sm->pairwise_cipher == WPA_CIPHER_NONE) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Pairwise Cipher "
[K		< 			"Suite: NONE - do not use pairwise keys");
[K		< 		return 0;
[K		< 	}
[K		<
[K		< 	if (!wpa_cipher_valid_pairwise(sm->pairwise_cipher)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Unsupported pairwise cipher %d",
[K		< 			sm->pairwise_cipher);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	alg = wpa_cipher_to_alg(sm->pairwise_cipher);
[K		< 	keylen = wpa_cipher_key_len(sm->pairwise_cipher);
[K		< 	rsclen = wpa_cipher_rsc_len(sm->pairwise_cipher);
[K		<
[K		< 	if (sm->proto == WPA_PROTO_RSN) {
[K		< 		key_rsc = null_rsc;
[K		< 	} else {
[K		< 		key_rsc = key->key_rsc;
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: RSC", key_rsc, rsclen);
[K		< 	}
[K		<
[K		< 	if (wpa_sm_set_key(sm, alg, sm->bssid, 0, 1, key_rsc, rsclen,
[K		< 			   (u8 *) sm->ptk.tk1, keylen) < 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Failed to set PTK to the "
[K		< 			"driver (alg=%d keylen=%d bssid=" MACSTR ")",
[K		< 			alg, keylen, MAC2STR(sm->bssid));
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	sm->ptk_installed = 1;
[K		<
[K		< 	if (sm->wpa_ptk_rekey) {
[K		< 		eloop_cancel_timeout(wpa_sm_rekey_ptk, sm, NULL);
[K		< 		eloop_register_timeout(sm->wpa_ptk_rekey, 0, wpa_sm_rekey_ptk,
[K		< 				       sm, NULL);
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_check_group_cipher(struct wpa_sm *sm,
[K		< 					     int group_cipher,
[K		< 					     int keylen, int maxkeylen,
[K		< 					     int *key_rsc_len,
[K		< 					     enum wpa_alg *alg)
[K		< {
[K		< 	int klen;
[K		<
[K		< 	*alg = wpa_cipher_to_alg(group_cipher);
[K		< 	if (*alg == WPA_ALG_NONE) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Unsupported Group Cipher %d",
[K		< 			group_cipher);
[K		< 		return -1;
[K		< 	}
[K		< 	*key_rsc_len = wpa_cipher_rsc_len(group_cipher);
[K		<
[K		< 	klen = wpa_cipher_key_len(group_cipher);
[K		< 	if (keylen != klen || maxkeylen < klen) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Unsupported %s Group Cipher key length %d (%d)",
[K		< 			wpa_cipher_txt(group_cipher), keylen, maxkeylen);
[K		< 		return -1;
[K		< 	}
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< struct wpa_gtk_data {
[K		< 	enum wpa_alg alg;
[K		< 	int tx, key_rsc_len, keyidx;
[K		< 	u8 gtk[32];
[K		< 	int gtk_len;
[K		< };
[K		<
[K		<
[K		< static int wpa_supplicant_install_gtk(struct wpa_sm *sm,
[K		< 				      const struct wpa_gtk_data *gd,
[K		< 				      const u8 *key_rsc, int wnm_sleep)
[K		< {
[K		< 	const u8 *_gtk = gd->gtk;
[K		< 	u8 gtk_buf[32];
[K		<
[K		< 	/* Detect possible key reinstallation */
[K		< 	if ((sm->gtk.gtk_len == (size_t) gd->gtk_len &&
[K		< 	     os_memcmp(sm->gtk.gtk, gd->gtk, sm->gtk.gtk_len) == 0) ||
[K		< 	    (sm->gtk_wnm_sleep.gtk_len == (size_t) gd->gtk_len &&
[K		< 	     os_memcmp(sm->gtk_wnm_sleep.gtk, gd->gtk,
[K		< 		       sm->gtk_wnm_sleep.gtk_len) == 0)) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: Not reinstalling already in-use GTK to the driver (keyidx=%d tx=%d len=%d)",
[K		< 			gd->keyidx, gd->tx, gd->gtk_len);
[K		< 		return 0;
[K		< 	}
[K		<
[K		< 	wpa_hexdump_key(MSG_DEBUG, "WPA: Group Key", gd->gtk, gd->gtk_len);
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 		"WPA: Installing GTK to the driver (keyidx=%d tx=%d len=%d)",
[K		< 		gd->keyidx, gd->tx, gd->gtk_len);
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: RSC", key_rsc, gd->key_rsc_len);
[K		< 	if (sm->group_cipher == WPA_CIPHER_TKIP) {
[K		< 		/* Swap Tx/Rx keys for Michael MIC */
[K		< 		os_memcpy(gtk_buf, gd->gtk, 16);
[K		< 		os_memcpy(gtk_buf + 16, gd->gtk + 24, 8);
[K		< 		os_memcpy(gtk_buf + 24, gd->gtk + 16, 8);
[K		< 		_gtk = gtk_buf;
[K		< 	}
[K		< 	if (sm->pairwise_cipher == WPA_CIPHER_NONE) {
[K		< 		if (wpa_sm_set_key(sm, gd->alg, NULL,
[K		< 				   gd->keyidx, 1, key_rsc, gd->key_rsc_len,
[K		< 				   _gtk, gd->gtk_len) < 0) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Failed to set GTK to the driver "
[K		< 				"(Group only)");
[K		< 			return -1;
[K		< 		}
[K		< 	} else if (wpa_sm_set_key(sm, gd->alg, broadcast_ether_addr,
[K		< 				  gd->keyidx, gd->tx, key_rsc, gd->key_rsc_len,
[K		< 				  _gtk, gd->gtk_len) < 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Failed to set GTK to "
[K		< 			"the driver (alg=%d keylen=%d keyidx=%d)",
[K		< 			gd->alg, gd->gtk_len, gd->keyidx);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (wnm_sleep) {
[K		< 		sm->gtk_wnm_sleep.gtk_len = gd->gtk_len;
[K		< 		os_memcpy(sm->gtk_wnm_sleep.gtk, gd->gtk,
[K		< 			  sm->gtk_wnm_sleep.gtk_len);
[K		< 	} else {
[K		< 		sm->gtk.gtk_len = gd->gtk_len;
[K		< 		os_memcpy(sm->gtk.gtk, gd->gtk, sm->gtk.gtk_len);
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_gtk_tx_bit_workaround(const struct wpa_sm *sm,
[K		< 						int tx)
[K		< {
[K		< 	if (tx && sm->pairwise_cipher != WPA_CIPHER_NONE) {
[K		< 		/* Ignore Tx bit for GTK if a pairwise key is used. One AP
[K		< 		 * seemed to set this bit (incorrectly, since Tx is only when
[K		< 		 * doing Group Key only APs) and without this workaround, the
[K		< 		 * data connection does not work because wpa_supplicant
[K		< 		 * configured non-zero keyidx to be used for unicast. */
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: Tx bit set for GTK, but pairwise "
[K		< 			"keys are used - ignore Tx bit");
[K		< 		return 0;
[K		< 	}
[K		< 	return tx;
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_pairwise_gtk(struct wpa_sm *sm,
[K		< 				       const struct wpa_eapol_key *key,
[K		< 				       const u8 *gtk, size_t gtk_len,
[K		< 				       int key_info)
[K		< {
[K		< #ifndef CONFIG_NO_WPA2
[K		< 	struct wpa_gtk_data gd;
[K		<
[K		< 	/*
[K		< 	 * IEEE Std 802.11i-2004 - 8.5.2 EAPOL-Key frames - Figure 43x
[K		< 	 * GTK KDE format:
[K		< 	 * KeyID[bits 0-1], Tx [bit 2], Reserved [bits 3-7]
[K		< 	 * Reserved [bits 0-7]
[K		< 	 * GTK
[K		< 	 */
[K		<
[K		< 	os_memset(&gd, 0, sizeof(gd));
[K		< 	wpa_hexdump_key(MSG_DEBUG, "RSN: received GTK in pairwise handshake",
[K		< 			gtk, gtk_len);
[K		<
[K		< 	if (gtk_len < 2 || gtk_len - 2 > sizeof(gd.gtk))
[K		< 		return -1;
[K		<
[K		< 	gd.keyidx = gtk[0] & 0x3;
[K		< 	gd.tx = wpa_supplicant_gtk_tx_bit_workaround(sm,
[K		< 						     !!(gtk[0] & BIT(2)));
[K		< 	gtk += 2;
[K		< 	gtk_len -= 2;
[K		<
[K		< 	os_memcpy(gd.gtk, gtk, gtk_len);
[K		< 	gd.gtk_len = gtk_len;
[K		<
[K		< 	if (wpa_supplicant_check_group_cipher(sm, sm->group_cipher,
[K		< 					      gtk_len, gtk_len,
[K		< 					      &gd.key_rsc_len, &gd.alg) ||
[K		< 	    wpa_supplicant_install_gtk(sm, &gd, key->key_rsc, 0)) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"RSN: Failed to install GTK");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	wpa_supplicant_key_neg_complete(sm, sm->bssid,
[K		< 					key_info & WPA_KEY_INFO_SECURE);
[K		< 	return 0;
[K		< #else /* CONFIG_NO_WPA2 */
[K		< 	return -1;
[K		< #endif /* CONFIG_NO_WPA2 */
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_IEEE80211W
[K		< static int wpa_supplicant_install_igtk(struct wpa_sm *sm,
[K		< 				       const struct wpa_igtk_kde *igtk,
[K		< 				       int wnm_sleep)
[K		< {
[K		< 	size_t len = WPA_IGTK_LEN;
[K		< 	u16 keyidx = WPA_GET_LE16(igtk->keyid);
[K		<
[K		< 	/* Detect possible key reinstallation */
[K		< 	if ((sm->igtk.igtk_len == len &&
[K		< 	     os_memcmp(sm->igtk.igtk, igtk->igtk, sm->igtk.igtk_len) == 0) ||
[K		< 	    (sm->igtk_wnm_sleep.igtk_len == len &&
[K		< 	     os_memcmp(sm->igtk_wnm_sleep.igtk, igtk->igtk,
[K		< 		       sm->igtk_wnm_sleep.igtk_len) == 0)) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: Not reinstalling already in-use IGTK to the driver (keyidx=%d)",
[K		< 			keyidx);
[K		< 		return  0;
[K		< 	}
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 		"WPA: IGTK keyid %d pn %02x%02x%02x%02x%02x%02x",
[K		< 		keyidx, MAC2STR(igtk->pn));
[K		< 	wpa_hexdump_key(MSG_DEBUG, "WPA: IGTK", igtk->igtk, len);
[K		< 	if (keyidx > 4095) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Invalid IGTK KeyID %d", keyidx);
[K		< 		return -1;
[K		< 	}
[K		< 	if (wpa_sm_set_key(sm, WPA_ALG_IGTK, broadcast_ether_addr,
[K		< 			   keyidx, 0, igtk->pn, sizeof(igtk->pn),
[K		< 			   igtk->igtk, WPA_IGTK_LEN) < 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Failed to configure IGTK to the driver");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (wnm_sleep) {
[K		< 		sm->igtk_wnm_sleep.igtk_len = len;
[K		< 		os_memcpy(sm->igtk_wnm_sleep.igtk, igtk->igtk,
[K		< 			  sm->igtk_wnm_sleep.igtk_len);
[K		< 	} else {
[K		< 		sm->igtk.igtk_len = len;
[K		< 		os_memcpy(sm->igtk.igtk, igtk->igtk, sm->igtk.igtk_len);
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		< #endif /* CONFIG_IEEE80211W */
[K		<
[K		<
[K		< static int ieee80211w_set_keys(struct wpa_sm *sm,
[K		< 			       struct wpa_eapol_ie_parse *ie)
[K		< {
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (sm->mgmt_group_cipher != WPA_CIPHER_AES_128_CMAC)
[K		< 		return 0;
[K		<
[K		< 	if (ie->igtk) {
[K		< 		const struct wpa_igtk_kde *igtk;
[K		< 		if (ie->igtk_len != sizeof(*igtk))
[K		< 			return -1;
[K		<
[K		< 		igtk = (const struct wpa_igtk_kde *) ie->igtk;
[K		< 		if (wpa_supplicant_install_igtk(sm, igtk, 0) < 0)
[K		< 			return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< #else /* CONFIG_IEEE80211W */
[K		< 	return 0;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< }
[K		<
[K		<
[K		< static void wpa_report_ie_mismatch(struct wpa_sm *sm,
[K		< 				   const char *reason, const u8 *src_addr,
[K		< 				   const u8 *wpa_ie, size_t wpa_ie_len,
[K		< 				   const u8 *rsn_ie, size_t rsn_ie_len)
[K		< {
[K		< 	wpa_msg(sm->ctx->msg_ctx, MSG_WARNING, "WPA: %s (src=" MACSTR ")",
[K		< 		reason, MAC2STR(src_addr));
[K		<
[K		< 	if (sm->ap_wpa_ie) {
[K		< 		wpa_hexdump(MSG_INFO, "WPA: WPA IE in Beacon/ProbeResp",
[K		< 			    sm->ap_wpa_ie, sm->ap_wpa_ie_len);
[K		< 	}
[K		< 	if (wpa_ie) {
[K		< 		if (!sm->ap_wpa_ie) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 				"WPA: No WPA IE in Beacon/ProbeResp");
[K		< 		}
[K		< 		wpa_hexdump(MSG_INFO, "WPA: WPA IE in 3/4 msg",
[K		< 			    wpa_ie, wpa_ie_len);
[K		< 	}
[K		<
[K		< 	if (sm->ap_rsn_ie) {
[K		< 		wpa_hexdump(MSG_INFO, "WPA: RSN IE in Beacon/ProbeResp",
[K		< 			    sm->ap_rsn_ie, sm->ap_rsn_ie_len);
[K		< 	}
[K		< 	if (rsn_ie) {
[K		< 		if (!sm->ap_rsn_ie) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 				"WPA: No RSN IE in Beacon/ProbeResp");
[K		< 		}
[K		< 		wpa_hexdump(MSG_INFO, "WPA: RSN IE in 3/4 msg",
[K		< 			    rsn_ie, rsn_ie_len);
[K		< 	}
[K		<
[K		< 	wpa_sm_deauthenticate(sm, WLAN_REASON_IE_IN_4WAY_DIFFERS);
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		<
[K		< static int ft_validate_mdie(struct wpa_sm *sm,
[K		< 			    const unsigned char *src_addr,
[K		< 			    struct wpa_eapol_ie_parse *ie,
[K		< 			    const u8 *assoc_resp_mdie)
[K		< {
[K		< 	struct rsn_mdie *mdie;
[K		<
[K		< 	mdie = (struct rsn_mdie *) (ie->mdie + 2);
[K		< 	if (ie->mdie == NULL || ie->mdie_len < 2 + sizeof(*mdie) ||
[K		< 	    os_memcmp(mdie->mobility_domain, sm->mobility_domain,
[K		< 		      MOBILITY_DOMAIN_ID_LEN) != 0) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "FT: MDIE in msg 3/4 did "
[K		< 			"not match with the current mobility domain");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (assoc_resp_mdie &&
[K		< 	    (assoc_resp_mdie[1] != ie->mdie[1] ||
[K		< 	     os_memcmp(assoc_resp_mdie, ie->mdie, 2 + ie->mdie[1]) != 0)) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "FT: MDIE mismatch");
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: MDIE in EAPOL-Key msg 3/4",
[K		< 			    ie->mdie, 2 + ie->mdie[1]);
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: MDIE in (Re)Association Response",
[K		< 			    assoc_resp_mdie, 2 + assoc_resp_mdie[1]);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int ft_validate_ftie(struct wpa_sm *sm,
[K		< 			    const unsigned char *src_addr,
[K		< 			    struct wpa_eapol_ie_parse *ie,
[K		< 			    const u8 *assoc_resp_ftie)
[K		< {
[K		< 	if (ie->ftie == NULL) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"FT: No FTIE in EAPOL-Key msg 3/4");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (assoc_resp_ftie == NULL)
[K		< 		return 0;
[K		<
[K		< 	if (assoc_resp_ftie[1] != ie->ftie[1] ||
[K		< 	    os_memcmp(assoc_resp_ftie, ie->ftie, 2 + ie->ftie[1]) != 0) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "FT: FTIE mismatch");
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: FTIE in EAPOL-Key msg 3/4",
[K		< 			    ie->ftie, 2 + ie->ftie[1]);
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: FTIE in (Re)Association Response",
[K		< 			    assoc_resp_ftie, 2 + assoc_resp_ftie[1]);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int ft_validate_rsnie(struct wpa_sm *sm,
[K		< 			     const unsigned char *src_addr,
[K		< 			     struct wpa_eapol_ie_parse *ie)
[K		< {
[K		< 	struct wpa_ie_data rsn;
[K		<
[K		< 	if (!ie->rsn_ie)
[K		< 		return 0;
[K		<
[K		< 	/*
[K		< 	 * Verify that PMKR1Name from EAPOL-Key message 3/4
[K		< 	 * matches with the value we derived.
[K		< 	 */
[K		< 	if (wpa_parse_wpa_ie_rsn(ie->rsn_ie, ie->rsn_ie_len, &rsn) < 0 ||
[K		< 	    rsn.num_pmkid != 1 || rsn.pmkid == NULL) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "FT: No PMKR1Name in "
[K		< 			"FT 4-way handshake message 3/4");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (os_memcmp(rsn.pmkid, sm->pmk_r1_name, WPA_PMK_NAME_LEN) != 0) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"FT: PMKR1Name mismatch in "
[K		< 			"FT 4-way handshake message 3/4");
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: PMKR1Name from Authenticator",
[K		< 			    rsn.pmkid, WPA_PMK_NAME_LEN);
[K		< 		wpa_hexdump(MSG_DEBUG, "FT: Derived PMKR1Name",
[K		< 			    sm->pmk_r1_name, WPA_PMK_NAME_LEN);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_validate_ie_ft(struct wpa_sm *sm,
[K		< 					 const unsigned char *src_addr,
[K		< 					 struct wpa_eapol_ie_parse *ie)
[K		< {
[K		< 	const u8 *pos, *end, *mdie = NULL, *ftie = NULL;
[K		<
[K		< 	if (sm->assoc_resp_ies) {
[K		< 		pos = sm->assoc_resp_ies;
[K		< 		end = pos + sm->assoc_resp_ies_len;
[K		< 		while (pos + 2 < end) {
[K		< 			if (pos + 2 + pos[1] > end)
[K		< 				break;
[K		< 			switch (*pos) {
[K		< 			case WLAN_EID_MOBILITY_DOMAIN:
[K		< 				mdie = pos;
[K		< 				break;
[K		< 			case WLAN_EID_FAST_BSS_TRANSITION:
[K		< 				ftie = pos;
[K		< 				break;
[K		< 			}
[K		< 			pos += 2 + pos[1];
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (ft_validate_mdie(sm, src_addr, ie, mdie) < 0 ||
[K		< 	    ft_validate_ftie(sm, src_addr, ie, ftie) < 0 ||
[K		< 	    ft_validate_rsnie(sm, src_addr, ie) < 0)
[K		< 		return -1;
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		< #endif /* CONFIG_IEEE80211R */
[K		<
[K		<
[K		< static int wpa_supplicant_validate_ie(struct wpa_sm *sm,
[K		< 				      const unsigned char *src_addr,
[K		< 				      struct wpa_eapol_ie_parse *ie)
[K		< {
[K		< 	if (sm->ap_wpa_ie == NULL && sm->ap_rsn_ie == NULL) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: No WPA/RSN IE for this AP known. "
[K		< 			"Trying to get from scan results");
[K		< 		if (wpa_sm_get_beacon_ie(sm) < 0) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Could not find AP from "
[K		< 				"the scan results");
[K		< 		} else {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 				"WPA: Found the current AP from "
[K		< 				"updated scan results");
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (ie->wpa_ie == NULL && ie->rsn_ie == NULL &&
[K		< 	    (sm->ap_wpa_ie || sm->ap_rsn_ie)) {
[K		< 		wpa_report_ie_mismatch(sm, "IE in 3/4 msg does not match "
[K		< 				       "with IE in Beacon/ProbeResp (no IE?)",
[K		< 				       src_addr, ie->wpa_ie, ie->wpa_ie_len,
[K		< 				       ie->rsn_ie, ie->rsn_ie_len);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if ((ie->wpa_ie && sm->ap_wpa_ie &&
[K		< 	     (ie->wpa_ie_len != sm->ap_wpa_ie_len ||
[K		< 	      os_memcmp(ie->wpa_ie, sm->ap_wpa_ie, ie->wpa_ie_len) != 0)) ||
[K		< 	    (ie->rsn_ie && sm->ap_rsn_ie &&
[K		< 	     wpa_compare_rsn_ie(wpa_key_mgmt_ft(sm->key_mgmt),
[K		< 				sm->ap_rsn_ie, sm->ap_rsn_ie_len,
[K		< 				ie->rsn_ie, ie->rsn_ie_len))) {
[K		< 		wpa_report_ie_mismatch(sm, "IE in 3/4 msg does not match "
[K		< 				       "with IE in Beacon/ProbeResp",
[K		< 				       src_addr, ie->wpa_ie, ie->wpa_ie_len,
[K		< 				       ie->rsn_ie, ie->rsn_ie_len);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (sm->proto == WPA_PROTO_WPA &&
[K		< 	    ie->rsn_ie && sm->ap_rsn_ie == NULL && sm->rsn_enabled) {
[K		< 		wpa_report_ie_mismatch(sm, "Possible downgrade attack "
[K		< 				       "detected - RSN was enabled and RSN IE "
[K		< 				       "was in msg 3/4, but not in "
[K		< 				       "Beacon/ProbeResp",
[K		< 				       src_addr, ie->wpa_ie, ie->wpa_ie_len,
[K		< 				       ie->rsn_ie, ie->rsn_ie_len);
[K		< 		return -1;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	if (wpa_key_mgmt_ft(sm->key_mgmt) &&
[K		< 	    wpa_supplicant_validate_ie_ft(sm, src_addr, ie) < 0)
[K		< 		return -1;
[K		< #endif /* CONFIG_IEEE80211R */
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_supplicant_send_4_of_4 - Send message 4 of WPA/RSN 4-Way Handshake
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @dst: Destination address for the frame
[K		<  * @key: Pointer to the EAPOL-Key frame header
[K		<  * @ver: Version bits from EAPOL-Key Key Info
[K		<  * @key_info: Key Info
[K		<  * @kde: KDEs to include the EAPOL-Key frame
[K		<  * @kde_len: Length of KDEs
[K		<  * @ptk: PTK to use for keyed hash and encryption
[K		<  * Returns: 0 on success, -1 on failure
[K		<  */
[K		< int wpa_supplicant_send_4_of_4(struct wpa_sm *sm, const unsigned char *dst,
[K		< 			       const struct wpa_eapol_key *key,
[K		< 			       u16 ver, u16 key_info,
[K		< 			       const u8 *kde, size_t kde_len,
[K		< 			       struct wpa_ptk *ptk)
[K		< {
[K		< 	size_t rlen;
[K		< 	struct wpa_eapol_key *reply;
[K		< 	u8 *rbuf;
[K		<
[K		< 	if (kde)
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: KDE for msg 4/4", kde, kde_len);
[K		<
[K		< 	rbuf = wpa_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAPOL_KEY, NULL,
[K		< 				  sizeof(*reply) + kde_len,
[K		< 				  &rlen, (void *) &reply);
[K		< 	if (rbuf == NULL)
[K		< 		return -1;
[K		<
[K		< 	reply->type = sm->proto == WPA_PROTO_RSN ?
[K		< 		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
[K		< 	key_info &= WPA_KEY_INFO_SECURE;
[K		< 	key_info |= ver | WPA_KEY_INFO_KEY_TYPE | WPA_KEY_INFO_MIC;
[K		< 	WPA_PUT_BE16(reply->key_info, key_info);
[K		< 	if (sm->proto == WPA_PROTO_RSN)
[K		< 		WPA_PUT_BE16(reply->key_length, 0);
[K		< 	else
[K		< 		os_memcpy(reply->key_length, key->key_length, 2);
[K		< 	os_memcpy(reply->replay_counter, key->replay_counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		<
[K		< 	WPA_PUT_BE16(reply->key_data_length, kde_len);
[K		< 	if (kde)
[K		< 		os_memcpy(reply + 1, kde, kde_len);
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Sending EAPOL-Key 4/4");
[K		< 	wpa_eapol_key_send(sm, ptk->kck, ver, dst, ETH_P_EAPOL,
[K		< 			   rbuf, rlen, reply->key_mic);
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_supplicant_process_3_of_4(struct wpa_sm *sm,
[K		< 					  const struct wpa_eapol_key *key,
[K		< 					  u16 ver)
[K		< {
[K		< 	u16 key_info, keylen, len;
[K		< 	const u8 *pos;
[K		< 	struct wpa_eapol_ie_parse ie;
[K		<
[K		< 	wpa_sm_set_state(sm, WPA_4WAY_HANDSHAKE);
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: RX message 3 of 4-Way "
[K		< 		"Handshake from " MACSTR " (ver=%d)", MAC2STR(sm->bssid), ver);
[K		<
[K		< 	key_info = WPA_GET_BE16(key->key_info);
[K		<
[K		< 	pos = (const u8 *) (key + 1);
[K		< 	len = WPA_GET_BE16(key->key_data_length);
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: IE KeyData", pos, len);
[K		< 	if (wpa_supplicant_parse_ies(pos, len, &ie) < 0)
[K		< 		goto failed;
[K		< 	if (ie.gtk && !(key_info & WPA_KEY_INFO_ENCR_KEY_DATA)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: GTK IE in unencrypted key data");
[K		< 		goto failed;
[K		< 	}
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (ie.igtk && !(key_info & WPA_KEY_INFO_ENCR_KEY_DATA)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: IGTK KDE in unencrypted key data");
[K		< 		goto failed;
[K		< 	}
[K		<
[K		< 	if (ie.igtk && ie.igtk_len != sizeof(struct wpa_igtk_kde)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Invalid IGTK KDE length %lu",
[K		< 			(unsigned long) ie.igtk_len);
[K		< 		goto failed;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211W */
[K		<
[K		< 	if (wpa_supplicant_validate_ie(sm, sm->bssid, &ie) < 0)
[K		< 		goto failed;
[K		<
[K		< 	if (os_memcmp(sm->anonce, key->key_nonce, WPA_NONCE_LEN) != 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: ANonce from message 1 of 4-Way Handshake "
[K		< 			"differs from 3 of 4-Way Handshake - drop packet (src="
[K		< 			MACSTR ")", MAC2STR(sm->bssid));
[K		< 		goto failed;
[K		< 	}
[K		<
[K		< 	keylen = WPA_GET_BE16(key->key_length);
[K		< 	if (keylen != wpa_cipher_key_len(sm->pairwise_cipher)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Invalid %s key length %d (src=" MACSTR
[K		< 			")", wpa_cipher_txt(sm->pairwise_cipher), keylen,
[K		< 			MAC2STR(sm->bssid));
[K		< 		goto failed;
[K		< 	}
[K		<
[K		< 	if (wpa_supplicant_send_4_of_4(sm, sm->bssid, key, ver, key_info,
[K		< 				       NULL, 0, &sm->ptk)) {
[K		< 		goto failed;
[K		< 	}
[K		<
[K		< 	/* SNonce was successfully used in msg 3/4, so mark it to be renewed
[K		< 	 * for the next 4-Way Handshake. If msg 3 is received again, the old
[K		< 	 * SNonce will still be used to avoid changing PTK. */
[K		< 	sm->renew_snonce = 1;
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_INSTALL) {
[K		< 		if (wpa_supplicant_install_ptk(sm, key))
[K		< 			goto failed;
[K		< 	}
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_SECURE) {
[K		< 		wpa_sm_mlme_setprotection(
[K		< 			sm, sm->bssid, MLME_SETPROTECTION_PROTECT_TYPE_RX,
[K		< 			MLME_SETPROTECTION_KEY_TYPE_PAIRWISE);
[K		< 		eapol_sm_notify_portValid(sm->eapol, TRUE);
[K		< 	}
[K		< 	wpa_sm_set_state(sm, WPA_GROUP_HANDSHAKE);
[K		<
[K		< 	if (ie.gtk &&
[K		< 	    wpa_supplicant_pairwise_gtk(sm, key,
[K		< 					ie.gtk, ie.gtk_len, key_info) < 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"RSN: Failed to configure GTK");
[K		< 		goto failed;
[K		< 	}
[K		<
[K		< 	if (ieee80211w_set_keys(sm, &ie) < 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"RSN: Failed to configure IGTK");
[K		< 		goto failed;
[K		< 	}
[K		<
[K		< 	wpa_sm_set_rekey_offload(sm);
[K		<
[K		< 	return;
[K		<
[K		< failed:
[K		< 	wpa_sm_deauthenticate(sm, WLAN_REASON_UNSPECIFIED);
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_process_1_of_2_rsn(struct wpa_sm *sm,
[K		< 					     const u8 *keydata,
[K		< 					     size_t keydatalen,
[K		< 					     u16 key_info,
[K		< 					     struct wpa_gtk_data *gd)
[K		< {
[K		< 	int maxkeylen;
[K		< 	struct wpa_eapol_ie_parse ie;
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "RSN: msg 1/2 key data", keydata, keydatalen);
[K		< 	if (wpa_supplicant_parse_ies(keydata, keydatalen, &ie) < 0)
[K		< 		return -1;
[K		< 	if (ie.gtk && !(key_info & WPA_KEY_INFO_ENCR_KEY_DATA)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: GTK IE in unencrypted key data");
[K		< 		return -1;
[K		< 	}
[K		< 	if (ie.gtk == NULL) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: No GTK IE in Group Key msg 1/2");
[K		< 		return -1;
[K		< 	}
[K		< 	maxkeylen = gd->gtk_len = ie.gtk_len - 2;
[K		<
[K		< 	if (wpa_supplicant_check_group_cipher(sm, sm->group_cipher,
[K		< 					      gd->gtk_len, maxkeylen,
[K		< 					      &gd->key_rsc_len, &gd->alg))
[K		< 		return -1;
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "RSN: received GTK in group key handshake",
[K		< 		    ie.gtk, ie.gtk_len);
[K		< 	gd->keyidx = ie.gtk[0] & 0x3;
[K		< 	gd->tx = wpa_supplicant_gtk_tx_bit_workaround(sm,
[K		< 						      !!(ie.gtk[0] & BIT(2)));
[K		< 	if (ie.gtk_len - 2 > sizeof(gd->gtk)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"RSN: Too long GTK in GTK IE (len=%lu)",
[K		< 			(unsigned long) ie.gtk_len - 2);
[K		< 		return -1;
[K		< 	}
[K		< 	os_memcpy(gd->gtk, ie.gtk + 2, ie.gtk_len - 2);
[K		<
[K		< 	if (ieee80211w_set_keys(sm, &ie) < 0)
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"RSN: Failed to configure IGTK");
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_process_1_of_2_wpa(struct wpa_sm *sm,
[K		< 					     const struct wpa_eapol_key *key,
[K		< 					     size_t keydatalen, int key_info,
[K		< 					     size_t extra_len, u16 ver,
[K		< 					     struct wpa_gtk_data *gd)
[K		< {
[K		< 	size_t maxkeylen;
[K		< 	u8 ek[32];
[K		<
[K		< 	gd->gtk_len = WPA_GET_BE16(key->key_length);
[K		< 	maxkeylen = keydatalen;
[K		< 	if (keydatalen > extra_len) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: Truncated EAPOL-Key packet: "
[K		< 			"key_data_length=%lu > extra_len=%lu",
[K		< 			(unsigned long) keydatalen, (unsigned long) extra_len);
[K		< 		return -1;
[K		< 	}
[K		< 	if (ver == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
[K		< 		if (maxkeylen < 8) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 				"WPA: Too short maxkeylen (%lu)",
[K		< 				(unsigned long) maxkeylen);
[K		< 			return -1;
[K		< 		}
[K		< 		maxkeylen -= 8;
[K		< 	}
[K		<
[K		< 	if (wpa_supplicant_check_group_cipher(sm, sm->group_cipher,
[K		< 					      gd->gtk_len, maxkeylen,
[K		< 					      &gd->key_rsc_len, &gd->alg))
[K		< 		return -1;
[K		<
[K		< 	gd->keyidx = (key_info & WPA_KEY_INFO_KEY_INDEX_MASK) >>
[K		< 		WPA_KEY_INFO_KEY_INDEX_SHIFT;
[K		< 	if (ver == WPA_KEY_INFO_TYPE_HMAC_MD5_RC4) {
[K		< 		os_memcpy(ek, key->key_iv, 16);
[K		< 		os_memcpy(ek + 16, sm->ptk.kek, 16);
[K		< 		if (keydatalen > sizeof(gd->gtk)) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: RC4 key data too long (%lu)",
[K		< 				(unsigned long) keydatalen);
[K		< 			return -1;
[K		< 		}
[K		< 		os_memcpy(gd->gtk, key + 1, keydatalen);
[K		< 		if (rc4_skip(ek, 32, 256, gd->gtk, keydatalen)) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_ERROR,
[K		< 				"WPA: RC4 failed");
[K		< 			return -1;
[K		< 		}
[K		< 	} else if (ver == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
[K		< 		if (keydatalen % 8) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Unsupported AES-WRAP len %lu",
[K		< 				(unsigned long) keydatalen);
[K		< 			return -1;
[K		< 		}
[K		< 		if (maxkeylen > sizeof(gd->gtk)) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: AES-WRAP key data "
[K		< 				"too long (keydatalen=%lu maxkeylen=%lu)",
[K		< 				(unsigned long) keydatalen,
[K		< 				(unsigned long) maxkeylen);
[K		< 			return -1;
[K		< 		}
[K		< 		if (aes_unwrap(sm->ptk.kek, maxkeylen / 8,
[K		< 			       (const u8 *) (key + 1), gd->gtk)) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: AES unwrap failed - could not decrypt "
[K		< 				"GTK");
[K		< 			return -1;
[K		< 		}
[K		< 	} else {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Unsupported key_info type %d", ver);
[K		< 		return -1;
[K		< 	}
[K		< 	gd->tx = wpa_supplicant_gtk_tx_bit_workaround(
[K		< 		sm, !!(key_info & WPA_KEY_INFO_TXRX));
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_send_2_of_2(struct wpa_sm *sm,
[K		< 				      const struct wpa_eapol_key *key,
[K		< 				      int ver, u16 key_info)
[K		< {
[K		< 	size_t rlen;
[K		< 	struct wpa_eapol_key *reply;
[K		< 	u8 *rbuf;
[K		<
[K		< 	rbuf = wpa_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAPOL_KEY, NULL,
[K		< 				  sizeof(*reply), &rlen, (void *) &reply);
[K		< 	if (rbuf == NULL)
[K		< 		return -1;
[K		<
[K		< 	reply->type = sm->proto == WPA_PROTO_RSN ?
[K		< 		EAPOL_KEY_TYPE_RSN : EAPOL_KEY_TYPE_WPA;
[K		< 	key_info &= WPA_KEY_INFO_KEY_INDEX_MASK;
[K		< 	key_info |= ver | WPA_KEY_INFO_MIC | WPA_KEY_INFO_SECURE;
[K		< 	WPA_PUT_BE16(reply->key_info, key_info);
[K		< 	if (sm->proto == WPA_PROTO_RSN)
[K		< 		WPA_PUT_BE16(reply->key_length, 0);
[K		< 	else
[K		< 		os_memcpy(reply->key_length, key->key_length, 2);
[K		< 	os_memcpy(reply->replay_counter, key->replay_counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		<
[K		< 	WPA_PUT_BE16(reply->key_data_length, 0);
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Sending EAPOL-Key 2/2");
[K		< 	wpa_eapol_key_send(sm, sm->ptk.kck, ver, sm->bssid, ETH_P_EAPOL,
[K		< 			   rbuf, rlen, reply->key_mic);
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< static void wpa_supplicant_process_1_of_2(struct wpa_sm *sm,
[K		< 					  const unsigned char *src_addr,
[K		< 					  const struct wpa_eapol_key *key,
[K		< 					  int extra_len, u16 ver)
[K		< {
[K		< 	u16 key_info, keydatalen;
[K		< 	int rekey, ret;
[K		< 	struct wpa_gtk_data gd;
[K		<
[K		< 	os_memset(&gd, 0, sizeof(gd));
[K		<
[K		< 	rekey = wpa_sm_get_state(sm) == WPA_COMPLETED;
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: RX message 1 of Group Key "
[K		< 		"Handshake from " MACSTR " (ver=%d)", MAC2STR(src_addr), ver);
[K		<
[K		< 	key_info = WPA_GET_BE16(key->key_info);
[K		< 	keydatalen = WPA_GET_BE16(key->key_data_length);
[K		<
[K		< 	if (sm->proto == WPA_PROTO_RSN) {
[K		< 		ret = wpa_supplicant_process_1_of_2_rsn(sm,
[K		< 							(const u8 *) (key + 1),
[K		< 							keydatalen, key_info,
[K		< 							&gd);
[K		< 	} else {
[K		< 		ret = wpa_supplicant_process_1_of_2_wpa(sm, key, keydatalen,
[K		< 							key_info, extra_len,
[K		< 							ver, &gd);
[K		< 	}
[K		<
[K		< 	wpa_sm_set_state(sm, WPA_GROUP_HANDSHAKE);
[K		<
[K		< 	if (ret)
[K		< 		goto failed;
[K		<
[K		< 	if (wpa_supplicant_install_gtk(sm, &gd, key->key_rsc, 0) ||
[K		< 	    wpa_supplicant_send_2_of_2(sm, key, ver, key_info))
[K		< 		goto failed;
[K		<
[K		< 	if (rekey) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Group rekeying "
[K		< 			"completed with " MACSTR " [GTK=%s]",
[K		< 			MAC2STR(sm->bssid), wpa_cipher_txt(sm->group_cipher));
[K		< 		wpa_sm_cancel_auth_timeout(sm);
[K		< 		wpa_sm_set_state(sm, WPA_COMPLETED);
[K		<
[K		< 		wpa_sm_set_rekey_offload(sm);
[K		< 	} else {
[K		< 		wpa_supplicant_key_neg_complete(sm, sm->bssid,
[K		< 						key_info &
[K		< 						WPA_KEY_INFO_SECURE);
[K		< 	}
[K		< 	return;
[K		<
[K		< failed:
[K		< 	wpa_sm_deauthenticate(sm, WLAN_REASON_UNSPECIFIED);
[K		< }
[K		<
[K		<
[K		< static int wpa_supplicant_verify_eapol_key_mic(struct wpa_sm *sm,
[K		< 					       struct wpa_eapol_key *key,
[K		< 					       u16 ver,
[K		< 					       const u8 *buf, size_t len)
[K		< {
[K		< 	u8 mic[16];
[K		< 	int ok = 0;
[K		<
[K		< 	os_memcpy(mic, key->key_mic, 16);
[K		< 	if (sm->tptk_set) {
[K		< 		os_memset(key->key_mic, 0, 16);
[K		< 		wpa_eapol_key_mic(sm->tptk.kck, ver, buf, len,
[K		< 				  key->key_mic);
[K		< 		if (os_memcmp(mic, key->key_mic, 16) != 0) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Invalid EAPOL-Key MIC "
[K		< 				"when using TPTK - ignoring TPTK");
[K		< 		} else {
[K		< 			ok = 1;
[K		< 			sm->tptk_set = 0;
[K		< 			sm->ptk_set = 1;
[K		< 			os_memcpy(&sm->ptk, &sm->tptk, sizeof(sm->ptk));
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (!ok && sm->ptk_set) {
[K		< 		os_memset(key->key_mic, 0, 16);
[K		< 		wpa_eapol_key_mic(sm->ptk.kck, ver, buf, len,
[K		< 				  key->key_mic);
[K		< 		if (os_memcmp(mic, key->key_mic, 16) != 0) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Invalid EAPOL-Key MIC - "
[K		< 				"dropping packet");
[K		< 			return -1;
[K		< 		}
[K		< 		ok = 1;
[K		< 	}
[K		<
[K		< 	if (!ok) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Could not verify EAPOL-Key MIC - "
[K		< 			"dropping packet");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	os_memcpy(sm->rx_replay_counter, key->replay_counter,
[K		< 		  WPA_REPLAY_COUNTER_LEN);
[K		< 	sm->rx_replay_counter_set = 1;
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /* Decrypt RSN EAPOL-Key key data (RC4 or AES-WRAP) */
[K		< static int wpa_supplicant_decrypt_key_data(struct wpa_sm *sm,
[K		< 					   struct wpa_eapol_key *key, u16 ver)
[K		< {
[K		< 	u16 keydatalen = WPA_GET_BE16(key->key_data_length);
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "RSN: encrypted key data",
[K		< 		    (u8 *) (key + 1), keydatalen);
[K		< 	if (!sm->ptk_set) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: PTK not available, cannot decrypt EAPOL-Key Key "
[K		< 			"Data");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	/* Decrypt key data here so that this operation does not need
[K		< 	 * to be implemented separately for each message type. */
[K		< 	if (ver == WPA_KEY_INFO_TYPE_HMAC_MD5_RC4) {
[K		< 		u8 ek[32];
[K		< 		os_memcpy(ek, key->key_iv, 16);
[K		< 		os_memcpy(ek + 16, sm->ptk.kek, 16);
[K		< 		if (rc4_skip(ek, 32, 256, (u8 *) (key + 1), keydatalen)) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_ERROR,
[K		< 				"WPA: RC4 failed");
[K		< 			return -1;
[K		< 		}
[K		< 	} else if (ver == WPA_KEY_INFO_TYPE_HMAC_SHA1_AES ||
[K		< 		   ver == WPA_KEY_INFO_TYPE_AES_128_CMAC) {
[K		< 		u8 *buf;
[K		< 		if (keydatalen % 8) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Unsupported AES-WRAP len %d",
[K		< 				keydatalen);
[K		< 			return -1;
[K		< 		}
[K		< 		keydatalen -= 8; /* AES-WRAP adds 8 bytes */
[K		< 		buf = os_malloc(keydatalen);
[K		< 		if (buf == NULL) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: No memory for AES-UNWRAP buffer");
[K		< 			return -1;
[K		< 		}
[K		< 		if (aes_unwrap(sm->ptk.kek, keydatalen / 8,
[K		< 			       (u8 *) (key + 1), buf)) {
[K		< 			os_free(buf);
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: AES unwrap failed - "
[K		< 				"could not decrypt EAPOL-Key key data");
[K		< 			return -1;
[K		< 		}
[K		< 		os_memcpy(key + 1, buf, keydatalen);
[K		< 		os_free(buf);
[K		< 		WPA_PUT_BE16(key->key_data_length, keydatalen);
[K		< 	} else {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: Unsupported key_info type %d", ver);
[K		< 		return -1;
[K		< 	}
[K		< 	wpa_hexdump_key(MSG_DEBUG, "WPA: decrypted EAPOL-Key key data",
[K		< 			(u8 *) (key + 1), keydatalen);
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_aborted_cached - Notify WPA that PMKSA caching was aborted
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  */
[K		< void wpa_sm_aborted_cached(struct wpa_sm *sm)
[K		< {
[K		< 	if (sm && sm->cur_pmksa) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"RSN: Cancelling PMKSA caching attempt");
[K		< 		sm->cur_pmksa = NULL;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< static void wpa_eapol_key_dump(struct wpa_sm *sm,
[K		< 			       const struct wpa_eapol_key *key)
[K		< {
[K		< #ifndef CONFIG_NO_STDOUT_DEBUG
[K		< 	u16 key_info = WPA_GET_BE16(key->key_info);
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "  EAPOL-Key type=%d", key->type);
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 		"  key_info 0x%x (ver=%d keyidx=%d rsvd=%d %s%s%s%s%s%s%s%s)",
[K		< 		key_info, key_info & WPA_KEY_INFO_TYPE_MASK,
[K		< 		(key_info & WPA_KEY_INFO_KEY_INDEX_MASK) >>
[K		< 		WPA_KEY_INFO_KEY_INDEX_SHIFT,
[K		< 		(key_info & (BIT(13) | BIT(14) | BIT(15))) >> 13,
[K		< 		key_info & WPA_KEY_INFO_KEY_TYPE ? "Pairwise" : "Group",
[K		< 		key_info & WPA_KEY_INFO_INSTALL ? " Install" : "",
[K		< 		key_info & WPA_KEY_INFO_ACK ? " Ack" : "",
[K		< 		key_info & WPA_KEY_INFO_MIC ? " MIC" : "",
[K		< 		key_info & WPA_KEY_INFO_SECURE ? " Secure" : "",
[K		< 		key_info & WPA_KEY_INFO_ERROR ? " Error" : "",
[K		< 		key_info & WPA_KEY_INFO_REQUEST ? " Request" : "",
[K		< 		key_info & WPA_KEY_INFO_ENCR_KEY_DATA ? " Encr" : "");
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 		"  key_length=%u key_data_length=%u",
[K		< 		WPA_GET_BE16(key->key_length),
[K		< 		WPA_GET_BE16(key->key_data_length));
[K		< 	wpa_hexdump(MSG_DEBUG, "  replay_counter",
[K		< 		    key->replay_counter, WPA_REPLAY_COUNTER_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "  key_nonce", key->key_nonce, WPA_NONCE_LEN);
[K		< 	wpa_hexdump(MSG_DEBUG, "  key_iv", key->key_iv, 16);
[K		< 	wpa_hexdump(MSG_DEBUG, "  key_rsc", key->key_rsc, 8);
[K		< 	wpa_hexdump(MSG_DEBUG, "  key_id (reserved)", key->key_id, 8);
[K		< 	wpa_hexdump(MSG_DEBUG, "  key_mic", key->key_mic, 16);
[K		< #endif /* CONFIG_NO_STDOUT_DEBUG */
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_rx_eapol - Process received WPA EAPOL frames
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @src_addr: Source MAC address of the EAPOL packet
[K		<  * @buf: Pointer to the beginning of the EAPOL data (EAPOL header)
[K		<  * @len: Length of the EAPOL frame
[K		<  * Returns: 1 = WPA EAPOL-Key processed, 0 = not a WPA EAPOL-Key, -1 failure
[K		<  *
[K		<  * This function is called for each received EAPOL frame. Other than EAPOL-Key
[K		<  * frames can be skipped if filtering is done elsewhere. wpa_sm_rx_eapol() is
[K		<  * only processing WPA and WPA2 EAPOL-Key frames.
[K		<  *
[K		<  * The received EAPOL-Key packets are validated and valid packets are replied
[K		<  * to. In addition, key material (PTK, GTK) is configured at the end of a
[K		<  * successful key handshake.
[K		<  */
[K		< int wpa_sm_rx_eapol(struct wpa_sm *sm, const u8 *src_addr,
[K		< 		    const u8 *buf, size_t len)
[K		< {
[K		< 	size_t plen, data_len, extra_len;
[K		< 	struct ieee802_1x_hdr *hdr;
[K		< 	struct wpa_eapol_key *key;
[K		< 	u16 key_info, ver;
[K		< 	u8 *tmp;
[K		< 	int ret = -1;
[K		< 	struct wpa_peerkey *peerkey = NULL;
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	sm->ft_completed = 0;
[K		< #endif /* CONFIG_IEEE80211R */
[K		<
[K		< 	if (len < sizeof(*hdr) + sizeof(*key)) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: EAPOL frame too short to be a WPA "
[K		< 			"EAPOL-Key (len %lu, expecting at least %lu)",
[K		< 			(unsigned long) len,
[K		< 			(unsigned long) sizeof(*hdr) + sizeof(*key));
[K		< 		return 0;
[K		< 	}
[K		<
[K		< 	tmp = os_malloc(len);
[K		< 	if (tmp == NULL)
[K		< 		return -1;
[K		< 	os_memcpy(tmp, buf, len);
[K		<
[K		< 	hdr = (struct ieee802_1x_hdr *) tmp;
[K		< 	key = (struct wpa_eapol_key *) (hdr + 1);
[K		< 	plen = be_to_host16(hdr->length);
[K		< 	data_len = plen + sizeof(*hdr);
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 		"IEEE 802.1X RX: version=%d type=%d length=%lu",
[K		< 		hdr->version, hdr->type, (unsigned long) plen);
[K		<
[K		< 	if (hdr->version < EAPOL_VERSION) {
[K		< 		/* TODO: backwards compatibility */
[K		< 	}
[K		< 	if (hdr->type != IEEE802_1X_TYPE_EAPOL_KEY) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: EAPOL frame (type %u) discarded, "
[K		< 			"not a Key frame", hdr->type);
[K		< 		ret = 0;
[K		< 		goto out;
[K		< 	}
[K		< 	if (plen > len - sizeof(*hdr) || plen < sizeof(*key)) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: EAPOL frame payload size %lu "
[K		< 			"invalid (frame size %lu)",
[K		< 			(unsigned long) plen, (unsigned long) len);
[K		< 		ret = 0;
[K		< 		goto out;
[K		< 	}
[K		<
[K		< 	if (key->type != EAPOL_KEY_TYPE_WPA && key->type != EAPOL_KEY_TYPE_RSN)
[K		< 	{
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: EAPOL-Key type (%d) unknown, discarded",
[K		< 			key->type);
[K		< 		ret = 0;
[K		< 		goto out;
[K		< 	}
[K		< 	wpa_eapol_key_dump(sm, key);
[K		<
[K		< 	eapol_sm_notify_lower_layer_success(sm->eapol, 0);
[K		< 	wpa_hexdump(MSG_MSGDUMP, "WPA: RX EAPOL-Key", tmp, len);
[K		< 	if (data_len < len) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: ignoring %lu bytes after the IEEE 802.1X data",
[K		< 			(unsigned long) len - data_len);
[K		< 	}
[K		< 	key_info = WPA_GET_BE16(key->key_info);
[K		< 	ver = key_info & WPA_KEY_INFO_TYPE_MASK;
[K		< 	if (ver != WPA_KEY_INFO_TYPE_HMAC_MD5_RC4 &&
[K		< #if defined(CONFIG_IEEE80211R) || defined(CONFIG_IEEE80211W)
[K		< 	    ver != WPA_KEY_INFO_TYPE_AES_128_CMAC &&
[K		< #endif /* CONFIG_IEEE80211R || CONFIG_IEEE80211W */
[K		< 	    ver != WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: Unsupported EAPOL-Key descriptor version %d",
[K		< 			ver);
[K		< 		goto out;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	if (wpa_key_mgmt_ft(sm->key_mgmt)) {
[K		< 		/* IEEE 802.11r uses a new key_info type (AES-128-CMAC). */
[K		< 		if (ver != WPA_KEY_INFO_TYPE_AES_128_CMAC) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 				"FT: AP did not use AES-128-CMAC");
[K		< 			goto out;
[K		< 		}
[K		< 	} else
[K		< #endif /* CONFIG_IEEE80211R */
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	if (wpa_key_mgmt_sha256(sm->key_mgmt)) {
[K		< 		if (ver != WPA_KEY_INFO_TYPE_AES_128_CMAC) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 				"WPA: AP did not use the "
[K		< 				"negotiated AES-128-CMAC");
[K		< 			goto out;
[K		< 		}
[K		< 	} else
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	if (sm->pairwise_cipher == WPA_CIPHER_CCMP &&
[K		< 	    ver != WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: CCMP is used, but EAPOL-Key "
[K		< 			"descriptor version (%d) is not 2", ver);
[K		< 		if (sm->group_cipher != WPA_CIPHER_CCMP &&
[K		< 		    !(key_info & WPA_KEY_INFO_KEY_TYPE)) {
[K		< 			/* Earlier versions of IEEE 802.11i did not explicitly
[K		< 			 * require version 2 descriptor for all EAPOL-Key
[K		< 			 * packets, so allow group keys to use version 1 if
[K		< 			 * CCMP is not used for them. */
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 				"WPA: Backwards compatibility: allow invalid "
[K		< 				"version for non-CCMP group keys");
[K		< 		} else
[K		< 			goto out;
[K		< 	}
[K		< 	if (sm->pairwise_cipher == WPA_CIPHER_GCMP &&
[K		< 	    ver != WPA_KEY_INFO_TYPE_HMAC_SHA1_AES) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: GCMP is used, but EAPOL-Key "
[K		< 			"descriptor version (%d) is not 2", ver);
[K		< 		goto out;
[K		< 	}
[K		<
[K		< #ifdef CONFIG_PEERKEY
[K		< 	for (peerkey = sm->peerkey; peerkey; peerkey = peerkey->next) {
[K		< 		if (os_memcmp(peerkey->addr, src_addr, ETH_ALEN) == 0)
[K		< 			break;
[K		< 	}
[K		<
[K		< 	if (!(key_info & WPA_KEY_INFO_SMK_MESSAGE) && peerkey) {
[K		< 		if (!peerkey->initiator && peerkey->replay_counter_set &&
[K		< 		    os_memcmp(key->replay_counter, peerkey->replay_counter,
[K		< 			      WPA_REPLAY_COUNTER_LEN) <= 0) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"RSN: EAPOL-Key Replay Counter did not "
[K		< 				"increase (STK) - dropping packet");
[K		< 			goto out;
[K		< 		} else if (peerkey->initiator) {
[K		< 			u8 _tmp[WPA_REPLAY_COUNTER_LEN];
[K		< 			os_memcpy(_tmp, key->replay_counter,
[K		< 				  WPA_REPLAY_COUNTER_LEN);
[K		< 			inc_byte_array(_tmp, WPA_REPLAY_COUNTER_LEN);
[K		< 			if (os_memcmp(_tmp, peerkey->replay_counter,
[K		< 				      WPA_REPLAY_COUNTER_LEN) != 0) {
[K		< 				wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 					"RSN: EAPOL-Key Replay "
[K		< 					"Counter did not match (STK) - "
[K		< 					"dropping packet");
[K		< 				goto out;
[K		< 			}
[K		< 		}
[K		< 	}
[K		<
[K		< 	if (peerkey && peerkey->initiator && (key_info & WPA_KEY_INFO_ACK)) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"RSN: Ack bit in key_info from STK peer");
[K		< 		goto out;
[K		< 	}
[K		< #endif /* CONFIG_PEERKEY */
[K		<
[K		< 	if (!peerkey && sm->rx_replay_counter_set &&
[K		< 	    os_memcmp(key->replay_counter, sm->rx_replay_counter,
[K		< 		      WPA_REPLAY_COUNTER_LEN) <= 0) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 			"WPA: EAPOL-Key Replay Counter did not increase - "
[K		< 			"dropping packet");
[K		< 		goto out;
[K		< 	}
[K		<
[K		< 	if (!(key_info & (WPA_KEY_INFO_ACK | WPA_KEY_INFO_SMK_MESSAGE))
[K		< #ifdef CONFIG_PEERKEY
[K		< 	    && (peerkey == NULL || !peerkey->initiator)
[K		< #endif /* CONFIG_PEERKEY */
[K		< 		) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: No Ack bit in key_info");
[K		< 		goto out;
[K		< 	}
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_REQUEST) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
[K		< 			"WPA: EAPOL-Key with Request bit - dropped");
[K		< 		goto out;
[K		< 	}
[K		<
[K		< 	if ((key_info & WPA_KEY_INFO_MIC) && !peerkey &&
[K		< 	    wpa_supplicant_verify_eapol_key_mic(sm, key, ver, tmp, data_len))
[K		< 		goto out;
[K		<
[K		< #ifdef CONFIG_PEERKEY
[K		< 	if ((key_info & WPA_KEY_INFO_MIC) && peerkey &&
[K		< 	    peerkey_verify_eapol_key_mic(sm, peerkey, key, ver, tmp, data_len))
[K		< 		goto out;
[K		< #endif /* CONFIG_PEERKEY */
[K		<
[K		< 	extra_len = data_len - sizeof(*hdr) - sizeof(*key);
[K		<
[K		< 	if (WPA_GET_BE16(key->key_data_length) > extra_len) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_INFO, "WPA: Invalid EAPOL-Key "
[K		< 			"frame - key_data overflow (%d > %lu)",
[K		< 			WPA_GET_BE16(key->key_data_length),
[K		< 			(unsigned long) extra_len);
[K		< 		goto out;
[K		< 	}
[K		< 	extra_len = WPA_GET_BE16(key->key_data_length);
[K		<
[K		< 	if (sm->proto == WPA_PROTO_RSN &&
[K		< 	    (key_info & WPA_KEY_INFO_ENCR_KEY_DATA)) {
[K		< 		if (wpa_supplicant_decrypt_key_data(sm, key, ver))
[K		< 			goto out;
[K		< 		extra_len = WPA_GET_BE16(key->key_data_length);
[K		< 	}
[K		<
[K		< 	if (key_info & WPA_KEY_INFO_KEY_TYPE) {
[K		< 		if (key_info & WPA_KEY_INFO_KEY_INDEX_MASK) {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: Ignored EAPOL-Key (Pairwise) with "
[K		< 				"non-zero key index");
[K		< 			goto out;
[K		< 		}
[K		< 		if (peerkey) {
[K		< 			/* PeerKey 4-Way Handshake */
[K		< 			peerkey_rx_eapol_4way(sm, peerkey, key, key_info, ver);
[K		< 		} else if (key_info & WPA_KEY_INFO_MIC) {
[K		< 			/* 3/4 4-Way Handshake */
[K		< 			wpa_supplicant_process_3_of_4(sm, key, ver);
[K		< 		} else {
[K		< 			/* 1/4 4-Way Handshake */
[K		< 			wpa_supplicant_process_1_of_4(sm, src_addr, key,
[K		< 						      ver);
[K		< 		}
[K		< 	} else if (key_info & WPA_KEY_INFO_SMK_MESSAGE) {
[K		< 		/* PeerKey SMK Handshake */
[K		< 		peerkey_rx_eapol_smk(sm, src_addr, key, extra_len, key_info,
[K		< 				     ver);
[K		< 	} else {
[K		< 		if (key_info & WPA_KEY_INFO_MIC) {
[K		< 			/* 1/2 Group Key Handshake */
[K		< 			wpa_supplicant_process_1_of_2(sm, src_addr, key,
[K		< 						      extra_len, ver);
[K		< 		} else {
[K		< 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
[K		< 				"WPA: EAPOL-Key (Group) without Mic bit - "
[K		< 				"dropped");
[K		< 		}
[K		< 	}
[K		<
[K		< 	ret = 1;
[K		<
[K		< out:
[K		< 	os_free(tmp);
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_CTRL_IFACE
[K		< static u32 wpa_key_mgmt_suite(struct wpa_sm *sm)
[K		< {
[K		< 	switch (sm->key_mgmt) {
[K		< 	case WPA_KEY_MGMT_IEEE8021X:
[K		< 		return (sm->proto == WPA_PROTO_RSN ?
[K		< 			RSN_AUTH_KEY_MGMT_UNSPEC_802_1X :
[K		< 			WPA_AUTH_KEY_MGMT_UNSPEC_802_1X);
[K		< 	case WPA_KEY_MGMT_PSK:
[K		< 		return (sm->proto == WPA_PROTO_RSN ?
[K		< 			RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X :
[K		< 			WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X);
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	case WPA_KEY_MGMT_FT_IEEE8021X:
[K		< 		return RSN_AUTH_KEY_MGMT_FT_802_1X;
[K		< 	case WPA_KEY_MGMT_FT_PSK:
[K		< 		return RSN_AUTH_KEY_MGMT_FT_PSK;
[K		< #endif /* CONFIG_IEEE80211R */
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	case WPA_KEY_MGMT_IEEE8021X_SHA256:
[K		< 		return RSN_AUTH_KEY_MGMT_802_1X_SHA256;
[K		< 	case WPA_KEY_MGMT_PSK_SHA256:
[K		< 		return RSN_AUTH_KEY_MGMT_PSK_SHA256;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	case WPA_KEY_MGMT_CCKM:
[K		< 		return (sm->proto == WPA_PROTO_RSN ?
[K		< 			RSN_AUTH_KEY_MGMT_CCKM:
[K		< 			WPA_AUTH_KEY_MGMT_CCKM);
[K		< 	case WPA_KEY_MGMT_WPA_NONE:
[K		< 		return WPA_AUTH_KEY_MGMT_NONE;
[K		< 	default:
[K		< 		return 0;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< #define RSN_SUITE "%02x-%02x-%02x-%d"
[K		< #define RSN_SUITE_ARG(s) \
[K		< ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
[K		<
[K		< /**
[K		<  * wpa_sm_get_mib - Dump text list of MIB entries
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @buf: Buffer for the list
[K		<  * @buflen: Length of the buffer
[K		<  * Returns: Number of bytes written to buffer
[K		<  *
[K		<  * This function is used fetch dot11 MIB variables.
[K		<  */
[K		< int wpa_sm_get_mib(struct wpa_sm *sm, char *buf, size_t buflen)
[K		< {
[K		< 	char pmkid_txt[PMKID_LEN * 2 + 1];
[K		< 	int rsna, ret;
[K		< 	size_t len;
[K		<
[K		< 	if (sm->cur_pmksa) {
[K		< 		wpa_snprintf_hex(pmkid_txt, sizeof(pmkid_txt),
[K		< 				 sm->cur_pmksa->pmkid, PMKID_LEN);
[K		< 	} else
[K		< 		pmkid_txt[0] = '\0';
[K		<
[K		< 	if ((wpa_key_mgmt_wpa_psk(sm->key_mgmt) ||
[K		< 	     wpa_key_mgmt_wpa_ieee8021x(sm->key_mgmt)) &&
[K		< 	    sm->proto == WPA_PROTO_RSN)
[K		< 		rsna = 1;
[K		< 	else
[K		< 		rsna = 0;
[K		<
[K		< 	ret = os_snprintf(buf, buflen,
[K		< 			  "dot11RSNAOptionImplemented=TRUE\n"
[K		< 			  "dot11RSNAPreauthenticationImplemented=TRUE\n"
[K		< 			  "dot11RSNAEnabled=%s\n"
[K		< 			  "dot11RSNAPreauthenticationEnabled=%s\n"
[K		< 			  "dot11RSNAConfigVersion=%d\n"
[K		< 			  "dot11RSNAConfigPairwiseKeysSupported=5\n"
[K		< 			  "dot11RSNAConfigGroupCipherSize=%d\n"
[K		< 			  "dot11RSNAConfigPMKLifetime=%d\n"
[K		< 			  "dot11RSNAConfigPMKReauthThreshold=%d\n"
[K		< 			  "dot11RSNAConfigNumberOfPTKSAReplayCounters=1\n"
[K		< 			  "dot11RSNAConfigSATimeout=%d\n",
[K		< 			  rsna ? "TRUE" : "FALSE",
[K		< 			  rsna ? "TRUE" : "FALSE",
[K		< 			  RSN_VERSION,
[K		< 			  wpa_cipher_key_len(sm->group_cipher) * 8,
[K		< 			  sm->dot11RSNAConfigPMKLifetime,
[K		< 			  sm->dot11RSNAConfigPMKReauthThreshold,
[K		< 			  sm->dot11RSNAConfigSATimeout);
[K		< 	if (ret < 0 || (size_t) ret >= buflen)
[K		< 		return 0;
[K		< 	len = ret;
[K		<
[K		< 	ret = os_snprintf(
[K		< 		buf + len, buflen - len,
[K		< 		"dot11RSNAAuthenticationSuiteSelected=" RSN_SUITE "\n"
[K		< 		"dot11RSNAPairwiseCipherSelected=" RSN_SUITE "\n"
[K		< 		"dot11RSNAGroupCipherSelected=" RSN_SUITE "\n"
[K		< 		"dot11RSNAPMKIDUsed=%s\n"
[K		< 		"dot11RSNAAuthenticationSuiteRequested=" RSN_SUITE "\n"
[K		< 		"dot11RSNAPairwiseCipherRequested=" RSN_SUITE "\n"
[K		< 		"dot11RSNAGroupCipherRequested=" RSN_SUITE "\n"
[K		< 		"dot11RSNAConfigNumberOfGTKSAReplayCounters=0\n"
[K		< 		"dot11RSNA4WayHandshakeFailures=%u\n",
[K		< 		RSN_SUITE_ARG(wpa_key_mgmt_suite(sm)),
[K		< 		RSN_SUITE_ARG(wpa_cipher_to_suite(sm->proto,
[K		< 						  sm->pairwise_cipher)),
[K		< 		RSN_SUITE_ARG(wpa_cipher_to_suite(sm->proto,
[K		< 						  sm->group_cipher)),
[K		< 		pmkid_txt,
[K		< 		RSN_SUITE_ARG(wpa_key_mgmt_suite(sm)),
[K		< 		RSN_SUITE_ARG(wpa_cipher_to_suite(sm->proto,
[K		< 						  sm->pairwise_cipher)),
[K		< 		RSN_SUITE_ARG(wpa_cipher_to_suite(sm->proto,
[K		< 						  sm->group_cipher)),
[K		< 		sm->dot11RSNA4WayHandshakeFailures);
[K		< 	if (ret >= 0 && (size_t) ret < buflen)
[K		< 		len += ret;
[K		<
[K		< 	return (int) len;
[K		< }
[K		< #endif /* CONFIG_CTRL_IFACE */
[K		<
[K		<
[K		< static void wpa_sm_pmksa_free_cb(struct rsn_pmksa_cache_entry *entry,
[K		< 				 void *ctx, enum pmksa_free_reason reason)
[K		< {
[K		< 	struct wpa_sm *sm = ctx;
[K		< 	int deauth = 0;
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "RSN: PMKSA cache entry free_cb: "
[K		< 		MACSTR " reason=%d", MAC2STR(entry->aa), reason);
[K		<
[K		< 	if (sm->cur_pmksa == entry) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"RSN: %s current PMKSA entry",
[K		< 			reason == PMKSA_REPLACE ? "replaced" : "removed");
[K		< 		pmksa_cache_clear_current(sm);
[K		<
[K		< 		/*
[K		< 		 * If an entry is simply being replaced, there's no need to
[K		< 		 * deauthenticate because it will be immediately re-added.
[K		< 		 * This happens when EAP authentication is completed again
[K		< 		 * (reauth or failed PMKSA caching attempt).
[K		< 		 */
[K		< 		if (reason != PMKSA_REPLACE)
[K		< 			deauth = 1;
[K		< 	}
[K		<
[K		< 	if (reason == PMKSA_EXPIRE &&
[K		< 	    (sm->pmk_len == entry->pmk_len &&
[K		< 	     os_memcmp(sm->pmk, entry->pmk, sm->pmk_len) == 0)) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"RSN: deauthenticating due to expired PMK");
[K		< 		pmksa_cache_clear_current(sm);
[K		< 		deauth = 1;
[K		< 	}
[K		<
[K		< 	if (deauth) {
[K		< 		os_memset(sm->pmk, 0, sizeof(sm->pmk));
[K		< 		wpa_sm_deauthenticate(sm, WLAN_REASON_UNSPECIFIED);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_init - Initialize WPA state machine
[K		<  * @ctx: Context pointer for callbacks; this needs to be an allocated buffer
[K		<  * Returns: Pointer to the allocated WPA state machine data
[K		<  *
[K		<  * This function is used to allocate a new WPA state machine and the returned
[K		<  * value is passed to all WPA state machine calls.
[K		<  */
[K		< struct wpa_sm * wpa_sm_init(struct wpa_sm_ctx *ctx)
[K		< {
[K		< 	struct wpa_sm *sm;
[K		<
[K		< 	sm = os_zalloc(sizeof(*sm));
[K		< 	if (sm == NULL)
[K		< 		return NULL;
[K		< 	dl_list_init(&sm->pmksa_candidates);
[K		< 	sm->renew_snonce = 1;
[K		< 	sm->ctx = ctx;
[K		<
[K		< 	sm->dot11RSNAConfigPMKLifetime = 43200;
[K		< 	sm->dot11RSNAConfigPMKReauthThreshold = 70;
[K		< 	sm->dot11RSNAConfigSATimeout = 60;
[K		<
[K		< 	sm->pmksa = pmksa_cache_init(wpa_sm_pmksa_free_cb, sm, sm);
[K		< 	if (sm->pmksa == NULL) {
[K		< 		wpa_msg(sm->ctx->msg_ctx, MSG_ERROR,
[K		< 			"RSN: PMKSA cache initialization failed");
[K		< 		os_free(sm);
[K		< 		return NULL;
[K		< 	}
[K		<
[K		< 	return sm;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_deinit - Deinitialize WPA state machine
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  */
[K		< void wpa_sm_deinit(struct wpa_sm *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		< 	pmksa_cache_deinit(sm->pmksa);
[K		< 	eloop_cancel_timeout(wpa_sm_start_preauth, sm, NULL);
[K		< 	eloop_cancel_timeout(wpa_sm_rekey_ptk, sm, NULL);
[K		< 	os_free(sm->assoc_wpa_ie);
[K		< 	os_free(sm->ap_wpa_ie);
[K		< 	os_free(sm->ap_rsn_ie);
[K		< 	os_free(sm->ctx);
[K		< 	peerkey_deinit(sm);
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	os_free(sm->assoc_resp_ies);
[K		< #endif /* CONFIG_IEEE80211R */
[K		< 	os_free(sm);
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_notify_assoc - Notify WPA state machine about association
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @bssid: The BSSID of the new association
[K		<  *
[K		<  * This function is called to let WPA state machine know that the connection
[K		<  * was established.
[K		<  */
[K		< void wpa_sm_notify_assoc(struct wpa_sm *sm, const u8 *bssid)
[K		< {
[K		< 	int clear_keys = 1;
[K		<
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 		"WPA: Association event - clear replay counter");
[K		< 	os_memcpy(sm->bssid, bssid, ETH_ALEN);
[K		< 	os_memset(sm->rx_replay_counter, 0, WPA_REPLAY_COUNTER_LEN);
[K		< 	sm->rx_replay_counter_set = 0;
[K		< 	sm->renew_snonce = 1;
[K		< 	if (os_memcmp(sm->preauth_bssid, bssid, ETH_ALEN) == 0)
[K		< 		rsn_preauth_deinit(sm);
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	if (wpa_ft_is_completed(sm)) {
[K		< 		/*
[K		< 		 * Clear portValid to kick EAPOL state machine to re-enter
[K		< 		 * AUTHENTICATED state to get the EAPOL port Authorized.
[K		< 		 */
[K		< 		eapol_sm_notify_portValid(sm->eapol, FALSE);
[K		< 		wpa_supplicant_key_neg_complete(sm, sm->bssid, 1);
[K		<
[K		< 		/* Prepare for the next transition */
[K		< 		wpa_ft_prepare_auth_request(sm, NULL);
[K		<
[K		< 		clear_keys = 0;
[K		< 	}
[K		< #endif /* CONFIG_IEEE80211R */
[K		<
[K		< 	if (clear_keys) {
[K		< 		/*
[K		< 		 * IEEE 802.11, 8.4.10: Delete PTK SA on (re)association if
[K		< 		 * this is not part of a Fast BSS Transition.
[K		< 		 */
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Clear old PTK");
[K		< 		sm->ptk_set = 0;
[K		< 		sm->tptk_set = 0;
[K		< 		os_memset(&sm->gtk, 0, sizeof(sm->gtk));
[K		< 		os_memset(&sm->gtk_wnm_sleep, 0, sizeof(sm->gtk_wnm_sleep));
[K		< #ifdef CONFIG_IEEE80211W
[K		< 		os_memset(&sm->igtk, 0, sizeof(sm->igtk));
[K		< 		os_memset(&sm->igtk_wnm_sleep, 0, sizeof(sm->igtk_wnm_sleep));
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	}
[K		<
[K		< #ifdef CONFIG_TDLS
[K		< 	wpa_tdls_assoc(sm);
[K		< #endif /* CONFIG_TDLS */
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_notify_disassoc - Notify WPA state machine about disassociation
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  *
[K		<  * This function is called to let WPA state machine know that the connection
[K		<  * was lost. This will abort any existing pre-authentication session.
[K		<  */
[K		< void wpa_sm_notify_disassoc(struct wpa_sm *sm)
[K		< {
[K		< 	rsn_preauth_deinit(sm);
[K		< 	pmksa_cache_clear_current(sm);
[K		< 	if (wpa_sm_get_state(sm) == WPA_4WAY_HANDSHAKE)
[K		< 		sm->dot11RSNA4WayHandshakeFailures++;
[K		< #ifdef CONFIG_TDLS
[K		< 	wpa_tdls_disassoc(sm);
[K		< #endif /* CONFIG_TDLS */
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	sm->ft_reassoc_completed = 0;
[K		< #endif /* CONFIG_IEEE80211R */
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_pmk - Set PMK
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @pmk: The new PMK
[K		<  * @pmk_len: The length of the new PMK in bytes
[K		<  *
[K		<  * Configure the PMK for WPA state machine.
[K		<  */
[K		< void wpa_sm_set_pmk(struct wpa_sm *sm, const u8 *pmk, size_t pmk_len)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	sm->pmk_len = pmk_len;
[K		< 	os_memcpy(sm->pmk, pmk, pmk_len);
[K		<
[K		< #ifdef CONFIG_IEEE80211R
[K		< 	/* Set XXKey to be PSK for FT key derivation */
[K		< 	sm->xxkey_len = pmk_len;
[K		< 	os_memcpy(sm->xxkey, pmk, pmk_len);
[K		< #endif /* CONFIG_IEEE80211R */
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_pmk_from_pmksa - Set PMK based on the current PMKSA
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  *
[K		<  * Take the PMK from the current PMKSA into use. If no PMKSA is active, the PMK
[K		<  * will be cleared.
[K		<  */
[K		< void wpa_sm_set_pmk_from_pmksa(struct wpa_sm *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		<
[K		< 	if (sm->cur_pmksa) {
[K		< 		sm->pmk_len = sm->cur_pmksa->pmk_len;
[K		< 		os_memcpy(sm->pmk, sm->cur_pmksa->pmk, sm->pmk_len);
[K		< 	} else {
[K		< 		sm->pmk_len = PMK_LEN;
[K		< 		os_memset(sm->pmk, 0, PMK_LEN);
[K		< 	}
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_fast_reauth - Set fast reauthentication (EAP) enabled/disabled
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @fast_reauth: Whether fast reauthentication (EAP) is allowed
[K		<  */
[K		< void wpa_sm_set_fast_reauth(struct wpa_sm *sm, int fast_reauth)
[K		< {
[K		< 	if (sm)
[K		< 		sm->fast_reauth = fast_reauth;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_scard_ctx - Set context pointer for smartcard callbacks
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @scard_ctx: Context pointer for smartcard related callback functions
[K		<  */
[K		< void wpa_sm_set_scard_ctx(struct wpa_sm *sm, void *scard_ctx)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return;
[K		< 	sm->scard_ctx = scard_ctx;
[K		< 	if (sm->preauth_eapol)
[K		< 		eapol_sm_register_scard_ctx(sm->preauth_eapol, scard_ctx);
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_config - Notification of current configration change
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @config: Pointer to current network configuration
[K		<  *
[K		<  * Notify WPA state machine that configuration has changed. config will be
[K		<  * stored as a backpointer to network configuration. This can be %NULL to clear
[K		<  * the stored pointed.
[K		<  */
[K		< void wpa_sm_set_config(struct wpa_sm *sm, struct rsn_supp_config *config)
[K		< {
[K		< 	if (!sm)
[K		< 		return;
[K		<
[K		< 	if (config) {
[K		< 		sm->network_ctx = config->network_ctx;
[K		< 		sm->peerkey_enabled = config->peerkey_enabled;
[K		< 		sm->allowed_pairwise_cipher = config->allowed_pairwise_cipher;
[K		< 		sm->proactive_key_caching = config->proactive_key_caching;
[K		< 		sm->eap_workaround = config->eap_workaround;
[K		< 		sm->eap_conf_ctx = config->eap_conf_ctx;
[K		< 		if (config->ssid) {
[K		< 			os_memcpy(sm->ssid, config->ssid, config->ssid_len);
[K		< 			sm->ssid_len = config->ssid_len;
[K		< 		} else
[K		< 			sm->ssid_len = 0;
[K		< 		sm->wpa_ptk_rekey = config->wpa_ptk_rekey;
[K		< 	} else {
[K		< 		sm->network_ctx = NULL;
[K		< 		sm->peerkey_enabled = 0;
[K		< 		sm->allowed_pairwise_cipher = 0;
[K		< 		sm->proactive_key_caching = 0;
[K		< 		sm->eap_workaround = 0;
[K		< 		sm->eap_conf_ctx = NULL;
[K		< 		sm->ssid_len = 0;
[K		< 		sm->wpa_ptk_rekey = 0;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_own_addr - Set own MAC address
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @addr: Own MAC address
[K		<  */
[K		< void wpa_sm_set_own_addr(struct wpa_sm *sm, const u8 *addr)
[K		< {
[K		< 	if (sm)
[K		< 		os_memcpy(sm->own_addr, addr, ETH_ALEN);
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_ifname - Set network interface name
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @ifname: Interface name
[K		<  * @bridge_ifname: Optional bridge interface name (for pre-auth)
[K		<  */
[K		< void wpa_sm_set_ifname(struct wpa_sm *sm, const char *ifname,
[K		< 		       const char *bridge_ifname)
[K		< {
[K		< 	if (sm) {
[K		< 		sm->ifname = ifname;
[K		< 		sm->bridge_ifname = bridge_ifname;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_eapol - Set EAPOL state machine pointer
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @eapol: Pointer to EAPOL state machine allocated with eapol_sm_init()
[K		<  */
[K		< void wpa_sm_set_eapol(struct wpa_sm *sm, struct eapol_sm *eapol)
[K		< {
[K		< 	if (sm)
[K		< 		sm->eapol = eapol;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_param - Set WPA state machine parameters
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @param: Parameter field
[K		<  * @value: Parameter value
[K		<  * Returns: 0 on success, -1 on failure
[K		<  */
[K		< int wpa_sm_set_param(struct wpa_sm *sm, enum wpa_sm_conf_params param,
[K		< 		     unsigned int value)
[K		< {
[K		< 	int ret = 0;
[K		<
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< 	switch (param) {
[K		< 	case RSNA_PMK_LIFETIME:
[K		< 		if (value > 0)
[K		< 			sm->dot11RSNAConfigPMKLifetime = value;
[K		< 		else
[K		< 			ret = -1;
[K		< 		break;
[K		< 	case RSNA_PMK_REAUTH_THRESHOLD:
[K		< 		if (value > 0 && value <= 100)
[K		< 			sm->dot11RSNAConfigPMKReauthThreshold = value;
[K		< 		else
[K		< 			ret = -1;
[K		< 		break;
[K		< 	case RSNA_SA_TIMEOUT:
[K		< 		if (value > 0)
[K		< 			sm->dot11RSNAConfigSATimeout = value;
[K		< 		else
[K		< 			ret = -1;
[K		< 		break;
[K		< 	case WPA_PARAM_PROTO:
[K		< 		sm->proto = value;
[K		< 		break;
[K		< 	case WPA_PARAM_PAIRWISE:
[K		< 		sm->pairwise_cipher = value;
[K		< 		break;
[K		< 	case WPA_PARAM_GROUP:
[K		< 		sm->group_cipher = value;
[K		< 		break;
[K		< 	case WPA_PARAM_KEY_MGMT:
[K		< 		sm->key_mgmt = value;
[K		< 		break;
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	case WPA_PARAM_MGMT_GROUP:
[K		< 		sm->mgmt_group_cipher = value;
[K		< 		break;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	case WPA_PARAM_RSN_ENABLED:
[K		< 		sm->rsn_enabled = value;
[K		< 		break;
[K		< 	case WPA_PARAM_MFP:
[K		< 		sm->mfp = value;
[K		< 		break;
[K		< 	default:
[K		< 		break;
[K		< 	}
[K		<
[K		< 	return ret;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_get_param - Get WPA state machine parameters
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @param: Parameter field
[K		<  * Returns: Parameter value
[K		<  */
[K		< unsigned int wpa_sm_get_param(struct wpa_sm *sm, enum wpa_sm_conf_params param)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return 0;
[K		<
[K		< 	switch (param) {
[K		< 	case RSNA_PMK_LIFETIME:
[K		< 		return sm->dot11RSNAConfigPMKLifetime;
[K		< 	case RSNA_PMK_REAUTH_THRESHOLD:
[K		< 		return sm->dot11RSNAConfigPMKReauthThreshold;
[K		< 	case RSNA_SA_TIMEOUT:
[K		< 		return sm->dot11RSNAConfigSATimeout;
[K		< 	case WPA_PARAM_PROTO:
[K		< 		return sm->proto;
[K		< 	case WPA_PARAM_PAIRWISE:
[K		< 		return sm->pairwise_cipher;
[K		< 	case WPA_PARAM_GROUP:
[K		< 		return sm->group_cipher;
[K		< 	case WPA_PARAM_KEY_MGMT:
[K		< 		return sm->key_mgmt;
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	case WPA_PARAM_MGMT_GROUP:
[K		< 		return sm->mgmt_group_cipher;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	case WPA_PARAM_RSN_ENABLED:
[K		< 		return sm->rsn_enabled;
[K		< 	default:
[K		< 		return 0;
[K		< 	}
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_get_status - Get WPA state machine
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @buf: Buffer for status information
[K		<  * @buflen: Maximum buffer length
[K		<  * @verbose: Whether to include verbose status information
[K		<  * Returns: Number of bytes written to buf.
[K		<  *
[K		<  * Query WPA state machine for status information. This function fills in
[K		<  * a text area with current status information. If the buffer (buf) is not
[K		<  * large enough, status information will be truncated to fit the buffer.
[K		<  */
[K		< int wpa_sm_get_status(struct wpa_sm *sm, char *buf, size_t buflen,
[K		< 		      int verbose)
[K		< {
[K		< 	char *pos = buf, *end = buf + buflen;
[K		< 	int ret;
[K		<
[K		< 	ret = os_snprintf(pos, end - pos,
[K		< 			  "pairwise_cipher=%s\n"
[K		< 			  "group_cipher=%s\n"
[K		< 			  "key_mgmt=%s\n",
[K		< 			  wpa_cipher_txt(sm->pairwise_cipher),
[K		< 			  wpa_cipher_txt(sm->group_cipher),
[K		< 			  wpa_key_mgmt_txt(sm->key_mgmt, sm->proto));
[K		< 	if (ret < 0 || ret >= end - pos)
[K		< 		return pos - buf;
[K		< 	pos += ret;
[K		<
[K		< 	if (sm->mfp != NO_MGMT_FRAME_PROTECTION && sm->ap_rsn_ie) {
[K		< 		struct wpa_ie_data rsn;
[K		< 		if (wpa_parse_wpa_ie_rsn(sm->ap_rsn_ie, sm->ap_rsn_ie_len, &rsn)
[K		< 		    >= 0 &&
[K		< 		    rsn.capabilities & (WPA_CAPABILITY_MFPR |
[K		< 					WPA_CAPABILITY_MFPC)) {
[K		< 			ret = os_snprintf(pos, end - pos, "pmf=%d\n",
[K		< 					  (rsn.capabilities &
[K		< 					   WPA_CAPABILITY_MFPR) ? 2 : 1);
[K		< 			if (ret < 0 || ret >= end - pos)
[K		< 				return pos - buf;
[K		< 			pos += ret;
[K		< 		}
[K		< 	}
[K		<
[K		< 	return pos - buf;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_assoc_wpa_ie_default - Generate own WPA/RSN IE from configuration
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @wpa_ie: Pointer to buffer for WPA/RSN IE
[K		<  * @wpa_ie_len: Pointer to the length of the wpa_ie buffer
[K		<  * Returns: 0 on success, -1 on failure
[K		<  */
[K		< int wpa_sm_set_assoc_wpa_ie_default(struct wpa_sm *sm, u8 *wpa_ie,
[K		< 				    size_t *wpa_ie_len)
[K		< {
[K		< 	int res;
[K		<
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< 	res = wpa_gen_wpa_ie(sm, wpa_ie, *wpa_ie_len);
[K		< 	if (res < 0)
[K		< 		return -1;
[K		< 	*wpa_ie_len = res;
[K		<
[K		< 	wpa_hexdump(MSG_DEBUG, "WPA: Set own WPA IE default",
[K		< 		    wpa_ie, *wpa_ie_len);
[K		<
[K		< 	if (sm->assoc_wpa_ie == NULL) {
[K		< 		/*
[K		< 		 * Make a copy of the WPA/RSN IE so that 4-Way Handshake gets
[K		< 		 * the correct version of the IE even if PMKSA caching is
[K		< 		 * aborted (which would remove PMKID from IE generation).
[K		< 		 */
[K		< 		sm->assoc_wpa_ie = os_malloc(*wpa_ie_len);
[K		< 		if (sm->assoc_wpa_ie == NULL)
[K		< 			return -1;
[K		<
[K		< 		os_memcpy(sm->assoc_wpa_ie, wpa_ie, *wpa_ie_len);
[K		< 		sm->assoc_wpa_ie_len = *wpa_ie_len;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_assoc_wpa_ie - Set own WPA/RSN IE from (Re)AssocReq
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @ie: Pointer to IE data (starting from id)
[K		<  * @len: IE length
[K		<  * Returns: 0 on success, -1 on failure
[K		<  *
[K		<  * Inform WPA state machine about the WPA/RSN IE used in (Re)Association
[K		<  * Request frame. The IE will be used to override the default value generated
[K		<  * with wpa_sm_set_assoc_wpa_ie_default().
[K		<  */
[K		< int wpa_sm_set_assoc_wpa_ie(struct wpa_sm *sm, const u8 *ie, size_t len)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< 	os_free(sm->assoc_wpa_ie);
[K		< 	if (ie == NULL || len == 0) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: clearing own WPA/RSN IE");
[K		< 		sm->assoc_wpa_ie = NULL;
[K		< 		sm->assoc_wpa_ie_len = 0;
[K		< 	} else {
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: set own WPA/RSN IE", ie, len);
[K		< 		sm->assoc_wpa_ie = os_malloc(len);
[K		< 		if (sm->assoc_wpa_ie == NULL)
[K		< 			return -1;
[K		<
[K		< 		os_memcpy(sm->assoc_wpa_ie, ie, len);
[K		< 		sm->assoc_wpa_ie_len = len;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_ap_wpa_ie - Set AP WPA IE from Beacon/ProbeResp
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @ie: Pointer to IE data (starting from id)
[K		<  * @len: IE length
[K		<  * Returns: 0 on success, -1 on failure
[K		<  *
[K		<  * Inform WPA state machine about the WPA IE used in Beacon / Probe Response
[K		<  * frame.
[K		<  */
[K		< int wpa_sm_set_ap_wpa_ie(struct wpa_sm *sm, const u8 *ie, size_t len)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< 	os_free(sm->ap_wpa_ie);
[K		< 	if (ie == NULL || len == 0) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: clearing AP WPA IE");
[K		< 		sm->ap_wpa_ie = NULL;
[K		< 		sm->ap_wpa_ie_len = 0;
[K		< 	} else {
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: set AP WPA IE", ie, len);
[K		< 		sm->ap_wpa_ie = os_malloc(len);
[K		< 		if (sm->ap_wpa_ie == NULL)
[K		< 			return -1;
[K		<
[K		< 		os_memcpy(sm->ap_wpa_ie, ie, len);
[K		< 		sm->ap_wpa_ie_len = len;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_set_ap_rsn_ie - Set AP RSN IE from Beacon/ProbeResp
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @ie: Pointer to IE data (starting from id)
[K		<  * @len: IE length
[K		<  * Returns: 0 on success, -1 on failure
[K		<  *
[K		<  * Inform WPA state machine about the RSN IE used in Beacon / Probe Response
[K		<  * frame.
[K		<  */
[K		< int wpa_sm_set_ap_rsn_ie(struct wpa_sm *sm, const u8 *ie, size_t len)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< 	os_free(sm->ap_rsn_ie);
[K		< 	if (ie == NULL || len == 0) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: clearing AP RSN IE");
[K		< 		sm->ap_rsn_ie = NULL;
[K		< 		sm->ap_rsn_ie_len = 0;
[K		< 	} else {
[K		< 		wpa_hexdump(MSG_DEBUG, "WPA: set AP RSN IE", ie, len);
[K		< 		sm->ap_rsn_ie = os_malloc(len);
[K		< 		if (sm->ap_rsn_ie == NULL)
[K		< 			return -1;
[K		<
[K		< 		os_memcpy(sm->ap_rsn_ie, ie, len);
[K		< 		sm->ap_rsn_ie_len = len;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< /**
[K		<  * wpa_sm_parse_own_wpa_ie - Parse own WPA/RSN IE
[K		<  * @sm: Pointer to WPA state machine data from wpa_sm_init()
[K		<  * @data: Pointer to data area for parsing results
[K		<  * Returns: 0 on success, -1 if IE is not known, or -2 on parsing failure
[K		<  *
[K		<  * Parse the contents of the own WPA or RSN IE from (Re)AssocReq and write the
[K		<  * parsed data into data.
[K		<  */
[K		< int wpa_sm_parse_own_wpa_ie(struct wpa_sm *sm, struct wpa_ie_data *data)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return -1;
[K		<
[K		< 	if (sm->assoc_wpa_ie == NULL) {
[K		< 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
[K		< 			"WPA: No WPA/RSN IE available from association info");
[K		< 		return -1;
[K		< 	}
[K		< 	if (wpa_parse_wpa_ie(sm->assoc_wpa_ie, sm->assoc_wpa_ie_len, data))
[K		< 		return -2;
[K		< 	return 0;
[K		< }
[K		<
[K		<
[K		< int wpa_sm_pmksa_cache_list(struct wpa_sm *sm, char *buf, size_t len)
[K		< {
[K		< #ifndef CONFIG_NO_WPA2
[K		< 	return pmksa_cache_list(sm->pmksa, buf, len);
[K		< #else /* CONFIG_NO_WPA2 */
[K		< 	return -1;
[K		< #endif /* CONFIG_NO_WPA2 */
[K		< }
[K		<
[K		<
[K		< void wpa_sm_drop_sa(struct wpa_sm *sm)
[K		< {
[K		< 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: Clear old PMK and PTK");
[K		< 	sm->ptk_set = 0;
[K		< 	sm->tptk_set = 0;
[K		< 	os_memset(sm->pmk, 0, sizeof(sm->pmk));
[K		< 	os_memset(&sm->ptk, 0, sizeof(sm->ptk));
[K		< 	os_memset(&sm->tptk, 0, sizeof(sm->tptk));
[K		< 	os_memset(&sm->gtk, 0, sizeof(sm->gtk));
[K		< 	os_memset(&sm->gtk_wnm_sleep, 0, sizeof(sm->gtk_wnm_sleep));
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	os_memset(&sm->igtk, 0, sizeof(sm->igtk));
[K		< 	os_memset(&sm->igtk_wnm_sleep, 0, sizeof(sm->igtk_wnm_sleep));
[K		< #endif /* CONFIG_IEEE80211W */
[K		< }
[K		<
[K		<
[K		< int wpa_sm_has_ptk(struct wpa_sm *sm)
[K		< {
[K		< 	if (sm == NULL)
[K		< 		return 0;
[K		< 	return sm->ptk_set;
[K		< }
[K		<
[K		<
[K		< void wpa_sm_update_replay_ctr(struct wpa_sm *sm, const u8 *replay_ctr)
[K		< {
[K		< 	os_memcpy(sm->rx_replay_counter, replay_ctr, WPA_REPLAY_COUNTER_LEN);
[K		< }
[K		<
[K		<
[K		< void wpa_sm_pmksa_cache_flush(struct wpa_sm *sm, void *network_ctx)
[K		< {
[K		< #ifndef CONFIG_NO_WPA2
[K		< 	pmksa_cache_flush(sm->pmksa, network_ctx);
[K		< #endif /* CONFIG_NO_WPA2 */
[K		< }
[K		<
[K		<
[K		< #ifdef CONFIG_WNM
[K		< int wpa_wnmsleep_install_key(struct wpa_sm *sm, u8 subelem_id, u8 *buf)
[K		< {
[K		< 	struct wpa_gtk_data gd;
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	struct wpa_igtk_kde igd;
[K		< 	u16 keyidx;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	u16 keyinfo;
[K		< 	u8 keylen;  /* plaintext key len */
[K		< 	u8 *key_rsc;
[K		<
[K		< 	os_memset(&gd, 0, sizeof(gd));
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	os_memset(&igd, 0, sizeof(igd));
[K		< #endif /* CONFIG_IEEE80211W */
[K		<
[K		< 	keylen = wpa_cipher_key_len(sm->group_cipher);
[K		< 	gd.key_rsc_len = wpa_cipher_rsc_len(sm->group_cipher);
[K		< 	gd.alg = wpa_cipher_to_alg(sm->group_cipher);
[K		< 	if (gd.alg == WPA_ALG_NONE) {
[K		< 		wpa_printf(MSG_DEBUG, "Unsupported group cipher suite");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	if (subelem_id == WNM_SLEEP_SUBELEM_GTK) {
[K		< 		key_rsc = buf + 5;
[K		< 		keyinfo = WPA_GET_LE16(buf + 2);
[K		< 		gd.gtk_len = keylen;
[K		< 		if (gd.gtk_len != buf[4]) {
[K		< 			wpa_printf(MSG_DEBUG, "GTK len mismatch len %d vs %d",
[K		< 				   gd.gtk_len, buf[4]);
[K		< 			return -1;
[K		< 		}
[K		< 		gd.keyidx = keyinfo & 0x03; /* B0 - B1 */
[K		< 		gd.tx = wpa_supplicant_gtk_tx_bit_workaround(
[K		< 		         sm, !!(keyinfo & WPA_KEY_INFO_TXRX));
[K		<
[K		< 		os_memcpy(gd.gtk, buf + 13, gd.gtk_len);
[K		<
[K		< 		wpa_hexdump_key(MSG_DEBUG, "Install GTK (WNM SLEEP)",
[K		< 				gd.gtk, gd.gtk_len);
[K		< 		if (wpa_supplicant_install_gtk(sm, &gd, key_rsc, 1)) {
[K		< 			wpa_printf(MSG_DEBUG, "Failed to install the GTK in "
[K		< 				   "WNM mode");
[K		< 			return -1;
[K		< 		}
[K		< #ifdef CONFIG_IEEE80211W
[K		< 	} else if (subelem_id == WNM_SLEEP_SUBELEM_IGTK) {
[K		< 		const struct wpa_igtk_kde *igtk;
[K		<
[K		< 		igtk = (const struct wpa_igtk_kde *) (buf + 2);
[K		< 		if (wpa_supplicant_install_igtk(sm, igtk, 1) < 0)
[K		< 			return -1;
[K		< #endif /* CONFIG_IEEE80211W */
[K		< 	} else {
[K		< 		wpa_printf(MSG_DEBUG, "Unknown element id");
[K		< 		return -1;
[K		< 	}
[K		<
[K		< 	return 0;
[K		< }
[K		< #endif /* CONFIG_WNM */
[K
	Successful transformation
[K
	Successful transplanting code, after 5.524946212768555 seconds.
[K
	Starting transplanting functions...
	__________________________________________________________________________________________

[K		-none-
[K
	Successful transplanting functions, after 0.0004515647888183594 seconds.
[K
	Starting transplanting data structures...
	__________________________________________________________________________________________

[K		-none-
[K
	Successful transplanting data structures, after 0.0002486705780029297 seconds.
[K
	Starting transplanting macros...
	__________________________________________________________________________________________

[K		-none-
[K
	Successful transplanting macros, after 0.00025773048400878906 seconds.
[K
	Starting transplanting header files...
	__________________________________________________________________________________________

[K		-none-
[K
	Successful transplanting header files, after 0.00022649765014648438 seconds.
[K
	Starting correcting syntax errors...
	__________________________________________________________________________________________

[K
		computing syntax errors
		------------------------------------------------------------------------------------------

[K
	Successful correcting syntax errors, after 0.0003223419189453125 seconds.
[K
====================================================================================================

	Patch Verification
====================================================================================================

[K
	verifying compilation...
	__________________________________________________________________________________________

[K
		building projects
		------------------------------------------------------------------------------------------

[K			/hostap/CVE-2018-14526_10_4/FreeBSD-10.4/contrib/wpa/src-patch/
[K
	Successful verifying compilation, after 5.418607950210571 seconds.
[K	
Run time statistics:
-----------------------

[K	Initialization: 0.10335254669189453 seconds
[K	Build Analysis: 44.360939502716064 seconds
[K	Diff Analysis: 5.202069282531738 seconds
[K	Clone Analysis: 2.3033828735351562 seconds
[K	AST Analysis: 2.3033828735351562 seconds
[K	Map Generation: 4.369724273681641 seconds
[K	Translation: 1.9069676399230957 seconds
[K	Transplantation: 5.72628378868103 seconds
[K	Verification: 5.419121026992798 seconds
[K
Crochet finished successfully after 246.59046840667725 seconds

