#! /usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jun 12 10:25:58 2018

@author: pedrobw
"""

import os
import time
from Utils import exec_com, err_exit, find_files, remove_Hexa, clean, \
                  get_extensions, levenshtein
#from ASTParser import transplant, longestSubstringFinder
import Project
import ASTVector
import Print

Pa = None
Pb = None
Pc = None


''' Main vector generation functions '''


def gen_AST(file, src_dir):
    
    # Check that we have an appropriate file
    if not os.path.isfile(file):
        err_exit("This is not a file: \n" + file)
        
    # Uses clang -ast-dump to generate an AST for file an saves it in "AST"
    c = "clang -Xclang -ast-dump -fsyntax-only -fno-diagnostics-color " + \
        "-ferror-limit=0 -w -I /usr/include/ -I /usr/local/include/ "
    
    # We try to include any .h file stated in the .c file
    d = "cat " + file + " | grep '#include' | grep '\.h' > output/hs"
    exec_com(d, False)
    includes = set()
    with open('output/hs', 'r', errors='replace') as h_files:
        line = h_files.readline().strip()
        while line:
            # For cases of the form '#include "****.h"'
            if '"' in line:
                line = line.split('"')[1]
            # For cases of the form '#include <****.h>'
            else:
                line = line.split('<')[1].split('>')[0]
            # We only keep the file name or find doesn't work
            line = line.split("/")[-1]
            c1 = "find " + src_dir + " -name '" + line + "'"
            l = exec_com(c1, False)[0].split("/")
            if len(l) > 2:
                # Here we get the directory and the parent directory
                includes.add("/".join(l[:-1]))
                includes.add("/".join(l[:-2]))
            line = h_files.readline().strip()
    for include in includes:
        c += "-I " + include + " "
    c += file + " > " + file + ".AST 2>> output/errors"
    try:
        exec_com(c, False)
    except Exception as e:
        err_exit(e, "Error with clang AST dump on file:", file,
                 "Reproduce with command:", c.replace("2>> errors", ""),
                 "or look at file 'errors'.")


def gen_vec(project_attribute, file, func_or_struct, start, end, Deckard=True):
    v = ASTVector.ASTVector(file, func_or_struct, start, end, Deckard)
    if not v.vector:
        return None
    if file in project_attribute.keys():
        project_attribute[file][func_or_struct] = v
    else:
        project_attribute[file] = dict()
        project_attribute[file][func_or_struct] = v
    return v


def parseAST(filepath, proj, Deckard=True):
    try:
        gen_AST(filepath, proj.path)
        # Path to the AST file generated by gen_AST
        AST = filepath + ".AST"
    except Exception as e:
        err_exit(e, "Unexpected error in gen_AST with file:", filepath)
    # Keep functions here
    function_lines = []
    # Keep structures here
    structure_lines = []
    # Keep variables for each function d[function] = "typevar namevar; ...;"
    dict_file = dict()
    # If we're inside the tree parsing a function
    in_function = False
    # If we're inside the tree parsing a struct
    in_struct = False
    # Start and ending line of the function/struct
    start = 0
    end = 0
    
    if Deckard:
        Print.grey("Generating vectors for " + filepath.split("/")[-1])
        
    with open(AST, 'r', errors='replace') as f:
        # A line is a node of the AST
        line = f.readline().strip()
        # Skip irrelevant things
        while line:
            if filepath in line:
                break
            line = f.readline().strip()
        # We find Function declarations and retrieve parameters and variables
        while line:
            if "-FunctionDecl " in line and "col:" not in line:
                in_struct = False
                line = line.split(" ")
                if line[-1] != "extern":
                    line = remove_Hexa(line)
                    # col: appears for .h files and other references
                    lines_aux = line.split("> ")
                    lines = lines_aux[0].split(" <")[1]
                    if "invalid" not in lines:
                        start = lines_aux[1].split(":")[1]
                        end = lines.split(", ")[1]
                        end = end.split(":")[1]
                        func = line.split(" '")[-2].split(" ")[-1]
                        in_function = True
                        try:
                            start = int(start)
                            end = int(end)
                        except Exception as e:
                            err_exit("Parsing error, not ints.", start, end, 
                                     line, lines_aux, lines, e)
                        function_lines.append((func, start, end))
                        gen_vec(proj.funcs, filepath, func, start, end, Deckard)
                    else:
                        in_function = False
                else:
                    in_function = False
            # TODO: Distinguish locally defined structures
            # (otherwise, line superposition!)
            elif in_function and ("VarDecl " in line):
                in_struct = False
                line = "-".join(line.split("-")[1:]).split(" ")
                line = remove_Hexa(line).split(" '")
                # TODO: Get variable types
                var_type = " '".join(line[1:]).split("'")[0]
                line = line[0].split(" ")
                line = line[0].replace("Decl", "") + " " + line[-1]
                line = line.replace("  ", "").split(" ")
                line = line[0] + " " + var_type + " " + line[1] + ";"
                if func not in dict_file.keys():
                    dict_file[func] = ""
                dict_file[func] = dict_file[func] + line
            elif ("-RecordDecl " in line) and ("struct" in line):
                in_function = False
                in_struct = True
                line = line.split(" ")
                line = remove_Hexa(line)
                if "invalid" not in line:
                    try:
                        lines = line.split("> ")[0].split(" <")[1].split(",")
                        start = lines[0].split(":")[1]
                        end = lines[1].split(":")[1]
                    except:
                        err_exit(line, lines, "RecordDecl error")
            elif in_struct and ("-FieldDecl" in line):
                if False:
                    Print.green("\t" + line)
            elif in_struct and ("-TypedefDecl" in line):
                try:
                    if len(line) > 2 and start and end:
                        struct = line.split(" '")[-2].split(" ")[-1]
                        structure_lines.append((struct, int(start), int(end)))
                        gen_vec(proj.structs, filepath, struct, start, end,
                                False)    
                except Exception as e:
                    err_exit(e)
                in_struct = False
            line = f.readline().strip()
    
    with open('output/function-lines', 'w') as func_l:
        for l in function_lines:
            func_l.write(l[0] + " " + str(l[1]) + "-" + str(l[2]) + "\n")
    with open('output/function-vars', 'w') as func_l:
        for func in dict_file.keys():
            func_l.write(func + "\n")
            for line in dict_file[func].split(";"):
                func_l.write("\t" + line.replace("  ", "") + "\n")
    if Deckard:
        get_vars(proj, filepath, dict_file)
    return function_lines, dict_file


def get_vars(proj, file, dict_file):
    for func in dict_file.keys():
        for line in dict_file[func].split(";"):
            if file in proj.funcs.keys():
                if func in proj.funcs[file].keys():
                    if "ParmVar" in line:
                        proj.funcs[file][func].params.append(line.replace("  ", "").replace("ParmVar ", ""))
                    else:
                        proj.funcs[file][func].variables.append(line.replace("  ", "").replace("Var ", ""))
                        
    
def gen_ASTs():
    # Generates an AST file for each .c file
    find_files(Pc.path, "*.c", "output/Cfiles")
    with open("output/Cfiles", 'r', errors='replace') as files:
        file = files.readline().strip()
        while file:
            # Parses it to remove useless information (for us) and gen vects
            try:
                parseAST(file, Pc)
            except Exception as e:
                err_exit(e, "Unexpected error in parseAST with file:", file)
            file = files.readline().strip()


def intersect(start, end, start2, end2):
    return not (end2 < start or start2 > end)


def find_diff_files():
    global Pa, Pb
    extensions = get_extensions(Pa.path, "output/files1")
    extensions = extensions.union(get_extensions(Pb.path, "output/files2"))
    with open('output/exclude_pats', 'w', errors='replace') as exclusions:
        for pattern in extensions:
            exclusions.write(pattern + "\n")
    c = "diff -ENBbwqr " + Pa.path + " " + Pb.path + \
        " -X output/exclude_pats | grep '\.c ' > output/diff"
    exec_com(c, False)


def find_affected_funcs(proj, file, pertinent_lines):
    try:
        function_lines, dict_file = parseAST(file, proj, False)
    except Exception as e:
        err_exit(e, "Error in parseAST.")
    for function, start, end in function_lines:
        for start2, end2 in pertinent_lines:
            if intersect(start, end, start2, end2):
                Print.rose("\t\tFound affected function: ")
                Print.grey("\t\t\tGenerating vector for " + \
                            function +" in "+ file.split("/")[-1])
                if file not in proj.funcs.keys():
                    proj.funcs[file] = dict()
                if function not in proj.funcs[file]:
                    proj.funcs[file][function] = dict()
                proj.funcs[file][function] = ASTVector.ASTVector(file, 
                                                                 function,
                                                                 start, end, True)
    get_vars(proj, file, dict_file)
    return function_lines, dict_file
    
    
def gen_diff():
    global Pa, Pb
    nums = "0123456789"
    Print.blue("Finding differing files...")
    find_diff_files()
    
    Print.blue("Starting fine-grained diff...\n")
    with open('output/diff', 'r', errors='replace') as diff:
        diff_line = diff.readline().strip()
        while diff_line:
            diff_line = diff_line.split(" ")
            file_a = diff_line[1]
            file_b = diff_line[3]
            c = "diff -ENBbwr " + file_a + " " + file_b + " > output/file_diff"
            exec_com(c, False)
            pertinent_lines = []
            pertinent_lines_b = []
            with open('output/file_diff', 'r', errors='replace') as file_diff:
                file_line = file_diff.readline().strip()
                while file_line:
                    # In file_diff, line starts with a number, <, >, or -.
                    if file_line[0] in nums:
                        # change (delete + add)
                        if 'c' in file_line:
                            l = file_line.split('c')
                        elif 'd' in file_line:
                            l = file_line.split('d')
                        elif 'a' in file_line:
                            l = file_line.split('a')
                        # range for file_a
                        a = l[0].split(',')
                        start_a = int(a[0])
                        end_a = int(a[-1])
                        # range for file_b
                        b = l[1].split(',')
                        start_b = int(b[0])
                        end_b = int(b[-1])
                        # Pertinent lines in file_a
                        pertinent_lines.append((start_a, end_a))
                        pertinent_lines_b.append((start_b, end_b))
                    file_line = file_diff.readline().strip()
            try:
                Print.blue("\t Project Pa...")
                find_affected_funcs(Pa, file_a, pertinent_lines)
                Print.blue("")
                Print.blue("\t Project Pb...")
                find_affected_funcs(Pb, file_b, pertinent_lines)
            except Exception as e:
                err_exit(e, "HERE")
                        
            diff_line = diff.readline().strip()

    
def norm(v):
    return sum(v[i]**2 for i in range(len(v)))**(1/2)    


def normed(v):
    n = norm(v)
    return [i/n for i in v]
    

def dist(u, v):
    assert(len(u)==len(v))
    return sum(((u[i] - v[i])**2) for i in range(len(u)))

    
def get_vector_list(src_path, filepath):
    find_files(src_path, "*.vec", filepath)
    with open(filepath, "r", errors='replace') as file:
        files = [vec.strip() for vec in file.readlines()]
    vecs = []
    for i in range(len(files)):
        with open(files[i], 'r', errors='replace') as vec:
            fl = vec.readline()
            if fl:
                v = [int(s) for s in vec.readline().strip().split(" ")]
                v = normed(v)
                vecs.append((files[i],v))
    return vecs
                
    
def compare():
    global Pa, Pc
    Print.blue("Getting vectors for Pa...")
    vecs_A = get_vector_list(Pa.path, "output/output_A")
    Print.blue("Getting vectors for Pc...")
    vecs_C = get_vector_list(Pc.path, "output/output_C")
    
    Print.blue("Variable mapping...")
    to_patch = []
    for i in vecs_A:
        best = vecs_C[0]
        best_d = dist(i[1], best[1])
        for j in vecs_C:
            d = dist(i[1],j[1])
            if d < best_d:
                best = j
                best_d = d
        # We go up to -4 to remove the ".vec" part
        fa = i[0].replace(Pa.path, "")[:-4].split(".")
        f_a = fa[-1]
        file_a = ".".join(fa[:-1])
        fc = best[0].replace(Pc.path, "")[:-4].split(".")
        f_c = fc[-1]
        file_c = ".".join(fc[:-1])
        # TODO: Get all pertinent matches (at dist d' < k*best_d)
        Print.blue("\tBest match for function " + f_a +" in $Pa/" + file_a + ":")
        Print.blue("\t\tDistance: " + str(best_d) + "\t" + f_c + " in $Pc/" + file_c)
        Print.blue("\tVariable mapping from " + f_a + " to " + f_c + ":")
        var_map = detect_matching_variables(f_a, file_a, f_c, file_c)
        with open('output/var-map', 'r', errors='replace') as mapped:
            mapping = mapped.readline().strip()
            while mapping:
                Print.grey("\t\t" + mapping)
                mapping = mapped.readline().strip()
        to_patch.append((Pa.funcs[Pa.path + file_a][f_a],
                         Pc.funcs[Pc.path + file_c][f_c], var_map))
    return to_patch
    
def path_exception():
    m = "ValueError Exception: Incorrect directory path"
    return ValueError(m)    
    
def run_crochet():
    global Pa, Pb, Pc
    # Little crochet introduction
    Print.start()
    
    # Time for final running time
    start = time.time()
    
    # Prepare projects directories by getting paths and cleaning residual files
    Print.title("Preparing projects...")
    with open('crochet.conf', 'r', errors='replace') as file:
        args = [i.strip() for i in file.readlines()]
    if (len(args) < 3):
        err_exit("Insufficient arguments: Pa, Pb, Pc source paths required.",
                 "Try running:", "\tpython3 ASTcrochet.py $Pa $Pb $Pc")
    Pa = Project.Project(args[0], "Pa")
    Pb = Project.Project(args[1], "Pb")
    Pc = Project.Project(args[2], "Pc")
    clean()
    Print.rose("Successful cleaning, after " + str(time.time() - start) + \
               " seconds.")
    # Generates vectors for pertinent functions (modified from Pa to Pb)
    Print.title("Getting modified functions in Pa and generating vectors...")   
    try:
        gen_diff()
        Print.rose("Functions successfully found, after " + \
                    str(time.time() - start) + " seconds.")
    except Exception as e:
        err_exit(e, "Unexpected error while finding relevant functions.")
    
    # Generates vectors for all functions in Pc
    Print.title("Generating vectors for functions in Pc...")
    try:
        gen_ASTs()
        Print.rose("Vectors for Pc successfully generated, after " + \
                    str(time.time() - start) + " seconds.")
    except Exception as e:
        err_exit(e, "Unexpected error while generating vectors.")

    # Pairwise vector comparison for matching
    Print.title("Starting pairwise vector comparison for matching...")
    try:
        to_patch = compare()
        Print.rose("Successful comparison, after " + \
                    str(time.time() - start) + " seconds.")
    except Exception as e:
        err_exit(e, "Unexpected error while doing pairwise comparison.")
    
    # Matching variables
    # TODO: Variable and structural matching
    
    # Using all previous structures to transplant patch
    Print.title("Starting patch transplantation...")
    try:
        transplantation(to_patch)
        Print.rose("Successful patch proposal, after " + \
                    str(time.time() - start) + " seconds.")
    except Exception as e:
        err_exit(e, "Unexpected error in transplantation algorithm.")
    # TODO: Transplant patch
    
    # Final clean
    Print.title("Cleaning residual files generated by Crochet...")
    
    # Final running time and exit message
    end = time.time()
    Print.exit_msg(start, end)
    
    
def test_parsing():
    project = "/media/pedrobw/6A384D7F384D4AF1/Users/Administrator/" + \
              "Examples/Backporting/Buffer_Overflow-Espruino/Pc/"
    file = project + "targetlibs/stm32f2/lib/stm32f2xx_hash_sha1.c"
    gen_AST(file, project)    
    #parseAST(file)
    
def longestSubstringFinder(string1, string2):
    answer = ""
    maxlen = min(len(string1), len(string2))
    i = 0
    while i < maxlen:
        if string1[i] != string2[i]:
            break
        answer += string1[i]
        i += 1
    return answer
    
def generate_ast_map(source_a, source_b):
    common_path = longestSubstringFinder(source_a, source_b).split("/")[:-1]
    common_path = "/".join(common_path)
    ast_diff_command = "docker run -v " + common_path + ":/diff gumtree " + \
                        "diff " + source_a.replace(common_path, "/diff") + \
                        " " + source_b.replace(common_path, "/diff") + \
                        " | grep -P 'Match GenericString: [A-Za-z0-9_]*\('" + \
                        " > output/ast-map "
    exec_com(ast_diff_command, False)
    

def detect_matching_variables(f_a, file_a, f_c, file_c):
    variable_mapping = dict()
    generate_ast_map(Pa.path + "/" + file_a, Pb.path + "/" + file_a)
    
    function_b = Pb.funcs[Pb.path + file_a][f_a]
    variable_list_b = function_b.variables + function_b.params
    #Print.white(variable_list_b)
    while '' in variable_list_b:
        variable_list_b.remove('')
        
    b_names = [i.split(" ")[-1] for i in variable_list_b]
        
    function_c = Pc.funcs[Pc.path + file_c][f_c]
    variable_list_c = function_c.variables + function_c.params
    #Print.white(variable_list_c)
    while '' in variable_list_c:
        variable_list_c.remove('')

    ast_map = dict()
    with open("output/ast-map", "r", errors='replace') as ast_map_file:
        map_line = ast_map_file.readline().strip()
        while map_line:
            aux = map_line.split(" to ")
            var_b = aux[0].split("(")[0].split(" ")[-1]
            var_c = aux[1].split("(")[0].split(" ")[-1]
            if var_b in b_names:
                if var_b not in ast_map:
                    ast_map[var_b] = dict()
                if var_c in ast_map[var_b]:
                    ast_map[var_b][var_c] += 1
                else:
                    ast_map[var_b][var_c] = 1
            map_line = ast_map_file.readline().strip()


    while len(variable_list_b):
        var_b = variable_list_b.pop()        
        if var_b not in variable_mapping.keys():
            b_name = var_b.split(" ")[-1]
            if b_name in ast_map.keys():
                max_match = -1
                best_match = None
                for var_c in ast_map[b_name].keys():
                    if max_match == -1:
                        max_match = ast_map[b_name][var_c]
                        best_match = var_c
                    elif ast_map[var_b][var_c] > max_match:
                        max_match = ast_map[var_b][var_c]
                        best_match = var_c
                if best_match:
                    for var_c in variable_list_c:
                        c_name = var_c.split(" ")[-1]
                        if c_name == best_match:
                            variable_mapping[var_b] = var_c
            if var_b not in variable_mapping.keys():
                variable_mapping[var_b] = "UNKNOWN"

    #generate_variable_slices(function_a_name, function_b_source_path, project_B['dir_path'])
    with open("output/var-map", "w", errors='replace') as var_map_file:
        for var_b in variable_mapping.keys():
            var_map_file.write(var_b + " -> " + variable_mapping[var_b] + "\n")
    
    return variable_mapping
    
def transplantation(to_patch):
    Print.blue("Generating edit script from Pa to Pb")
    for (ast_vec_f_a, ast_vec_f_c,var_map) in to_patch:
        
        start = ast_vec_f_a.start
        end = ast_vec_f_a.end
        Print.blue("Start line: " + str(start))
        Print.blue("End line: " + str(end))
        
        with open("output/temp_a.c", 'w') as temp_a:
            with open(ast_vec_f_a.file, 'r', errors='replace') as file_a:
                lines = file_a.readlines()
                while (start > 0):
                    j = start-1
                    if ("}" in lines[j]) or ("#include" in lines[j]):
                        break
                    start = j
                Print.blue("Lines in file in Pa: " + str(len(lines)))
                temp_a.write("".join(lines[start:end]))
            temp_a.write("\n")
            
        start = ast_vec_f_c.start
        end = ast_vec_f_c.end
        Print.blue("Start line: " + str(start))
        Print.blue("End line: " + str(end))
        with open("output/temp_c.c", 'w') as temp_c:
            with open(ast_vec_f_c.file, 'r', errors='replace') as file_c:
                lines = file_c.readlines()
                while (start > 0):
                    j = start-1
                    if ("}" in lines[j]) or ("#include" in lines[j]):
                        break
                    start = j
                Print.blue("Lines in file in Pa: " + str(len(lines)))
                temp_c.write("".join(lines[start:end]))
            temp_c.write("\n")
        
        exec_com("docker run -v $PWD/output:/diff gumtree " + \
                 "diff temp_a.c temp_c.c > output/diff_script_AC")
        #print(ast_vec_f_a.function, ast_vec_f_a.file, ast_vec_f_c.function, ast_vec_f_c.file)\
        
        
    
def transplant_patch_to_function(f_a, file_a, f_c, file_c, var_map):
    print("TRANSPLANT")
    
if __name__=="__main__":
    #test_parsing()
    try:
        run_crochet()
    except KeyboardInterrupt as e:
        err_exit("Program Interrupted by User")